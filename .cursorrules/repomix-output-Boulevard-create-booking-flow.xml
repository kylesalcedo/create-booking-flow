This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    github-actions.yml
components/
  atoms/
    formik/
      ts/
        utils.ts
      wizard/
        WizardButtons.tsx
      TextFieldBase.tsx
    layout/
      mobile/
        BackHeader.tsx
        useStyles.ts
      selectable-list-item/
        Caption.tsx
        Price.tsx
        SelectableListBtn.tsx
        SelectableListItem.tsx
        useStyles.ts
      service/
        ServiceAvailableBookableItem.tsx
        ServiceCartBookableItemCaption.tsx
        ServicePrice.tsx
      summary/
        LeftSummary.tsx
        Location.tsx
        PersonalInfo.tsx
        Service.tsx
        Services.tsx
        SummaryItem.tsx
        SummaryItemBase.tsx
        Time.tsx
      LayoutContext.ts
      LayoutListItem.tsx
      useWithLayoutStyles.ts
      WithLayout.tsx
    AppHead.tsx
  blocks/
    BlockContainer.tsx
    BlockRenderer.tsx
    BookingSuccessBlock.tsx
    ChooseDateBlock.tsx
    ChooseLocationBlock.tsx
    LoadingStepBlock.tsx
    PayAndConfirmBlock.tsx
    PersonalInfoBlock.tsx
    SelectedServicesBlock.tsx
    SelectOptionsBlock.tsx
    SelectServiceBlock.tsx
  Container/
    index.tsx
  icons/
    ArrowLeft.tsx
    ArrowRight.tsx
    Calendar.tsx
    CalendarDark.tsx
    Cart.tsx
    CheckboxIcon.tsx
    Checked.tsx
    CheckedCheckboxIcon.tsx
    ChevronDown.tsx
    ChevronUp.tsx
    color-props.ts
    Cross.tsx
    DatePickerIcon.tsx
    index.ts
    List.tsx
    LocationPin.tsx
    Map.tsx
    MapPin.tsx
    MapPinIcon.tsx
    Search.tsx
    SearchClear.tsx
    TrashCan.tsx
    User.tsx
  molecules/
    CartInitializer/
      CartDefinition.tsx
      Flow.ts
      FlowFactory.ts
      LocationFirst.ts
      ServiceFirst.ts
    CustomFormControlLabel/
      index.tsx
    DefineLocation/
      Google/
        GoogleDefineLocation.tsx
        useGoogleActions.ts
      Mapbox/
        MapboxDefineLocation.tsx
        useMapboxActions.ts
      DefineLocation.tsx
      DefineLocationFactory.tsx
      theme.ts
      useActions.ts
      useStyles.ts
    Header/
      AppSettings.tsx
      AppSettingsPopper.tsx
      CartItem.tsx
      index.tsx
      Logo.tsx
      PopperContent.tsx
      PopperDateTime.tsx
      PopperItemBase.tsx
      PopperLocation.tsx
      PopperPersonalInfo.tsx
      PopperTopRow.tsx
      Progress.tsx
      Steps.tsx
      useHeader.ts
      useStyles.ts
    Map/
      Google/
        MapStore.tsx
        MapStoreInfoWindow.tsx
        MapStores.tsx
        SelectedStoreMapGoogle.tsx
        styles.ts
      Mapbox/
        cursors.ts
        CustomMarker.tsx
        CustomStorePopup.tsx
        Layers.ts
        MapView.tsx
        SelectedStoreMap.tsx
      helper.ts
      MapFactory.tsx
      PopupCommon.tsx
    MobileSelectedServiceSelector/
      index.tsx
      useStyles.ts
    MobileSummary/
      index.tsx
    PaymentSummaryControl/
      index.tsx
      useStyles.ts
    Services/
      BookingSuccess/
        index.tsx
      ChooseDate/
        ManyDays/
          SelectAvailability.tsx
          SelectTime.tsx
          ShowTimeForManyDaysComponent.tsx
        OneDay/
          DayTimes.tsx
          SelectTime.tsx
          ShowTimeForOneDayComponent.tsx
          StaffsInfoList.tsx
        ChooseDateScreen.tsx
        DisplayTime.tsx
        SelectDate.tsx
        SelectedTime.tsx
        ServerError.tsx
        Time.tsx
        WorkshopPanel.tsx
      ChooseLocation/
        ChooseLocationScreen.tsx
        LeftPanel.tsx
        LocationDistance.tsx
        RightPanel.tsx
        SelectStore.tsx
        StoreList.tsx
        useLeftPanel.ts
        useStyles.ts
      ChooseStaff/
        SelectedButton.tsx
        Staff.tsx
        StaffsList.tsx
        useStyles.ts
      PayAndConfirm/
        ts/
          constants.ts
          types.ts
          useButtons.ts
        BLVDLogo.tsx
        CardHoldersName.tsx
        CreditCardNumber.tsx
        ExpirationCVCAndZipcode.tsx
        PayAndConfirmScreen.tsx
        PaymentAndTerms.tsx
        PaymentInfo.tsx
        PaymentSummary.tsx
        Terms.tsx
      PersonalInfo/
        Questions/
          CartBookingQuestionDisplayType.ts
          QuestionCheckbox.tsx
          QuestionDatetime.tsx
          QuestionElement.tsx
          QuestionFloat.tsx
          QuestionInteger.tsx
          QuestionLongText.tsx
          QuestionMultiselect.tsx
          QuestionSelect.tsx
          QuestionShortText.tsx
        ts/
          constants.ts
          formikUtils.ts
          useButtons.ts
        AdditionalInfo.tsx
        BasicInfo.tsx
        ContactInfo.tsx
        EmailPhone.tsx
        FirstLastName.tsx
        PersonalInfoScreen.tsx
        YourAndAdditionalInfo.tsx
        YourInfoForm.tsx
      SelectedServices/
        AvailableServiceOption.tsx
        AvailableServiceOptions.tsx
        DurationPrice.tsx
        MobileAddAnotherService.tsx
        MobileRightSection.tsx
        Option.tsx
        RightPanel.tsx
        SelectedOption.tsx
        SelectedOptions.tsx
        SelectedServices.tsx
        SelectedServicesScreen.tsx
        SelectedTime.tsx
        Service.tsx
        ServiceStaff.tsx
        StaffError.tsx
        useSelectedServiceChange.ts
        useStyles.ts
        WithService.tsx
        WorkshopPanel.tsx
      SelectOptions/
        LeftPanel.tsx
        MobileRightSection.tsx
        Option.tsx
        OptionsList.tsx
        RightPanel.tsx
        SelectedButton.tsx
        SelectOptionsScreen.tsx
        useStyles.ts
        WorkshopPanel.tsx
      SelectService/
        CategoriesList.tsx
        Category.tsx
        LeftPanel.tsx
        SelectServiceScreen.tsx
        Service.tsx
        ServiceSearch.tsx
        ServicesList.tsx
        useStyles.ts
        WorkshopPanel.tsx
    FlowRouting.tsx
    GeoLocation.tsx
    ServerError.tsx
config/
  brand.json
  colors.json
  fonts.json
constants/
  colors.ts
  regexps.ts
  styles.ts
enums/
  colors.ts
lib/
  analytics-api/
    analyticsService.ts
    googleAnalyticsUtils.ts
    types.ts
  geojson/
    GeoJSON.ts
  sdk/
    hooks/
      useConfig.ts
      useStores.ts
      useUrlParams.ts
    blvd.ts
  state/
    booking-answers/
      index.ts
      types.ts
    booking-flow/
      index.ts
      types.ts
    cart/
      index.ts
      types.ts
    config/
      index.ts
    currentPosition/
      index.ts
      types.ts
    error/
      enums.ts
      index.ts
    flow-routing/
      index.ts
    location/
      index.ts
      types.ts
    payment-info/
      index.ts
      types.ts
    personal-info/
      index.ts
      types.ts
    services/
      index.ts
    staff/
      index.ts
      types.ts
    staffDate/
      index.ts
      types.ts
    staffTime/
      index.ts
      types.ts
    store/
      index.ts
      types.ts
    summary/
      index.ts
    persistence.ts
  styles/
    fonts.scss
    styles.daypicker.scss
    styles.scss
    theme.tsx
  utils/
    durationUtils.ts
    formatCurrency.ts
    formatDateFns.ts
    getMobileOperatingSystem.ts
    getTimeZoneAbbr.ts
    locationUtils.ts
    numberUtils.ts
    sortUtils.ts
    stepUtils.ts
    stringUtils.ts
    useMobile.ts
  wrappers/
    ip-wrapper.ts
    logger.ts
pages/
  _app.tsx
  _document.tsx
  index.tsx
public/
  images/
    arr-l.svg
    arr-r.svg
    image 1.svg
    logo.svg
    logotype.svg
  robots.txt
.eslintrc
.gitignore
.prettierignore
babel.config.json
CONTRIBUTING.md
LICENSE.md
material-ui.d.ts
next-env.d.ts
next.config.js
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/github-actions.yml">
name: "Tagged release"

on:
  push:
    tags:
      - "v*"

jobs:
  tagged-release:
    name: "Tagged Release"
    runs-on: "ubuntu-latest"

    steps:
      # ...
      #- name: "Build & test"
      #  run: |
      #    echo "When we add tests run them!"

      - uses: "marvinpinto/action-automatic-releases@latest"
        with:
          repo_token: "${{ secrets.GITHUB_TOKEN }}"
          prerelease: false
</file>

<file path="components/atoms/formik/ts/utils.ts">
export const getFormikValue = (values: any, fieldName: string) =>
    values[fieldName]
</file>

<file path="components/atoms/formik/wizard/WizardButtons.tsx">
import { useFormikContext } from 'formik'
import { Box, Button } from '@mui/material'
import { useMobile } from 'lib/utils/useMobile'

interface Props {
    onBack: () => void
    showBackButton: boolean
    isFormSubmitting: boolean
    showContinue: boolean
    continueButtonText?: string
}

export default function WizardButtons({
    onBack,
    showBackButton,
    isFormSubmitting,
    showContinue,
    continueButtonText,
}: Props) {
    const { isMobile } = useMobile()
    const { handleSubmit } = useFormikContext()

    return (
        <Box
            sx={{
                pt: 4,
                pb: 4,
                ...(isMobile && {
                    display: 'flex',
                    justifyContent: 'space-between',
                }),
            }}
        >
            {showBackButton && (
                <Button
                    variant="outlined"
                    sx={{
                        marginRight: '13px',
                        ...(isMobile && {
                            width: '50%',
                        }),
                    }}
                    onClick={onBack}
                >
                    Back
                </Button>
            )}
            {showContinue && (
                <Button
                    variant="contained"
                    onClick={() => handleSubmit()}
                    disabled={isFormSubmitting}
                    sx={{
                        ...(isMobile && {
                            width: '50%',
                        }),
                    }}
                >
                    {continueButtonText ? continueButtonText : 'Continue'}
                </Button>
            )}
        </Box>
    )
}
</file>

<file path="components/atoms/formik/TextFieldBase.tsx">
import { TextField } from '@mui/material'
import { useFormikContext } from 'formik'
import { getFormikValue } from 'components/atoms/formik/ts/utils'
import { TextFieldProps } from '@mui/material/TextField/TextField'

type Props = TextFieldProps & {
    id: string
}

export default function TextFieldBase(props: Props) {
    const { id, ...other } = props
    const { handleChange, values } = useFormikContext()

    const getValue = () => {
        return getFormikValue(values, id)
    }

    return (
        <TextField
            id={id}
            name={id}
            value={getValue()}
            InputLabelProps={{
                focused: !!getValue(),
            }}
            onChange={handleChange}
            {...other}
        />
    )
}
</file>

<file path="components/atoms/layout/mobile/BackHeader.tsx">
import { Box, Typography } from '@mui/material'
import { useBackHeaderStyles } from 'components/atoms/layout/mobile/useStyles'
import { ArrowLeft } from 'components/icons/ArrowLeft'

interface Props {
    onClick: () => void
    caption?: string
}

export const BackHeader = ({ onClick, caption }: Props) => {
    const classes = useBackHeaderStyles()
    return (
        <Box className={classes.block} onClick={onClick}>
            <Box className={classes.row}>
                <Box className={classes.arrow}>
                    <ArrowLeft color="black" />
                </Box>
                <Typography variant="h6">{caption}</Typography>
            </Box>
        </Box>
    )
}
</file>

<file path="components/atoms/layout/mobile/useStyles.ts">
import { makeStyles } from '@mui/styles'
import { Theme } from '@mui/material'

export const useBackHeaderStyles = makeStyles((theme: Theme) => ({
    block: {
        padding: theme.spacing(2, 2),
        cursor: 'pointer',
        borderBottom: `1px solid ${theme.palette.custom.lightGray}`,
    },
    row: {
        display: 'flex',
        flexDirection: 'row',
    },
    arrow: {
        marginRight: '20px',
    },
}))
</file>

<file path="components/atoms/layout/selectable-list-item/Caption.tsx">
import { Box, Typography } from '@mui/material'
import { useStyles } from 'components/atoms/layout/selectable-list-item/useStyles'
import { useMobile } from 'lib/utils/useMobile'

interface Props {
    name: string
    durationText?: string
    useBold: boolean
}

export const Caption = ({ name, durationText, useBold }: Props) => {
    const { isMobile } = useMobile()
    const classes = useStyles({ isMobile })
    return (
        <Box className={classes.row}>
            <Box className={classes.cardItemName} sx={{
                fontWeight: useBold ? 'bold' : '',
            }}>
                {name}
                {isMobile &&
                    <Typography component="span" fontSize="16px">
                        {` ${durationText}`}
                    </Typography>
                }
            </Box>
            {!isMobile && <Box className={classes.durationText}>{durationText}</Box>}
        </Box>
    )
}
</file>

<file path="components/atoms/layout/selectable-list-item/Price.tsx">
import { Box } from '@mui/material'

interface Props {
    priceStr: string
    classesCardItemPrice?: any
}

export const Price = ({ priceStr, classesCardItemPrice }: Props) => {
    return (
        <Box component="span" className={classesCardItemPrice}>
            {priceStr}
        </Box>
    )
}
</file>

<file path="components/atoms/layout/selectable-list-item/SelectableListBtn.tsx">
import { Box, Button } from '@mui/material'
import React from 'react'
import { useStyles } from 'components/atoms/layout/selectable-list-item/useStyles'
import { useMobile } from 'lib/utils/useMobile'

interface Props {
    btnName: string
    btnWidth: number
    onSelectClick: () => void
    btnTop?: string
    sxWrapper?: any
    sxButton?: any
}

export const SelectableListBtn = ({
    btnName,
    onSelectClick,
    btnWidth,
    btnTop,
    sxWrapper,
    sxButton,
}: Props) => {
    const { isMobile } = useMobile()
    const classes = useStyles({ isMobile })
    return (
        <Box className={classes.selectBtnWrapper} sx={sxWrapper}>
            <Button
                variant="contained"
                sx={{
                    width: btnWidth,
                    top: btnTop ?? isMobile ? '0px' : '17px',
                    marginTop: isMobile ? '5px!important' : '16px',
                    ...(sxButton ?? {}),
                }}
                className={classes.selectBtn}
                onClick={onSelectClick}
            >
                {btnName}
            </Button>
        </Box>
    )
}
</file>

<file path="components/atoms/layout/selectable-list-item/SelectableListItem.tsx">
import { LayoutListItem } from 'components/atoms/layout/LayoutListItem'
import { Box, Button } from '@mui/material'
import { useStyles } from 'components/atoms/layout/selectable-list-item/useStyles'
import React from 'react'
import { SelectableListBtn } from 'components/atoms/layout/selectable-list-item/SelectableListBtn'
import { useMobile } from 'lib/utils/useMobile'
import clsx from 'clsx'

interface Props {
    captionComponent: React.ReactNode
    priceComponent: React.ReactNode
    description?: string
    btnName: string
    btnWidth: number
    onSelectClick: () => void
    buttonComponent?: React.ReactNode
}

export const SelectableListItem = ({
    captionComponent,
    priceComponent,
    description,
    btnName,
    onSelectClick,
    btnWidth,
    buttonComponent,
}: Props) => {
    const { isMobile } = useMobile()
    const classes = useStyles({ isMobile })
    return (
        <LayoutListItem
            useDefaultCursor={true}
            sx={{
                paddingTop: '19px!important',
                paddingBottom: '16px!important',
            }}
        >
            <Box
                className={clsx(
                    isMobile && classes.column,
                    !isMobile && classes.row
                )}
            >
                <Box
                    sx={{
                        marginRight: '20px',
                    }}
                >
                    {captionComponent}

                    <Box className={classes.cardItemDescBlock}>
                        <Box component="span">{description}</Box>
                    </Box>
                    {priceComponent}
                </Box>

                {buttonComponent}
                {!buttonComponent && (
                    <SelectableListBtn
                        btnWidth={btnWidth}
                        btnName={btnName}
                        onSelectClick={onSelectClick}
                    />
                )}
            </Box>
        </LayoutListItem>
    )
}
</file>

<file path="components/atoms/layout/selectable-list-item/useStyles.ts">
import { makeStyles } from '@mui/styles'
import { Theme } from '@mui/material'

interface StylesProps {
    isMobile: boolean
}

export const useStyles = makeStyles((theme: Theme) => ({
    cardItemPrice: {
        display: 'inline-block',
        textTransform: 'lowercase',
        fontSize: '14px',
        fontWeight: 'bold',
        '&:first-letter': {
            textTransform: 'uppercase',
        },
    },

    selectBtnWrapper: {
        marginLeft: (props: StylesProps) => (props.isMobile ? '0px' : 'auto'),
        marginRight: (props: StylesProps) => (props.isMobile ? '0px' : '32px'),
    },

    selectBtn: {
        height: 38,
        marginTop: theme.spacing(2),
        fontSize: '16px',
        fontWeight: 500,
        textTransform: 'none',
    },

    cardItemDescBlock: {
        paddingTop: '14px',
        marginBottom: '20px',
    },

    row: {
        display: 'flex',
        flexDirection: 'row',
    },

    column: {
        display: 'flex',
        flexDirection: 'column',
    },

    cardItemName: {
        marginRight: '5px',
    },

    durationText: {
        fontSize: '13px',
        marginLeft: '5px',
    },
}))
</file>

<file path="components/atoms/layout/service/ServiceAvailableBookableItem.tsx">
import { CartAvailableBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { getDurationText } from 'lib/utils/durationUtils'
import { Caption } from 'components/atoms/layout/selectable-list-item/Caption'

interface Props {
    bookableItem: CartAvailableBookableItem
}

export const ServiceAvailableBookableItem = ({ bookableItem }: Props) => {
    const durationText = getDurationText(bookableItem)
    return <Caption name={bookableItem.name} durationText={durationText} useBold={true}/>
}
</file>

<file path="components/atoms/layout/service/ServiceCartBookableItemCaption.tsx">
import { CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { getItemAndOptionsDurationText } from 'lib/utils/durationUtils'
import { Caption } from 'components/atoms/layout/selectable-list-item/Caption'
import { useCartMethods } from 'lib/state/cart'

interface Props {
    bookableItem: CartBookableItem
    useBold: boolean
}

export const ServiceCartBookableItemCaption = ({ bookableItem, useBold }: Props) => {
    let durationText = ''
    const { isCartAvailableBookableItem } = useCartMethods()
    if (isCartAvailableBookableItem(bookableItem.item)) {
        durationText = getItemAndOptionsDurationText(bookableItem)
    }

    return <Caption name={bookableItem.item.name} durationText={durationText} useBold={useBold} />
}
</file>

<file path="components/atoms/layout/service/ServicePrice.tsx">
import { CartAvailableBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { FreePrice, PriceLabelByRange } from 'lib/utils/formatCurrency'
import { Price } from 'components/atoms/layout/selectable-list-item/Price'

interface Props {
    bookableItem: CartAvailableBookableItem
    classesCardItemPrice?: any
}

export const ServicePrice = ({ bookableItem, classesCardItemPrice }: Props) => {
    const price = PriceLabelByRange(bookableItem.listPriceRange)
    const priceStr = price === FreePrice ? price : `Starting from ${price}`
    return (
        <Price
            classesCardItemPrice={classesCardItemPrice}
            priceStr={priceStr}
        />
    )
}
</file>

<file path="components/atoms/layout/summary/LeftSummary.tsx">
import { Box } from '@mui/material'
import { Location } from 'components/atoms/layout/summary/Location'
import { useFlowStep } from 'lib/state/booking-flow'
import { Step } from 'lib/state/booking-flow/types'
import { Services } from 'components/atoms/layout/summary/Services'
import { PersonalInfo } from 'components/atoms/layout/summary/PersonalInfo'

export const LeftSummary = () => {
    const { currentFlowStep } = useFlowStep()

    if (currentFlowStep.step === Step.ChooseLocation) {
        return <></>
    }

    return (
        <Box>
            <Location />
            <Services />
            <PersonalInfo />
        </Box>
    )
}
</file>

<file path="components/atoms/layout/summary/Location.tsx">
import React from 'react'
import { Typography } from '@mui/material'
import { getLocationName } from 'lib/utils/locationUtils'
import { useCartStoreState } from 'lib/state/store'
import { useDefaultBlvdLocationState } from 'lib/state/cart'
import { Step } from 'lib/state/booking-flow/types'
import { SummaryItemBase } from 'components/atoms/layout/summary/SummaryItemBase'

export const Location = () => {
    const selectedStore = useCartStoreState()
    const defaultBlvdLocationState = useDefaultBlvdLocationState()
    if (!selectedStore) {
        return <></>
    }
    return (
        <SummaryItemBase
            isEditable={!defaultBlvdLocationState}
            step={Step.ChooseLocation}
        >
            <Typography variant="body2">
                {getLocationName(selectedStore)}
            </Typography>
        </SummaryItemBase>
    )
}
</file>

<file path="components/atoms/layout/summary/PersonalInfo.tsx">
import React from 'react'
import { Typography } from '@mui/material'
import { usePersonalInformationState } from 'lib/state/personal-info'
import { Step } from 'lib/state/booking-flow/types'
import { SummaryItemBase } from 'components/atoms/layout/summary/SummaryItemBase'
import { useFlowStep } from 'lib/state/booking-flow'

export const PersonalInfo = () => {
    const { currentFlowStep } = useFlowStep()
    const [personalInformation] = usePersonalInformationState()

    if (
        (!personalInformation.firstName && !personalInformation.lastName) ||
        currentFlowStep.step !== Step.PayAndConfirm
    ) {
        return <></>
    }

    return (
        <SummaryItemBase isEditable={true} step={Step.PersonalInfo}>
            <Typography variant="body1">
                {`${personalInformation.firstName} ${personalInformation.lastName}`}
            </Typography>
        </SummaryItemBase>
    )
}
</file>

<file path="components/atoms/layout/summary/Service.tsx">
import { CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { SummaryItem } from 'components/atoms/layout/summary/SummaryItem'
import { MapPin } from 'components/icons'
import { Step } from 'lib/state/booking-flow/types'
import React from 'react'
import { useCartBookableItemListStaff } from 'lib/state/staff'
import { Box } from '@mui/material'
import { DatePickerIcon } from 'components/icons/DatePickerIcon'

interface Props {
    bookableItem: CartBookableItem
}

export const Service = ({ bookableItem }: Props) => {
    const cartBookableItemListStaff = useCartBookableItemListStaff()
    const staff = cartBookableItemListStaff?.find(
        (s) => s.cartBookableItemId === bookableItem.id
    )?.staff

    const staffName = staff ? `with ${staff.name}` : 'with first available'
    const text = `${bookableItem.item.name} ${staffName}`
    return (
        <SummaryItem
            key={bookableItem.id}
            icon={<DatePickerIcon />}
            isEditable={true}
            step={Step.SelectedServices}
            textHtml={
                <Box
                    sx={{
                        textTransform: 'none',
                    }}
                >
                    {text}
                </Box>
            }
        />
    )
}
</file>

<file path="components/atoms/layout/summary/Services.tsx">
import React from 'react'
import { Step } from 'lib/state/booking-flow/types'
import { useFlowStep } from 'lib/state/booking-flow'
import {
    useSelectedServices,
    useSetActiveSelectedService,
} from 'lib/state/services'
import { WithService } from 'components/molecules/Services/SelectedServices/WithService'
import { SummaryItemBase } from 'components/atoms/layout/summary/SummaryItemBase'
import { CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { theme } from 'styles/theme'

export const Services = () => {
    const { currentFlowStep } = useFlowStep()
    const { selectedServicesStateValue, reverseSelectedServices } =
        useSelectedServices()
    const reversedList = reverseSelectedServices(selectedServicesStateValue)
    const setActiveSelectedService = useSetActiveSelectedService()

    if (
        currentFlowStep.step !== Step.ChooseDate &&
        currentFlowStep.step !== Step.PersonalInfo &&
        currentFlowStep.step !== Step.PayAndConfirm
    ) {
        return <></>
    }
    const onEdit = (bookableItem: CartBookableItem) => {
        setActiveSelectedService(bookableItem)
    }
    return (
        <>
            {reversedList?.map((bookableItem: CartBookableItem) => (
                <SummaryItemBase
                    key={bookableItem.id}
                    padding={theme.spacing(0)}
                    step={Step.SelectedServices}
                    onEdit={() => onEdit(bookableItem)}
                    isEditable={true}
                >
                    <WithService
                        isReadMode={true}
                        hideBorderBottom={true}
                        bookableItem={bookableItem}
                    />
                </SummaryItemBase>
            ))}
        </>
    )
}
</file>

<file path="components/atoms/layout/summary/SummaryItem.tsx">
import { Box, Theme, Typography } from '@mui/material'
import React from 'react'
import { createStyles, makeStyles } from '@mui/styles'
import { Step } from 'lib/state/booking-flow/types'
import { useFlowStep } from 'lib/state/booking-flow'
import { SummaryItemBase } from 'components/atoms/layout/summary/SummaryItemBase'

interface StylesProps {
    isIconExist: boolean
}

const useStyles = makeStyles((theme: Theme) =>
    createStyles({
        infoText: {
            paddingLeft: (props: StylesProps) =>
                props.isIconExist ? theme.spacing(1) : 0,
            paddingRight: theme.spacing(1),
            fontSize: 16,
            textTransform: 'capitalize',
        },
    })
)

interface Props {
    icon?: JSX.Element
    text?: string
    textHtml?: React.ReactNode
    step: Step
    isEditable: boolean
}

export const SummaryItem = ({
    icon,
    text,
    step,
    isEditable,
    textHtml,
}: Props) => {
    const isIconExist = !!icon
    const classes = useStyles({ isIconExist })

    return (
        <SummaryItemBase step={step} isEditable={isEditable}>
            {icon}
            <Typography className={classes.infoText} variant="body1">
                {text}
                {textHtml}
            </Typography>
        </SummaryItemBase>
    )
}
</file>

<file path="components/atoms/layout/summary/SummaryItemBase.tsx">
import { Box, Theme, Typography } from '@mui/material'
import React from 'react'
import { createStyles, makeStyles } from '@mui/styles'
import { Step } from 'lib/state/booking-flow/types'
import { useFlowStep } from 'lib/state/booking-flow'
import { useMobile } from 'lib/utils/useMobile'
import { useIsSummaryBlockOpenState } from 'lib/state/summary'
interface StylesProps {
    isMobile: boolean
}

const useStyles = makeStyles((theme: Theme) =>
    createStyles({
        infoBlock: {
            display: 'flex',
            flexDirection: 'row',
            justifyContent: 'flex-start',
            alignItems: 'center',
            borderBottom: `1px solid ${theme.palette.custom.lightGray}`,
            margin: (props: StylesProps) => (!props.isMobile ? 0 : theme.spacing(0, -3)),
            paddingRight: (props: StylesProps) => (!props.isMobile ? theme.spacing(3) : 0),
            '&:first-child': {
                height: (props: StylesProps) => (!props.isMobile ? '57px' : 'auto'),
                borderBottom: (props: StylesProps) => (!props.isMobile ? '1px solid #C4C4C4' : `1px solid ${theme.palette.custom.lightGray}`),
                boxShadow: (props: StylesProps) => (!props.isMobile ? '0px 1px 2px rgba(0, 0, 0, 0.25)' : 'none'),
            },
        },
        editButton: {
            paddingRight: (props: StylesProps) => (!props.isMobile ? 0 : theme.spacing(3)),
            cursor: 'pointer',
            marginLeft: 'auto',
        },
    })
)

interface Props {
    children?: React.ReactNode
    step?: Step
    isEditable: boolean
    padding?: string
    onEdit?: () => void
}

export const SummaryItemBase = ({
    children,
    step,
    isEditable,
    padding,
    onEdit,
}: Props) => {
    const { isMobile } = useMobile()
    const classes = useStyles({ isMobile })
    const { setStep } = useFlowStep()
    const [isSummaryBlockOpen, setIsSummaryBlockOpen] =
        useIsSummaryBlockOpenState()

    const onEditClick = async () => {
        if (isSummaryBlockOpen) {
            setIsSummaryBlockOpen(false)
        }
        if (onEdit) {
            onEdit()
        }
        if (step) {
            await setStep(step)
        }
    }

    return (
        <Box
            className={classes.infoBlock}
            sx={{
                padding: padding ?? 2,
                paddingRight: !isMobile ? 0 : 2,
            }}
        >
            {children}
            {isEditable && (
                <Typography
                    className={classes.editButton}
                    variant="subtitle2"
                    onClick={onEditClick}
                >
                    Edit
                </Typography>
            )}
        </Box>
    )
}
</file>

<file path="components/atoms/layout/summary/Time.tsx">
import React from 'react'
import { Typography } from '@mui/material'
import { Calendar } from 'components/icons'
import { SummaryItem } from 'components/atoms/layout/summary/SummaryItem'
import { useMobile } from 'lib/utils/useMobile'
import formatDateFns, { cartTimeToDate } from 'lib/utils/formatDateFns'
import { useCartState } from 'lib/state/cart'
import { useCartStoreState } from 'lib/state/store'
import { Step } from 'lib/state/booking-flow/types'
import { useFlowStep } from 'lib/state/booking-flow'

export const Time = () => {
    const { currentFlowStep } = useFlowStep()
    const { isMobile } = useMobile()
    const cartState = useCartState()
    const store = useCartStoreState()
    const startTime = cartState?.startTime

    if (
        !startTime ||
        (currentFlowStep.step !== Step.PersonalInfo &&
            currentFlowStep.step !== Step.PayAndConfirm)
    ) {
        return <></>
    }

    return (
        <SummaryItem
            isEditable={true}
            step={Step.ChooseDate}
            textHtml={
                <>
                    <Typography variant="h4" component="span">
                        {formatDateFns(
                            cartTimeToDate(startTime),
                            store?.location.tz,
                            `${!isMobile ? 'EEEE' : 'EEE'} MM/dd/yyyy`
                        )}
                    </Typography>
                    <Typography variant="body1" component="span">
                        {' '}
                        at{' '}
                    </Typography>
                    <Typography variant="h4" component="span">
                        {formatDateFns(
                            cartTimeToDate(startTime),
                            store?.location.tz,
                            "h:mmaaaaa'm' "
                        )}
                    </Typography>
                </>
            }
        />
    )
}
</file>

<file path="components/atoms/layout/LayoutContext.ts">
import { createContext } from 'react'

export interface Context {
    showBottom: boolean
    isShowLoader: boolean
    isBlurScreen: boolean
    setShowBottom: (showBottom: boolean) => void
    setIsShowLoader: (isShowLoader: boolean) => void
    setIsBlurScreen: (isBlurScreen: boolean) => void
    setOnRightPanelBtnClick: (onRightPanelBtnClick: () => void) => void
    setHideLeftPanel: (hideLeftPanel: boolean) => void
    setHideRightPanel: (hideRightPanel: boolean) => void
    setShowLeftBottom: (showLeftBottom: boolean) => void
}

const defaultValue: Context = {
    showBottom: false,
    isShowLoader: false,
    isBlurScreen: false,
    setShowBottom: () => {},
    setIsShowLoader: () => {},
    setIsBlurScreen: () => {},
    setOnRightPanelBtnClick: () => {},
    setHideLeftPanel: () => {},
    setHideRightPanel: () => {},
    setShowLeftBottom: () => {},
}
export const LayoutContext = createContext<Context>(defaultValue)
</file>

<file path="components/atoms/layout/LayoutListItem.tsx">
import { Box, Theme } from '@mui/material'
import { makeStyles } from '@mui/styles'
import { useMobile } from 'lib/utils/useMobile'
import { SxProps } from '@mui/system'
import { MouseEventHandler } from 'react'
import { ArrowRight } from 'components/icons/ArrowRight'
import { colors } from 'constants/colors'

interface StylesProps {
    isMobile: boolean
    selected: boolean | undefined
    useDefaultCursor?: boolean
    hideBorderBottom?: boolean
    useBottomShadow?: boolean
}

interface Props {
    children: any
    sx?: SxProps<Theme>
    onClick?: MouseEventHandler | undefined
    id?: string | undefined
    selected?: boolean | undefined
    useDefaultCursor?: boolean
    hideBorderBottom?: boolean
    useBottomShadow?: boolean
    addRightArrow?: boolean
}

const leftShadow = '4px 0 0 0'
const bottomShadow = '0 -3px 0 0'

const useStyles = makeStyles((theme: Theme) => ({
    block: {
        padding: (props: StylesProps) => (!props.isMobile ? theme.spacing(3, 2) : theme.spacing(3)),
        cursor: (props: StylesProps) =>
            props.useDefaultCursor ? 'default' : 'pointer',

        boxShadow: (props: StylesProps) =>
            props.selected
                ? `inset ${props.useBottomShadow ? bottomShadow : leftShadow} ${
                      theme.palette.primary.main
                  }`
                : 'none',
        borderBottom: (props: StylesProps) =>
            props.hideBorderBottom
                ? ''
                : `1px solid ${theme.palette.custom.lightGray}`,
        '&:last-child': {
            marginBottom: theme.spacing(4),
        },
    },
    row: {
        display: 'flex',
        flexDirection: 'row',
    },
    right: {
        marginLeft: 'auto',
    },
}))

export const LayoutListItem = ({
    id,
    children,
    sx,
    onClick,
    selected,
    useDefaultCursor,
    hideBorderBottom,
    useBottomShadow,
    addRightArrow,
}: Props) => {
    const { isMobile } = useMobile()
    const classes = useStyles({
        isMobile,
        selected,
        useDefaultCursor,
        hideBorderBottom,
        useBottomShadow,
    })
    const arrowColor = selected ? colors.primary.main : 'black'
    return (
        <Box id={id} className={classes.block} sx={sx} onClick={onClick}>
            {addRightArrow && (
                <Box className={classes.row}>
                    {children}
                    <Box className={classes.right}>
                        <ArrowRight color={arrowColor} />
                    </Box>
                </Box>
            )}
            {!addRightArrow && <>{children}</>}
        </Box>
    )
}
</file>

<file path="components/atoms/layout/useWithLayoutStyles.ts">
import { makeStyles } from '@mui/styles'
import { Theme } from '@mui/material'
import { stepScreen } from 'constants/styles'
import Font from 'config/fonts.json'

interface StylesProps {
    isMobile: boolean
}

export const useWithLayoutStyles = makeStyles((theme: Theme) => ({
    root: {
        height: (props: StylesProps) => (!props.isMobile ? '100%' : 'auto'),
        marginTop: (props: StylesProps) => (!props.isMobile ? '0' : '46px'),
        overflowY: 'scroll',
        '&::-webkit-scrollbar': {
            display: 'none',
        },
    },
    grid: {
        height: (props: StylesProps) => (!props.isMobile ? '100%' : 'auto'),
        display: (props: StylesProps) => (!props.isMobile ? 'flex' : 'block'),
    },
    left: {
        height: (props: StylesProps) => (!props.isMobile ? '100%' : 'auto'),
        flex: '0 0 500px',
        display: 'flex',
        flexDirection: 'column',
    },
    right: {
        flex: '1 0 400px',
        borderLeft: (props: StylesProps) =>
            !props.isMobile ? '1px solid #D9DDE6' : 'none',
        display: 'flex',
        flexDirection: 'column',
        height: '100%',
    },
    rightPanelCaption: {
        display: 'flex',
        flexDirection: 'row',
        justifyContent: 'flex-start',
        alignItems: 'center',
        height: '58px',
        minHeight: '58px',
        borderBottom: '2px solid rgb(217, 221, 229)',
        paddingLeft: (props: StylesProps) =>
            !props.isMobile ? theme.spacing(4) : theme.spacing(2),
    },
    rightPanelCaptionIcon: {
        paddingRight: theme.spacing(2),
    },
    rightPanelCaptionText: {
        fontFamily: Font.headings_family,
        fontWeight: 500,
        fontSize: '20px',
        color: '#000000E5',
        lineHeight: '24px',
    },
    rightPanelBottom: {
        zIndex: 1000,
        height: '56px',
        width: '100%',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'flex-end',
        position: (props: StylesProps) =>
            !props.isMobile ? 'relative' : 'fixed',
        bottom: 0,
    },
    rightPanelBottomBtn: {
        width: '100%',
        height: '56px',
        borderRadius: 0,
        fontSize: '16px',
        fontWeight: 500,
        textTransform: 'none',
    },
    leftPanelBottom: {
        height: '62px',
        display: 'flex',
    },
    leftPanelBottomBtn: {
        fontSize: '16px',
        fontWeight: 500,
        marginLeft: 'auto',
        marginRight: 'auto',
        marginTop: 'auto',
        marginBottom: 'auto',
    },
    loader: stepScreen(theme).loader,
    blurScreen: stepScreen(theme).blurScreen,
}))
</file>

<file path="components/atoms/layout/WithLayout.tsx">
import { Box, Button, Grid } from '@mui/material'
import React, { useState } from 'react'
import { useMobile } from 'lib/utils/useMobile'
import { useWithLayoutStyles } from 'components/atoms/layout/useWithLayoutStyles'
import BounceLoader from 'react-spinners/BounceLoader'
import clsx from 'clsx'
import { LeftSummary } from 'components/atoms/layout/summary/LeftSummary'
import { Context, LayoutContext } from 'components/atoms/layout/LayoutContext'
import ServerError from 'components/molecules/ServerError'
import { ErrorType } from 'lib/state/error/enums'
import { useErrorMessageType } from 'lib/state/error'
import { Step } from 'lib/state/booking-flow/types'
import { useFlowStep } from 'lib/state/booking-flow'
import { ArrowLeft } from 'components/icons/ArrowLeft'

interface Props {
    isShowLoader?: boolean
    leftPanel?: React.ReactNode
    rightPanel?: React.ReactNode
    showBottom?: boolean
    isBlurScreen?: boolean
    rightPanelCaption?: string
    rightPanelBtnCaption?: string
    onRightPanelBtnClick?: () => void
    showLeftBottom?: boolean
    leftPanelBtnCaption?: string
    onLeftPanelBtnClick?: () => void
    isHideLeftPanel?: boolean
    isHideRightPanel?: boolean
    workshopPanel?: React.ReactNode
    addBackArrow?: boolean
    backArrowStep?: Step
}

export default function WithLayout({
    isShowLoader,
    leftPanel,
    rightPanel,
    showBottom,
    isBlurScreen,
    rightPanelCaption,
    rightPanelBtnCaption,
    onRightPanelBtnClick,
    showLeftBottom,
    leftPanelBtnCaption,
    onLeftPanelBtnClick,
    isHideLeftPanel,
    isHideRightPanel,
    workshopPanel,
    addBackArrow,
    backArrowStep,
}: Props) {
    const { isMobile } = useMobile()
    const classes = useWithLayoutStyles({ isMobile })
    const { setStep } = useFlowStep()
    const [displayBottom, setDisplayBottom] = useState(showBottom ?? false)
    const [displayLeftBottom, setDisplayLeftBottom] = useState(
        showLeftBottom ?? false
    )
    const [showLoader, setShowLoader] = useState(isShowLoader ?? false)
    const [blurScreen, setBlurScreen] = useState(isBlurScreen ?? false)
    const [hideLeftPanel, setHideLeftPanel] = useState(isHideLeftPanel ?? false)
    const [hideRightPanel, setHideRightPanel] = useState(
        isHideRightPanel ?? false
    )
    const [rightPanelBtnClick, setRightPanelBtnClick] = useState({
        onRightPanelBtnClick,
    })
    const [errorMessageType] = useErrorMessageType()
    const providerValue: Context = {
        isShowLoader: showLoader,
        showBottom: displayBottom,
        isBlurScreen: blurScreen,
        setShowBottom: (showBottom: boolean) => {
            setDisplayBottom(showBottom)
        },
        setIsShowLoader: (isShowLoader: boolean) => {
            setShowLoader(isShowLoader)
        },
        setIsBlurScreen: (isBlurScreen: boolean) => {
            setBlurScreen(isBlurScreen)
        },
        setOnRightPanelBtnClick: (onRightPanelBtnClick: () => void) => {
            setRightPanelBtnClick({ onRightPanelBtnClick })
        },
        setHideLeftPanel: (hideLeftPanel: boolean) => {
            setHideLeftPanel(hideLeftPanel)
        },
        setHideRightPanel: (hideRightPanel: boolean) => {
            setHideRightPanel(hideRightPanel)
        },
        setShowLeftBottom: (showLeftBottom: boolean) => {
            setDisplayLeftBottom(showLeftBottom)
        },
    }

    const onStepClick = async () => {
        if (backArrowStep) {
            await setStep(backArrowStep)
        }
    }

    return (
        <LayoutContext.Provider value={providerValue}>
            <Box className={classes.root}>
                <Grid
                    container
                    className={clsx(
                        classes.grid,
                        (errorMessageType !== ErrorType.NoError ||
                            showLoader ||
                            blurScreen) &&
                            classes.blurScreen
                    )}
                >
                    {!hideLeftPanel && (
                        <Grid item className={classes.left}>
                            {!isMobile && <LeftSummary />}
                            {leftPanel}
                            {displayLeftBottom && (
                                <Box className={classes.leftPanelBottom}>
                                    <Button
                                        variant="text"
                                        color="secondary"
                                        className={classes.leftPanelBottomBtn}
                                        onClick={onLeftPanelBtnClick}
                                        sx={{
                                            width: '403px',
                                        }}
                                    >
                                        {leftPanelBtnCaption}
                                    </Button>
                                </Box>
                            )}
                        </Grid>
                    )}
                    {!hideRightPanel && (
                        <Grid item className={classes.right}>
                            {rightPanelCaption && (
                                <Box className={classes.rightPanelCaption}>
                                    {addBackArrow && (
                                        <Box
                                            className={
                                                classes.rightPanelCaptionIcon
                                            }
                                            onClick={onStepClick}
                                        >
                                            <ArrowLeft color="#000000E5" />
                                        </Box>
                                    )}
                                    <Box
                                        className={
                                            classes.rightPanelCaptionText
                                        }
                                    >
                                        {rightPanelCaption}
                                    </Box>
                                </Box>
                            )}
                            {rightPanel}
                            {displayBottom && (
                                <Box className={classes.rightPanelBottom}>
                                    <Button
                                        variant="contained"
                                        color="primary"
                                        className={classes.rightPanelBottomBtn}
                                        onClick={
                                            rightPanelBtnClick.onRightPanelBtnClick
                                        }
                                    >
                                        {rightPanelBtnCaption}
                                    </Button>
                                </Box>
                            )}
                        </Grid>
                    )}
                </Grid>
                {showLoader && (
                    <Box position="fixed" className={classes.loader}>
                        <BounceLoader color="#dadada" size={60} />
                    </Box>
                )}
                {errorMessageType !== ErrorType.NoError && <ServerError />}
            </Box>
            {workshopPanel}
        </LayoutContext.Provider>
    )
}
</file>

<file path="components/atoms/AppHead.tsx">
import Head from 'next/head'
import Brand from 'config/brand.json'
import { MapType, useAppConfig } from 'lib/state/config'
import { useGoogleAnalytics } from 'lib/analytics-api/googleAnalyticsUtils'
import { useRouter } from 'next/router'
import { useConfig } from 'lib/sdk/hooks/useConfig'
import { useEffect } from 'react'

export const AppHead = () => {
    const googleAnalytics = useGoogleAnalytics()
    const googleAnalyticsKey = googleAnalytics.googleAnalyticsKey
    const router = useRouter()
    const { googleMapsApiAccessToken, mapboxApiAccessToken } = useConfig()
    const { getMapType } = useAppConfig()
    const mapType = getMapType()
    const googlePlacesApiUrl = `https://maps.googleapis.com/maps/api/js?key=${googleMapsApiAccessToken}&libraries=places`
    const isMapBox = !!mapboxApiAccessToken && mapType === MapType.MapBox

    useEffect(() => {
        const jssStyles = document.querySelector('#jss-server-side')
        jssStyles?.parentElement?.removeChild(jssStyles)
    }, [])

    // Google Analytics: log page views
    useEffect(() => {
        const handleRouteChange = (url: URL) => {
            googleAnalytics.pageView(url)
        }
        router.events.on('routeChangeComplete', handleRouteChange)
        router.events.on('hashChangeComplete', handleRouteChange)
        return () => {
            router.events.off('routeChangeComplete', handleRouteChange)
            router.events.off('hashChangeComplete', handleRouteChange)
        }
    }, [googleAnalytics, router.events])

    return (
        <Head>
            <title>Salon - Booking</title>
            {/* SEO */}
            <meta itemProp="name" content={Brand.name} />
            <meta itemProp="description" content={Brand.description} />

            {/* Icons */}
            <link rel="icon" type="image/x-icon" href={Brand.icon} />
            <link
                rel="shortcut icon"
                type="image/x-icon"
                href={Brand.icon}
            />
            <link
                rel="shortcut icon"
                type="image/x-icon"
                href={Brand.icon}
            />
            <link
                rel="apple-touch-icon"
                sizes="180x180"
                href={Brand.icon}
            />

            {/* Fonts */}
            <link
                rel="prefetch"
                href={'/assets/Roboto-Bold.ttf'}
                as="font"
                crossOrigin=""
            />
            <link
                rel="prefetch"
                href={'/assets/Roboto-Medium.ttf'}
                as="font"
                crossOrigin=""
            />
            <link
                rel="prefetch"
                href={'/assets/Roboto-Regular.ttf'}
                as="font"
                crossOrigin=""
            />

            {/* Other Meta */}
            <meta
                name="viewport"
                content="minimum-scale=1, initial-scale=1, width=device-width"
            />

            {mapType === MapType.Google && googleMapsApiAccessToken && (
                <script async src={googlePlacesApiUrl} />
            )}

            {/* Global Site Tag (gtag.js) - Google Analytics */}
            {googleAnalyticsKey && (
                <script
                    async
                    src={`https://www.googletagmanager.com/gtag/js?id=${googleAnalyticsKey}`}
                />
            )}
            {googleAnalyticsKey && (
                <script
                    dangerouslySetInnerHTML={{
                        __html: `
                            window.dataLayer = window.dataLayer || [];
                            function gtag(){dataLayer.push(arguments);}
                            gtag('js', new Date());
                            gtag('config', '${googleAnalyticsKey}', {
                              page_path: window.location.pathname,
                            });
                        `,
                    }}
                />
            )}
            {isMapBox && <link
                href={
                    'https://api.mapbox.com/mapbox-gl-js/v2.6.0/mapbox-gl.css'
                }
                rel="stylesheet"
            />}
            {isMapBox && <script
                async
                src={
                    'https://api.mapbox.com/mapbox-gl-js/v2.6.0/mapbox-gl.js'
                }
            />}
        </Head>
    )
}
</file>

<file path="components/blocks/BlockContainer.tsx">
import { BlockRenderer } from './BlockRenderer'
import { useFlowStep } from 'lib/state/booking-flow'

export const BlockContainer = () => {
    const { currentFlowStep } = useFlowStep()
    return (
        <BlockRenderer key={currentFlowStep.step} flowStep={currentFlowStep} />
    )
}
</file>

<file path="components/blocks/BlockRenderer.tsx">
import type { ComponentType } from 'react'
import { Types, Step } from 'lib/state/booking-flow/types'
import LoadingStep from 'components/blocks/LoadingStepBlock'
import ChooseLocation from 'components/blocks/ChooseLocationBlock'
import ChooseDate from 'components/blocks/ChooseDateBlock'
import PersonalInfo from 'components/blocks/PersonalInfoBlock'
import BookingSuccess from 'components/blocks/BookingSuccessBlock'
import PayAndConfirm from 'components/blocks/PayAndConfirmBlock'
import SelectServiceBlock from 'components/blocks/SelectServiceBlock'
import SelectedServicesBlock from 'components/blocks/SelectedServicesBlock'
import SelectOptionsBlock from 'components/blocks/SelectOptionsBlock'

export interface BaseBlockProps {}

const Blocks: Record<Step, ComponentType<BaseBlockProps>> = {
    [Step.LoadingStep]: LoadingStep,
    [Step.ChooseLocation]: ChooseLocation,
    [Step.SelectService]: SelectServiceBlock,
    [Step.SelectOptions]: SelectOptionsBlock,
    [Step.SelectedServices]: SelectedServicesBlock,
    [Step.ChooseDate]: ChooseDate,
    [Step.PersonalInfo]: PersonalInfo,
    [Step.PayAndConfirm]: PayAndConfirm,
    [Step.BookingSuccess]: BookingSuccess,
}

export const BlockRenderer = ({ flowStep }: { flowStep: Types }) => {
    const Component = Blocks[flowStep.step]
    if (!Component) throw new Error('Invalid block type: ' + flowStep.step)
    return <Component />
}
</file>

<file path="components/blocks/BookingSuccessBlock.tsx">
import BookingSuccess from 'components/molecules/Services/BookingSuccess'
import React from 'react'

export default function BookingSuccessBlock() {
    return <BookingSuccess />
}
</file>

<file path="components/blocks/ChooseDateBlock.tsx">
import ChooseDateScreen from 'components/molecules/Services/ChooseDate/ChooseDateScreen'
import React from 'react'

export default function ChooseDateBlock() {
    return <ChooseDateScreen />
}
</file>

<file path="components/blocks/ChooseLocationBlock.tsx">
import React from 'react'
import ChooseLocationScreen from 'components/molecules/Services/ChooseLocation/ChooseLocationScreen'

export default function ChooseLocationBlock() {
    return <ChooseLocationScreen />
}
</file>

<file path="components/blocks/LoadingStepBlock.tsx">
import React from 'react'
import { Box } from '@mui/material'
import BounceLoader from 'react-spinners/BounceLoader'

export default function LoadingStepBlock() {
    return (
        <Box
            sx={{
                position: 'absolute',
                left: 'calc(50% - 30px)',
                top: 'calc(50% - 30px)',
            }}
        >
            <BounceLoader color="#dadada" size={60} />
        </Box>
    )
}
</file>

<file path="components/blocks/PayAndConfirmBlock.tsx">
import PayAndConfirmScreen from 'components/molecules/Services/PayAndConfirm/PayAndConfirmScreen'
import React from 'react'

export default function PayAndConfirmBlock() {
    return <PayAndConfirmScreen />
}
</file>

<file path="components/blocks/PersonalInfoBlock.tsx">
import PersonalInfoScreen from 'components/molecules/Services/PersonalInfo/PersonalInfoScreen'
import React from 'react'

export default function PersonalInfoBlock() {
    return <PersonalInfoScreen />
}
</file>

<file path="components/blocks/SelectedServicesBlock.tsx">
import { SelectedServicesScreen } from 'components/molecules/Services/SelectedServices/SelectedServicesScreen'

export default function SelectedServicesBlock() {
    return <SelectedServicesScreen />
}
</file>

<file path="components/blocks/SelectOptionsBlock.tsx">
import React from 'react'
import { SelectOptionsScreen } from 'components/molecules/Services/SelectOptions/SelectOptionsScreen'

export default function SelectOptionsBlock() {
    return <SelectOptionsScreen />
}
</file>

<file path="components/blocks/SelectServiceBlock.tsx">
import { SelectServiceScreen } from 'components/molecules/Services/SelectService/SelectServiceScreen'
import React from 'react'

export default function SelectServiceBlock() {
    return <SelectServiceScreen />
}
</file>

<file path="components/Container/index.tsx">
import { Box } from '@mui/material'
import { makeStyles } from '@mui/styles'

import { useIsSummaryBlockOpenState } from 'lib/state/summary'
import { memo } from 'react'
import { useFlowStep } from 'lib/state/booking-flow'
import { Step } from 'lib/state/booking-flow/types'
import { useMobile } from 'lib/utils/useMobile'

const useStyles = makeStyles(() => ({
    blur: {
        '-webkit-filter': 'blur(12px)',
        '-moz-filter': 'blur(12px)',
        ' -o-filter': 'blur(12px)',
        '-ms-filter': 'blur(12px)',
        filter: 'blur(12px)',
        opacity: '0.5',
        pointerEvents: 'none',
        position: 'fixed',
        width: '100%',
    },
}))

export const Container = ({ children }) => {
    const classes = useStyles()
    const { currentFlowStep } = useFlowStep()

    // eslint-disable-next-line react/display-name
    const Children = memo(() => {
        return <>{children}</>
    })

    const Layout = () => {
        const { isMobile } = useMobile()
        const isDesktopMode =
            !isMobile || currentFlowStep.step === Step.LoadingStep
        const [isSummaryBlockOpen, setIsSummaryBlockOpen] =
            useIsSummaryBlockOpenState()
        const onClick = () => {
            if (!isDesktopMode && isSummaryBlockOpen) {
                setIsSummaryBlockOpen(false)
            }
        }
        return (
            <Box
                onClick={onClick}
                sx={{
                    height: isDesktopMode ? '100%' : 'auto',
                    paddingTop: isDesktopMode ? '70px' : '0',
                }}
            >
                <Box
                    className={
                        !isDesktopMode && isSummaryBlockOpen ? classes.blur : ''
                    }
                    sx={{
                        height: isDesktopMode ? '100%' : 'auto',
                        width: '100%',
                    }}
                >
                    <Children />
                </Box>
            </Box>
        )
    }

    return (
        <>
            <Layout />
        </>
    )
}
</file>

<file path="components/icons/ArrowLeft.tsx">
import { ColorProps } from 'components/icons/color-props'

export const ArrowLeft = ({ color }: ColorProps) => {
    return (
        <svg
            width="8"
            height="12"
            viewBox="0 0 8 12"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
        >
            <path
                d="M7.41016 1.41L2.83016 6L7.41016 10.59L6.00016 12L0.000156403 6L6.00016 0L7.41016 1.41Z"
                fill={color}
                fillOpacity="0.54"
            />
        </svg>
    )
}
</file>

<file path="components/icons/ArrowRight.tsx">
import { ColorProps } from 'components/icons/color-props'

export const ArrowRight = ({ color }: ColorProps) => {
    return (
        <svg
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
        >
            <path
                d="M8.58997 16.59L13.17 12L8.58997 7.41L9.99997 6L16 12L9.99997 18L8.58997 16.59Z"
                fill={color}
                fillOpacity="0.54"
            />
        </svg>
    )
}
</file>

<file path="components/icons/Calendar.tsx">
export const Calendar = (props?: any) => {
    return (
        <svg
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
            {...props}
        >
            <path
                d="M19 4H5C3.89543 4 3 4.89543 3 6V20C3 21.1046 3.89543 22 5 22H19C20.1046 22 21 21.1046 21 20V6C21 4.89543 20.1046 4 19 4Z"
                stroke="#33343C"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
            <path
                d="M16 2V6"
                stroke="#33343C"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
            <path
                d="M8 2V6"
                stroke="#33343C"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
            <path
                d="M3 10H21"
                stroke="#33343C"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
        </svg>
    )
}
</file>

<file path="components/icons/CalendarDark.tsx">
export const CalendarDark = () => {
    return (
        <svg width="10" height="12" viewBox="0 0 10 12" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9 1.5H8.5V0.5H7.5V1.5H2.5V0.5H1.5V1.5H1C0.45 1.5 0 1.95 0 2.5V10.5C0 11.05 0.45 11.5 1 11.5H9C9.55 11.5 10 11.05 10 10.5V2.5C10 1.95 9.55 1.5 9 1.5ZM9 10.5H1V4H9V10.5Z" fill="black" fillOpacity="0.54"/>
        </svg>
    )
}
</file>

<file path="components/icons/Cart.tsx">
export const Cart = () => {
    return (
        <svg width="22" height="19" viewBox="0 0 22 19" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M16.21 6.99953L11.83 0.439531C11.64 0.159531 11.32 0.0195312 11 0.0195312C10.68 0.0195312 10.36 0.159531 10.17 0.449531L5.79 6.99953H1C0.45 6.99953 0 7.44953 0 7.99953C0 8.08953 0.00999996 8.17953 0.04 8.26953L2.58 17.5395C2.81 18.3795 3.58 18.9995 4.5 18.9995H17.5C18.42 18.9995 19.19 18.3795 19.43 17.5395L21.97 8.26953L22 7.99953C22 7.44953 21.55 6.99953 21 6.99953H16.21ZM8 6.99953L11 2.59953L14 6.99953H8ZM11 14.9995C9.9 14.9995 9 14.0995 9 12.9995C9 11.8995 9.9 10.9995 11 10.9995C12.1 10.9995 13 11.8995 13 12.9995C13 14.0995 12.1 14.9995 11 14.9995Z" fill="black"/>
        </svg>
    )
}
</file>

<file path="components/icons/CheckboxIcon.tsx">
export const CheckboxIcon = () => {
    return (
        <svg
            width="18"
            height="18"
            viewBox="0 0 18 18"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
        >
            <rect
                x="0.5"
                y="0.5"
                width="17"
                height="17"
                rx="1.5"
                fill="white"
            />
            <rect
                x="0.5"
                y="0.5"
                width="17"
                height="17"
                rx="1.5"
                stroke="#D9DDE6"
            />
        </svg>
    )
}
</file>

<file path="components/icons/Checked.tsx">
import { ColorProps } from 'components/icons/color-props'

export const Checked = ({ color }: ColorProps) => {
    return (
        <svg
            width="20"
            height="20"
            viewBox="0 0 20 20"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
        >
            <path
                d="M10 0C4.48 0 0 4.48 0 10C0 15.52 4.48 20 10 20C15.52 20 20 15.52 20 10C20 4.48 15.52 0 10 0ZM8 15L3 10L4.41 8.59L8 12.17L15.59 4.58L17 6L8 15Z"
                fill={color}
            />
        </svg>
    )
}
</file>

<file path="components/icons/CheckedCheckboxIcon.tsx">
export const CheckedCheckboxIcon = (props?: any) => {
    return (
        <svg
            width="18"
            height="18"
            viewBox="0 0 18 18"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
        >
            <rect
                x="0.5"
                y="0.5"
                width="17"
                height="17"
                rx="1.5"
                fill="white"
            />
            <path
                d="M13 6L7.5 11.5L5 9"
                stroke="#33343C"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
            <rect
                x="0.5"
                y="0.5"
                width="17"
                height="17"
                rx="1.5"
                stroke="#33343C"
            />
        </svg>
    )
}
</file>

<file path="components/icons/ChevronDown.tsx">
export const ChevronDown = () => {
    return (
        <svg
            width="14"
            height="8"
            viewBox="0 0 14 8"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
        >
            <path
                d="M1 1L7 7L13 1"
                stroke="#33343C"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
        </svg>
    )
}
</file>

<file path="components/icons/ChevronUp.tsx">
export const ChevronUp = () => {
    return (
        <svg
            width="14"
            height="8"
            viewBox="0 0 14 8"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
        >
            <path
                d="M13 7L7 1L1 7"
                stroke="#33343C"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
        </svg>
    )
}
</file>

<file path="components/icons/color-props.ts">
export interface ColorProps {
    color: string
}
</file>

<file path="components/icons/Cross.tsx">
export const Cross = () => {
    return (
        <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M14 1.41L12.59 0L7 5.59L1.41 0L0 1.41L5.59 7L0 12.59L1.41 14L7 8.41L12.59 14L14 12.59L8.41 7L14 1.41Z" fill="black" fillOpacity="0.54"/>
        </svg>
    )
}
</file>

<file path="components/icons/DatePickerIcon.tsx">
export const DatePickerIcon = () => {
    return (
        <svg
            width="20"
            height="20"
            viewBox="0 0 20 20"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
        >
            <path
                d="M15.8333 3.33325H4.16667C3.24619 3.33325 2.5 4.07944 2.5 4.99992V16.6666C2.5 17.5871 3.24619 18.3333 4.16667 18.3333H15.8333C16.7538 18.3333 17.5 17.5871 17.5 16.6666V4.99992C17.5 4.07944 16.7538 3.33325 15.8333 3.33325Z"
                stroke="#6E717D"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
            <path
                d="M13.3333 1.66675V5.00008"
                stroke="#6E717D"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
            <path
                d="M6.66675 1.66675V5.00008"
                stroke="#6E717D"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
            <path
                d="M2.5 8.33325H17.5"
                stroke="#6E717D"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
        </svg>
    )
}
</file>

<file path="components/icons/index.ts">
export * from './Calendar'
export * from './MapPin'
export * from './User'
export * from './CheckboxIcon'
export * from './CheckedCheckboxIcon'
export * from './ChevronDown'
export * from './ChevronUp'
</file>

<file path="components/icons/List.tsx">
import { colors } from 'constants/colors'

export const List = () => {
    return (
        <svg
            width="20"
            height="20"
            viewBox="0 0 20 20"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
        >
            <path
                d="M6.66663 5H17.5"
                stroke="white"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
            <path
                d="M6.66663 10H17.5"
                stroke="white"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
            <path
                d="M6.66663 15H17.5"
                stroke="white"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
            <path
                d="M2.5 5H2.50833"
                stroke="white"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
            <path
                d="M2.5 10H2.50833"
                stroke="white"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
            <path
                d="M2.5 15H2.50833"
                stroke="white"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
        </svg>
    )
}
</file>

<file path="components/icons/LocationPin.tsx">
export const LocationPin = () => {
    return (
        <svg width="10" height="12" viewBox="0 0 10 12" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.05722 5C9.05722 8.5 4.74736 11.5 4.74736 11.5C4.74736 11.5 0.4375 8.5 0.4375 5C0.4375 3.80653 0.891573 2.66193 1.69983 1.81802C2.50808 0.974106 3.60431 0.5 4.74736 0.5C5.89041 0.5 6.98663 0.974106 7.79489 1.81802C8.60314 2.66193 9.05722 3.80653 9.05722 5Z" fill="black" fillOpacity="0.54"/>
        </svg>
    )
}
</file>

<file path="components/icons/Map.tsx">
import { colors } from 'constants/colors'

export const Map = () => {
    return (
        <svg
            width="20"
            height="20"
            viewBox="0 0 20 20"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
        >
            <g clipPath="url(#clip0_985_6790)">
                <path
                    d="M0.833374 4.99996V18.3333L6.66671 15L13.3334 18.3333L19.1667 15V1.66663L13.3334 4.99996L6.66671 1.66663L0.833374 4.99996Z"
                    stroke="white"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                />
                <path
                    d="M6.66663 1.66663V15"
                    stroke="white"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                />
                <path
                    d="M13.3334 5V18.3333"
                    stroke="white"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                />
            </g>
            <defs>
                <clipPath id="clip0_985_6790">
                    <rect width="20" height="20" fill="white" />
                </clipPath>
            </defs>
        </svg>
    )
}
</file>

<file path="components/icons/MapPin.tsx">
export const MapPin = () => {
    return (
        <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="1"
            strokeLinecap="round"
            strokeLinejoin="round"
        >
            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z" />
            <circle cx="12" cy="10" r="3" />
        </svg>
    )
}
</file>

<file path="components/icons/MapPinIcon.tsx">
import { colors } from 'constants/colors'
interface Props {
    style?: object
}

export const MapPinIcon = ({ style }: Props) => {
    return (
        <svg
            width="54"
            height="69"
            viewBox="0 0 54 69"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
            style={style}
        >
            <path
                d="M52.5 28.583C52.5 49.2913 27 67.0413 27 67.0413C27 67.0413 1.5 49.2913 1.5 28.583C1.5 21.5216 4.1866 14.7494 8.96878 9.75629C13.751 4.76313 20.237 1.95801 27 1.95801C33.763 1.95801 40.249 4.76313 45.0312 9.75629C49.8134 14.7494 52.5 21.5216 52.5 28.583Z"
                fill={colors.primary.main}
                stroke={colors.primary.main}
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
            <path
                fillRule="evenodd"
                clipRule="evenodd"
                d="M27.2082 10.3608C33.5859 10.4424 39.7697 14.3982 42.5 20.3423C44.9746 25.7297 44.368 32.4193 40.824 37.3297C37.6739 41.6943 32.3849 44.4575 26.9628 44.4399C21.629 44.4227 16.3765 41.7154 13.2112 37.3297C10.5774 33.6806 9.4713 28.9519 10.2389 24.5151C11.1784 19.0851 14.9241 14.2169 19.9825 11.8963C22.2416 10.8599 24.7452 10.337 27.2082 10.3608V10.3608ZM26.9177 16.0402C24.1074 16.0671 21.3262 17.2013 19.2719 19.1326C15.9158 22.2879 14.6922 27.5087 16.6034 31.8871C18.3603 35.9121 22.5792 38.76 27.0176 38.76C32.3932 38.76 37.5296 34.5 38.2719 28.8705C38.7233 25.4473 37.4805 21.8494 35.0325 19.394C32.9649 17.3202 30.1027 16.0784 27.1446 16.0404C27.069 16.0397 26.9933 16.0402 26.9177 16.0402V16.0402ZM27.2801 21.7241C29.6956 21.8434 31.9254 23.6517 32.5213 26.0148C32.9893 27.8707 32.4326 29.9538 31.0978 31.338C29.5375 32.9559 26.9915 33.5272 24.8693 32.6531C22.5355 31.6917 21.0157 29.0448 21.4103 26.5229C21.8138 23.9438 24.1703 21.8357 26.8428 21.7202H27.1923C27.2216 21.7214 27.2508 21.7228 27.2801 21.7241V21.7241Z"
                fill="white"
            />
        </svg>
    )
}
</file>

<file path="components/icons/Search.tsx">
export const Search = () => {
    return (
        <svg
            width="20"
            height="20"
            viewBox="0 0 20 20"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
        >
            <path
                d="M17.5 17.5L13.875 13.875M15.8333 9.16667C15.8333 12.8486 12.8486 15.8333 9.16667 15.8333C5.48477 15.8333 2.5 12.8486 2.5 9.16667C2.5 5.48477 5.48477 2.5 9.16667 2.5C12.8486 2.5 15.8333 5.48477 15.8333 9.16667Z"
                stroke="#33343C"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
            />
        </svg>
    )
}
</file>

<file path="components/icons/SearchClear.tsx">
export const SearchClear = () => {
    return (
        <svg
            stroke="white"
            fill="#C2C6C9"
            strokeWidth="2"
            viewBox="0 0 24 24"
            strokeLinecap="round"
            strokeLinejoin="round"
            height="20px"
            width="20px"
            xmlns="http://www.w3.org/2000/svg"
        >
            <circle cx="12" cy="12" r="12" />
            <line x1="15" y1="9" x2="9" y2="15" />
            <line x1="9" y1="9" x2="15" y2="15" />
        </svg>
    )
}
</file>

<file path="components/icons/TrashCan.tsx">
import { ColorProps } from 'components/icons/color-props'

export const TrashCan = ({ color }: ColorProps) => {
    return (
        <svg
            width="14"
            height="18"
            viewBox="0 0 14 18"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
        >
            <path
                d="M1 16C1 17.1 1.9 18 3 18H11C12.1 18 13 17.1 13 16V4H1V16ZM3 6H11V16H3V6ZM10.5 1L9.5 0H4.5L3.5 1H0V3H14V1H10.5Z"
                fill={color}
            />
        </svg>
    )
}
</file>

<file path="components/icons/User.tsx">
export const User = () => {
    return (
        <svg
            xmlns="http://www.w3.org/2000/svg"
            width="10" height="12" viewBox="0 0 10 12"
            fill="none"
            stroke="currentColor"
            strokeWidth="1"
            strokeLinecap="round"
            strokeLinejoin="round"
        >
            <path d="M10 11v-1a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v1" />
            <circle cx="6" cy="3" r="2" />
        </svg>
    )
}
</file>

<file path="components/molecules/CartInitializer/CartDefinition.tsx">
import { useEffect } from 'react'
import { Blvd, defaultLocationExternalId } from 'lib/sdk/blvd'
import {
    useCartIdState,
    useCartMethods,
    useCartState,
    useSetCartDataLoadedState,
    useSetDefaultBlvdLocationState,
} from 'lib/state/cart'
import { Cart, CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { Location } from '@boulevard/blvd-book-sdk/lib/locations'
import { useFlowStep } from 'lib/state/booking-flow'
import { Step } from 'lib/state/booking-flow/types'
import { getStepFromPath } from 'lib/utils/stepUtils'
import { useRouter } from 'next/router'
import { useSetPersonalInformationState } from 'lib/state/personal-info'
import { useUrlParams } from 'lib/sdk/hooks/useUrlParams'
import { useStaffTimes } from 'lib/state/staffTime'
import { useStores } from 'lib/sdk/hooks/useStores'
import { useFlowFactory } from 'components/molecules/CartInitializer/FlowFactory'

interface CartLocation {
    cart: Cart
    location?: Location
}

interface Info {
    cartLocation?: CartLocation
    locations?: Location[]
    selectedServices?: CartBookableItem[] | undefined
}

export const CartDefinition = () => {
    const router = useRouter()
    const cartState = useCartState()
    const cartIdState = useCartIdState()
    const { setStepForce, setRecoilStep } = useFlowStep()
    const setPersonalInformationState = useSetPersonalInformationState()
    const setCartDataLoadedState = useSetCartDataLoadedState()
    const { getUrlParams } = useUrlParams()
    const setDefaultBlvdLocationState = useSetDefaultBlvdLocationState()
    const { setLocations } = useStores()
    const {
        createCart,
        setCartCommonState,
        getPersonalInformation,
        forceLoadSelectedServices,
        loadSelectedStaff,
        loadBookingAnswers,
    } = useCartMethods()
    const { loadDatesAndTimes } = useStaffTimes()
    const { getMaxAvailableStep, getInitialStep, isCreateEmptyCart } =
        useFlowFactory()

    const setDefaultLocation = async (
        cartLocation: Location | undefined,
        locations: Location[] | undefined
    ): Promise<Location | undefined> => {
        const urlParams = getUrlParams()
        let result: Location | undefined
        if (
            !defaultLocationExternalId &&
            cartLocation &&
            cartLocation.externalId === urlParams.storeId
        ) {
            result = cartLocation
        } else if (
            locations &&
            (defaultLocationExternalId || urlParams.storeId)
        ) {
            const defaultBlvdLocation = locations.find(
                (x) => x.externalId === defaultLocationExternalId
            )
            const storeIdLocation = locations.find(
                (x) => x.externalId === urlParams.storeId
            )
            result = defaultBlvdLocation ?? storeIdLocation
        }
        if (result) {
            setDefaultBlvdLocationState(result)
        }
        return result
    }

    const getAndSetLocations = async () => {
        const locations = await Blvd.locations.list()
        setLocations(locations)
        return locations
    }

    const initFlow = async (): Promise<Info> => {
        const locations = await getAndSetLocations()
        const location = await setDefaultLocation(undefined, locations)
        if (location || isCreateEmptyCart()) {
            const cart = await createCart(location, undefined)
            return {
                cartLocation: {
                    cart: cart,
                    location: location,
                },
                locations: locations,
            }
        }
        return {
            locations: locations,
        }
    }

    const getRouteStep = async (
        cart: Cart,
        location: Location | undefined,
        selectedServices: CartBookableItem[] | undefined
    ): Promise<Step> => {
        const initialStep = getInitialStep(location, selectedServices)
        const routeStep = getStepFromPath(router.asPath, initialStep)
        const maxAvailableStep = getMaxAvailableStep(
            cart,
            location,
            selectedServices
        )
        if (routeStep > maxAvailableStep) {
            return maxAvailableStep
        } else {
            return routeStep
        }
    }

    const loadCartInternal = async (): Promise<Info> => {
        if (!cartIdState) throw new TypeError('cartIdState must be present')

        const urlParams = getUrlParams()
        const cart = await Blvd.carts.get(cartIdState)
        setPersonalInformationState(getPersonalInformation(cart))
        loadBookingAnswers(cart)
        const location = (await cart.getLocation()) ?? undefined
        if (
            (location &&
                urlParams &&
                urlParams.storeId &&
                urlParams.storeId !== location.externalId) ||
            (location === undefined && urlParams.storeId !== undefined)
        ) {
            throw new Error('StoreId mismatch')
        }

        await setDefaultLocation(location, undefined)
        const availableCategories = await setCartCommonState(
            cart,
            location,
            undefined
        )
        const selectedItems = await forceLoadSelectedServices(
            cart,
            availableCategories
        )
        await loadSelectedStaff(selectedItems)

        return {
            cartLocation: {
                cart,
                location,
            },
            selectedServices: selectedItems,
        }
    }

    const loadCart = async (): Promise<Info> => {
        try {
            return await loadCartInternal()
        } catch (ex) {
            return await initFlow()
        }
    }

    const manageFlow = async (): Promise<Step | undefined> => {
        if (cartState !== undefined) {
            return
        }

        let locations: Location[] | undefined
        let cartLocation: CartLocation | undefined
        let info: Info
        if (cartIdState === undefined) {
            info = await initFlow()
        } else {
            info = await loadCart()
        }

        cartLocation = info.cartLocation
        locations = info.locations
        const selectedServices = info.selectedServices

        let step: Step
        if (cartLocation) {
            const { cart, location } = cartLocation
            step = await getRouteStep(cart, location, selectedServices)
            if (step === Step.ChooseDate && location) {
                await loadDatesAndTimes(cart, location, new Date())
            }
        } else {
            step = getInitialStep(undefined, selectedServices)
        }
        if (!locations) {
            await getAndSetLocations()
        }
        return step
    }

    useEffect(() => {
        manageFlow()
            .then(async (step: Step | undefined) => {
                if (step === undefined) {
                    return
                }
                await setStepForce(step)
                setRecoilStep(step)
            })
            .finally(() => setCartDataLoadedState(true))
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [])

    return <></>
}
</file>

<file path="components/molecules/CartInitializer/Flow.ts">
import { Location } from '@boulevard/blvd-book-sdk/lib/locations'
import { Step } from 'lib/state/booking-flow/types'
import { Cart, CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'

export interface Flow {
    getMaxAvailableStep(
        cart: Cart,
        location: Location | undefined,
        selectedServices: CartBookableItem[] | undefined
    ): Step
    getInitialStep(
        location: Location | undefined,
        selectedServices: CartBookableItem[] | undefined
    ): Step
    isCreateEmptyCart(): boolean
}

export const getAvailableStepBase = (
    cart: Cart,
    selectedItems: CartBookableItem[],
    selectedServicesStep: number,
    chooseDateStep: number,
    personalInfoStep: number,
    all: number
): number => {
    let availableStep = selectedServicesStep
    if (
        selectedItems.filter((x) => x.selectedStaffVariant == undefined)
            .length > 0
    ) {
        return availableStep
    }
    availableStep = chooseDateStep
    if (cart.startTime === undefined || cart.startTime === null) {
        return availableStep
    }

    availableStep = personalInfoStep
    for (let question of cart.bookingQuestions) {
        if (question.required && question.answer == undefined) {
            return availableStep
        }
    }
    if (
        cart.clientInformation == null ||
        !cart.clientInformation.email ||
        !cart.clientInformation.phoneNumber ||
        !cart.clientInformation.firstName ||
        !cart.clientInformation.lastName
    ) {
        return availableStep
    }

    return all
}

export const getMaxAvailableStepBase = (
    availableStep: number,
    personalInfoStep: number,
    chooseDateStep: number,
    selectedServicesStep: number,
    payAndConfirmStep: number
) => {
    if ((availableStep & payAndConfirmStep) === payAndConfirmStep) {
        return Step.PayAndConfirm
    }

    if ((availableStep & personalInfoStep) === personalInfoStep) {
        return Step.PersonalInfo
    }

    if ((availableStep & chooseDateStep) === chooseDateStep) {
        return Step.ChooseDate
    }

    if ((availableStep & selectedServicesStep) === selectedServicesStep) {
        return Step.SelectedServices
    }

    return undefined
}
</file>

<file path="components/molecules/CartInitializer/FlowFactory.ts">
import { FlowType, useAppConfig } from 'lib/state/config'
import { useLocationFirst } from 'components/molecules/CartInitializer/LocationFirst'
import { useServiceFirst } from 'components/molecules/CartInitializer/ServiceFirst'
import { Flow } from 'components/molecules/CartInitializer/Flow'
import { Cart, CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { Location } from '@boulevard/blvd-book-sdk/lib/locations'

export const useFlowFactory = () => {
    const { getFlowType } = useAppConfig()
    const flowType = getFlowType()
    const locationFirst = useLocationFirst()
    const serviceFirst = useServiceFirst()

    const getFlow = (): Flow => {
        if (flowType === FlowType.SelectLocationFirst) {
            return locationFirst
        }
        return serviceFirst
    }

    const getMaxAvailableStep = (
        cart: Cart,
        location: Location | undefined,
        selectedServices: CartBookableItem[] | undefined
    ) => {
        return getFlow().getMaxAvailableStep(cart, location, selectedServices)
    }

    const getInitialStep = (
        location: Location | undefined,
        selectedServices: CartBookableItem[] | undefined
    ) => {
        return getFlow().getInitialStep(location, selectedServices)
    }

    const isCreateEmptyCart = () => {
        return getFlow().isCreateEmptyCart()
    }

    return {
        getMaxAvailableStep: getMaxAvailableStep,
        getInitialStep: getInitialStep,
        isCreateEmptyCart: isCreateEmptyCart,
    }
}
</file>

<file path="components/molecules/CartInitializer/LocationFirst.ts">
import { Cart, CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { Location } from '@boulevard/blvd-book-sdk/lib/locations'
import { Step } from 'lib/state/booking-flow/types'
import {
    Flow,
    getAvailableStepBase,
    getMaxAvailableStepBase,
} from 'components/molecules/CartInitializer/Flow'

enum AvailableSteps {
    ChooseLocation = 0,
    SelectService = 1,
    SelectedServices = 2,
    ChooseDate = 1 << 3,
    PersonalInfo = 1 << 4,
    PayAndConfirm = 1 << 5,
    All = ~(~0 << 6),
}

export const useLocationFirst = () => {
    const getAvailableStep = (
        cart: Cart,
        location: Location | undefined,
        selectedItems: CartBookableItem[] | undefined
    ): AvailableSteps => {
        let availableStep = AvailableSteps.ChooseLocation
        if (location === undefined) {
            return availableStep
        }
        availableStep = AvailableSteps.SelectService
        if (!selectedItems || selectedItems.length === 0) {
            return availableStep
        }

        return getAvailableStepBase(
            cart,
            selectedItems,
            AvailableSteps.SelectedServices,
            AvailableSteps.ChooseDate,
            AvailableSteps.PersonalInfo,
            AvailableSteps.All
        )
    }

    const getMaxAvailableStepInternal = (availableStep: AvailableSteps) => {
        const step = getMaxAvailableStepBase(
            availableStep,
            AvailableSteps.PersonalInfo,
            AvailableSteps.ChooseDate,
            AvailableSteps.SelectedServices,
            AvailableSteps.PayAndConfirm
        )

        if (step) {
            return step
        }

        if (
            (availableStep & AvailableSteps.SelectService) ===
            AvailableSteps.SelectService
        ) {
            return Step.SelectService
        }

        return Step.ChooseLocation
    }

    const getMaxAvailableStep = (
        cart: Cart,
        location: Location | undefined,
        selectedServices: CartBookableItem[] | undefined
    ): Step => {
        const availableStep = getAvailableStep(cart, location, selectedServices)
        return getMaxAvailableStepInternal(availableStep)
    }

    const getInitialStep = (
        location: Location | undefined,
        selectedServices: CartBookableItem[] | undefined
    ): Step => {
        return location ? Step.SelectService : Step.ChooseLocation
    }

    const isCreateEmptyCart = () => {
        return false
    }

    return {
        getMaxAvailableStep: getMaxAvailableStep,
        getInitialStep: getInitialStep,
        isCreateEmptyCart: isCreateEmptyCart,
    } as Flow
}
</file>

<file path="components/molecules/CartInitializer/ServiceFirst.ts">
import { Cart, CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { Location } from '@boulevard/blvd-book-sdk/lib/locations'
import { Step } from 'lib/state/booking-flow/types'
import {
    Flow,
    getAvailableStepBase,
    getMaxAvailableStepBase,
} from 'components/molecules/CartInitializer/Flow'

enum AvailableSteps {
    SelectService = 0,
    ChooseLocation = 1,
    SelectedServices = 2,
    ChooseDate = 1 << 3,
    PersonalInfo = 1 << 4,
    PayAndConfirm = 1 << 5,
    All = ~(~0 << 6),
}

export const useServiceFirst = () => {
    const getAvailableStep = (
        cart: Cart,
        location: Location | undefined,
        selectedItems: CartBookableItem[] | undefined
    ): AvailableSteps => {
        let availableStep = AvailableSteps.SelectService
        if (!selectedItems || selectedItems.length === 0) {
            return availableStep
        }

        availableStep = AvailableSteps.ChooseLocation
        if (location === undefined) {
            return availableStep
        }

        return getAvailableStepBase(
            cart,
            selectedItems,
            AvailableSteps.SelectedServices,
            AvailableSteps.ChooseDate,
            AvailableSteps.PersonalInfo,
            AvailableSteps.All
        )
    }

    const getMaxAvailableStepInternal = (availableStep: AvailableSteps) => {
        const step = getMaxAvailableStepBase(
            availableStep,
            AvailableSteps.PersonalInfo,
            AvailableSteps.ChooseDate,
            AvailableSteps.SelectedServices,
            AvailableSteps.PayAndConfirm
        )

        if (step) {
            return step
        }

        if (
            (availableStep & AvailableSteps.ChooseLocation) ===
            AvailableSteps.ChooseLocation
        ) {
            return Step.ChooseLocation
        }

        return Step.SelectService
    }

    const getMaxAvailableStep = (
        cart: Cart,
        location: Location | undefined,
        selectedServices: CartBookableItem[] | undefined
    ): Step => {
        const availableStep = getAvailableStep(cart, location, selectedServices)
        return getMaxAvailableStepInternal(availableStep)
    }

    const getInitialStep = (
        location: Location | undefined,
        selectedServices: CartBookableItem[] | undefined
    ): Step => {
        return selectedServices && selectedServices.length > 0
            ? Step.ChooseLocation
            : Step.SelectService
    }

    const isCreateEmptyCart = () => {
        return true
    }

    return {
        getMaxAvailableStep: getMaxAvailableStep,
        getInitialStep: getInitialStep,
        isCreateEmptyCart: isCreateEmptyCart,
    } as Flow
}
</file>

<file path="components/molecules/CustomFormControlLabel/index.tsx">
import { FormControlLabelProps } from '@mui/material/FormControlLabel'
import { FormControlLabel, useTheme } from '@mui/material'
import { styled } from '@mui/material/styles'

interface CustomFormControlLabelProps extends FormControlLabelProps {
    controlLabelStyles: Record<string, any>
    checkedBorder?: string
    checkedControlLabelStyles?: Record<string, any>
}

interface StyledFormControlLabelProps extends CustomFormControlLabelProps {
    checked: boolean
}

const FormControlLabelBase = (props: StyledFormControlLabelProps) => {
    const {
        checked,
        controlLabelStyles,
        checkedBorder,
        checkedControlLabelStyles,
        ...other
    } = props
    return <FormControlLabel {...other} />
}

const StyledFormControlLabel = styled((props: StyledFormControlLabelProps) => (
    <FormControlLabelBase {...props} />
))(({ controlLabelStyles, checkedControlLabelStyles, checked }) => ({
    '.MuiFormControlLabel-label': {
        ...controlLabelStyles,
        ...(checked && checkedControlLabelStyles),
    },
    '& .Mui-disabled': {
        opacity: 0.1,
    },
}))

export const CustomFormControlLabel = (props: CustomFormControlLabelProps) => {
    const theme = useTheme()

    return (
        <StyledFormControlLabel
            sx={{
                boxShadow: props.checked
                    ? `0px 0px 0px 2px ${theme.palette.primary.main}`
                    : `0px 0px 0px 1px ${theme.palette.custom.lightGray}`,
            }}
            checked={props.checked!}
            {...props}
        />
    )
}
</file>

<file path="components/molecules/DefineLocation/Google/GoogleDefineLocation.tsx">
import { useGoogleActions } from 'components/molecules/DefineLocation/Google/useGoogleActions'
import React from 'react'
import { DefineLocation } from 'components/molecules/DefineLocation/DefineLocation'

export const GoogleDefineLocation = ({ onSelected }) => {
    const {
        clear,
        onChange,
        hideResults,
        onFocus,
        onItemClick,
        results,
        showResults,
        onKeyDown,
        onSearchClick,
        onChangeViewClick,
        getValue,
        textInputRef,
        currIndex,
        getPlaceName,
    } = useGoogleActions(onSelected)
    return (
        <DefineLocation
            clear={clear}
            currIndex={currIndex}
            getPlaceName={getPlaceName}
            getValue={getValue}
            hideResults={hideResults}
            onKeyDown={onKeyDown}
            onFocus={onFocus}
            onChange={onChange}
            onItemClick={onItemClick}
            onSearchClick={onSearchClick}
            onChangeViewClick={onChangeViewClick}
            results={results}
            showResults={showResults}
            textInputRef={textInputRef}
        />
    )
}
</file>

<file path="components/molecules/DefineLocation/Google/useGoogleActions.ts">
import { ChangeEvent } from 'react'
import usePlacesAutocomplete, {
    getGeocode,
    getLatLng,
    HookArgs,
} from 'use-places-autocomplete'
import { defaultZoom } from 'lib/utils/locationUtils'
import { useActions } from 'components/molecules/DefineLocation/useActions'

export const useGoogleActions = (onSelected) => {
    const getPlaceName = (place) => {
        return place.description
    }

    const displaySuggest = (suggestion) => {
        const address = suggestion.description

        getGeocode({ address })
            .then((results) => getLatLng(results[0]))
            .then((latLng) => {
                const { lat, lng } = latLng
                onSelected({
                    longitude: lng,
                    latitude: lat,
                    zoom: defaultZoom,
                })
                setSearchValue(address)
            })
            .catch((error) => {
                console.log('Error: ', error)
            })
    }

    const {
        value,
        suggestions: { status, data },
        setValue,
    } = usePlacesAutocomplete({
        requestOptions: {
            types: ['(regions)'],
            componentRestrictions: { country: ['us', 'ca'] },
        },
    } as HookArgs)
    const hasSuggestions = status === 'OK'

    const getResults = () => {
        return data
    }

    const getHasResults = () => {
        return hasSuggestions
    }

    const {
        onItemClick,
        onFocus,
        hideResults,
        state,
        onSearchClick,
        getValue,
        textInputRef,
        clear,
        currIndex,
        setState,
        onKeyDown,
        onChangeViewClick,
    } = useActions({ displaySuggest, getPlaceName, getResults, getHasResults })

    const onChange = (e: ChangeEvent<HTMLInputElement>) => {
        const queryString = e.target.value
        if (queryString === '') {
            setSearchValue(queryString)
        } else {
            setValue(queryString)
        }
        setState((prevState) => ({
            ...prevState,
            inputValue: queryString,
            cachedVal: queryString,
        }))
    }

    const setSearchValue = (value: string, shouldFetchData?: boolean) => {
        setValue(value, shouldFetchData)
    }

    const onSuggestSelected = (suggestion) => () => {
        displaySuggest(suggestion)
    }

    return {
        value: value,
        textInputRef: textInputRef,
        onKeyDown: onKeyDown,
        onChange: onChange,
        status: status,
        results: data,
        onSuggestSelected: onSuggestSelected,
        currIndex: currIndex,
        state: state,
        hideResults: hideResults,
        onFocus: onFocus,
        getValue: getValue,
        clear: clear,
        onSearchClick: onSearchClick,
        onItemClick: onItemClick,
        showResults: state.showResults,
        getPlaceName: getPlaceName,
        onChangeViewClick: onChangeViewClick,
    }
}
</file>

<file path="components/molecules/DefineLocation/Mapbox/MapboxDefineLocation.tsx">
import React from 'react'
import { useMapboxActions } from 'components/molecules/DefineLocation/Mapbox/useMapboxActions'
import { DefineLocation } from 'components/molecules/DefineLocation/DefineLocation'

export const MapboxDefineLocation = ({ onSelected }) => {
    const {
        clear,
        onChange,
        hideResults,
        onFocus,
        onItemClick,
        results,
        showResults,
        onKeyDown,
        onSearchClick,
        onChangeViewClick,
        getValue,
        textInputRef,
        currIndex,
        getPlaceName,
    } = useMapboxActions(onSelected)

    return (
        <DefineLocation
            clear={clear}
            currIndex={currIndex}
            getPlaceName={getPlaceName}
            getValue={getValue}
            hideResults={hideResults}
            onKeyDown={onKeyDown}
            onFocus={onFocus}
            onChange={onChange}
            onItemClick={onItemClick}
            onSearchClick={onSearchClick}
            onChangeViewClick={onChangeViewClick}
            results={results}
            showResults={showResults}
            textInputRef={textInputRef}
        />
    )
}
</file>

<file path="components/molecules/DefineLocation/Mapbox/useMapboxActions.ts">
import { useState } from 'react'
import MapboxClient from '@mapbox/mapbox-sdk'
import MapboxGeocoding from '@mapbox/mapbox-sdk/services/geocoding'
import { WebMercatorViewport } from 'viewport-mercator-project'
import { useConfig } from 'lib/sdk/hooks/useConfig'
import {
    defaultZoom,
    mapBoxFlyToInterpolator,
    mapBoxTransitionDuration,
} from 'lib/utils/locationUtils'
import { useMapView } from 'lib/state/location'
import { useActions } from 'components/molecules/DefineLocation/useActions'

export const useMapboxActions = (onSelected) => {
    const { getMapViewportState } = useMapView()
    const { mapboxApiAccessToken } = useConfig()
    const [geocodingClient] = useState(
        new MapboxGeocoding(
            new MapboxClient({ accessToken: mapboxApiAccessToken })
        )
    )
    const queryParams = {
        countries: ['us', 'ca'],
        types: ['region', 'postcode', 'district', 'place'],
    }
    const [debounceTimeout, setDebounceTimeout] = useState()
    const timeoutDefault = 300
    const defaultLimit = 5

    const getPlaceName = (place) => {
        return place.place_name
    }

    const displaySuggest = (item) => {
        const viewport = getMapViewportState()
        const webMercatorViewport = new WebMercatorViewport(viewport as any)
        let newViewPort
        const { bbox, center } = item

        if (bbox) {
            newViewPort = webMercatorViewport.fitBounds([
                [bbox[0], bbox[1]],
                [bbox[2], bbox[3]],
            ])
        } else {
            newViewPort = {
                longitude: center[0],
                latitude: center[1],
                zoom: defaultZoom,
            }
        }

        const { longitude, latitude, zoom } = newViewPort
        onSelected(
            {
                ...viewport,
                ...{
                    longitude,
                    latitude,
                    zoom,
                    transitionDuration: mapBoxTransitionDuration,
                    transitionInterpolator: mapBoxFlyToInterpolator,
                },
            },
            item
        )
    }

    const getResults = () => {
        return state.results
    }

    const getHasResults = () => {
        return state.results !== undefined && state.results.length > 0
    }

    const {
        onItemClick,
        onFocus,
        hideResults,
        state,
        onSearchClick,
        getValue,
        textInputRef,
        clear,
        setState,
        onKeyDown,
        onChangeViewClick,
    } = useActions({ displaySuggest, getPlaceName, getResults, getHasResults })

    const onChange = (event) => {
        const queryString = event.target.value
        setState((prevState) => ({
            ...prevState,
            inputValue: queryString,
            cachedVal: queryString,
        }))

        clearTimeout(debounceTimeout)
        const timeout = setTimeout(() => {
            const params = {
                ...queryParams,
                ...{ limit: defaultLimit },
                ...{ query: queryString },
            }
            if (params.limit > 0 && queryString.length > 0) {
                geocodingClient
                    .forwardGeocode(params)
                    .send()
                    .then((res) => {
                        setState((prevState) => ({
                            ...prevState,
                            results: [...res.body.features],
                        }))
                    })
            } else {
                setState((prevState) => ({ ...prevState, results: [] }))
            }
        }, timeoutDefault)
        setDebounceTimeout(timeout as any)
    }

    return {
        onChange: onChange,
        onItemClick: onItemClick,
        onFocus: onFocus,
        hideResults: hideResults,
        state: state,
        onKeyDown: onKeyDown,
        onSearchClick: onSearchClick,
        getValue: getValue,
        textInputRef: textInputRef,
        clear: clear,
        results: state.results,
        showResults: state.showResults,
        currIndex: state.currIndex,
        getPlaceName: getPlaceName,
        onChangeViewClick: onChangeViewClick,
    }
}
</file>

<file path="components/molecules/DefineLocation/DefineLocation.tsx">
import React from 'react'
import clsx from 'clsx'
import { Box, InputBase, Paper } from '@mui/material'
import { useMobile } from 'lib/utils/useMobile'
import { useStyles } from 'components/molecules/DefineLocation/useStyles'
import { colors } from 'constants/colors'
import { useIsShowMap } from 'lib/state/location'
import { SearchClear } from 'components/icons/SearchClear'
import { StyledButton } from 'components/molecules/DefineLocation/theme'
import { Search } from 'components/icons/Search'
import { Map } from 'components/icons/Map'
import { List } from 'components/icons/List'

export const DefineLocation = ({
    clear,
    onChange,
    hideResults,
    onFocus,
    onItemClick,
    results,
    showResults,
    onKeyDown,
    onSearchClick,
    getValue,
    textInputRef,
    currIndex,
    getPlaceName,
    onChangeViewClick,
}) => {
    const { isMobile } = useMobile()
    const classes = useStyles({ isMobile })
    const [isShowMap] = useIsShowMap()
    const placeholder = !isMobile
        ? 'C\u2063ity or Z\u2063ip c\u2063ode'
        : 'Enter a c\u2063ity or z\u2063ip c\u2063ode'
    const isEmpty = getValue() === ''
    return (
        <Box>
            <Paper component="form" className={classes.paper}>
                <Box className={classes.inputWrapper}>
                    <InputBase
                        onChange={onChange}
                        onBlur={hideResults}
                        onKeyDown={onKeyDown}
                        onFocus={onFocus}
                        className={classes.inputSearch}
                        inputRef={textInputRef}
                        placeholder={placeholder}
                        value={getValue()}
                    />
                    <Box
                        sx={{
                            position: 'relative',
                            right: '10px',
                            margin: 'auto',
                        }}
                    >
                        {!isEmpty && <Box
                            sx={{
                                cursor: 'pointer',
                                textDecoration: 'underline',
                                color: colors.text.grey,
                                fontSize: '14px',
                            }}
                            onClick={clear}
                        >
                            {isMobile ? <SearchClear /> : 'Clear'}
                        </Box>}
                    </Box>
                </Box>
                <StyledButton onClick={onSearchClick}>
                    <Search />
                </StyledButton>
                {isMobile && (
                    <StyledButton onClick={onChangeViewClick}>
                        {!isShowMap ? <Map /> : <List />}
                    </StyledButton>
                )}
            </Paper>

            {showResults && !!results.length && (
                <Box className={classes.resultList}>
                    {results.map((item, index) => (
                        <Box
                            key={index}
                            className={clsx(
                                index === currIndex && classes.resultItemHover,
                                classes.resultItem
                            )}
                            onClick={() => onItemClick(item, index)}
                        >
                            {getPlaceName(item)}
                        </Box>
                    ))}
                </Box>
            )}
        </Box>
    )
}
</file>

<file path="components/molecules/DefineLocation/DefineLocationFactory.tsx">
import { MapType, useAppConfig } from 'lib/state/config'
import React from 'react'
import { MapboxDefineLocation } from 'components/molecules/DefineLocation/Mapbox/MapboxDefineLocation'
import { GoogleDefineLocation } from 'components/molecules/DefineLocation/Google/GoogleDefineLocation'
import { useConfig } from 'lib/sdk/hooks/useConfig'

export const DefineLocationFactory = ({ onSelected }) => {
    const { getMapType } = useAppConfig()
    const mapType = getMapType()
    const { mapboxApiAccessToken, googleMapsApiAccessToken } = useConfig()
    return (
        <>
            {mapType === MapType.MapBox && !!mapboxApiAccessToken && (
                <MapboxDefineLocation onSelected={onSelected} />
            )}
            {mapType === MapType.Google && !!googleMapsApiAccessToken && (
                <GoogleDefineLocation onSelected={onSelected} />
            )}
        </>
    )
}
</file>

<file path="components/molecules/DefineLocation/theme.ts">
import { styled } from '@mui/material/styles'
import { Button } from '@mui/material'

export const StyledButton = styled(Button)(({ theme }) => ({
    width: 48,
    height: 40,
    border: 'none',
    backgroundColor: theme.palette.primary.main,
    marginLeft: '12px',
    paddingLeft: 0,
    paddingRight: 0,
    minWidth: 48,
    '&:hover': {
        backgroundColor: theme.palette.primary.dark,
    },
    '& svg path': {
        stroke: theme.palette.primary.contrastText,
    },
}))
</file>

<file path="components/molecules/DefineLocation/useActions.ts">
import { useRef, useState } from 'react'
import { useCurrentPositionName } from 'lib/state/currentPosition'
import { isMobile as isMobileNative } from 'react-device-detect'
import { useIsShowMap } from 'lib/state/location'

export interface stateInterface {
    results: Array<any>
    showResults: boolean
    inputValue: string
    currIndex: number | null
    cachedVal: string
}

export const initialState = {
    results: [],
    showResults: false,
    inputValue: '',
    currIndex: null,
    cachedVal: '',
} as stateInterface

interface Props {
    displaySuggest: (item) => void
    getPlaceName: (place) => string
    getResults: () => any[]
    getHasResults: () => boolean
}

export const useActions = ({
    displaySuggest,
    getPlaceName,
    getResults,
    getHasResults,
}: Props) => {
    const textInputRef = useRef(null)
    const defaultLocationName = useCurrentPositionName()
    const [isShowMap, setIsShowMap] = useIsShowMap()
    const acceptedKeys = ['ArrowUp', 'ArrowDown', 'Escape', 'Enter']
    const [state, setState] = useState(initialState)
    const [touched, setTouched] = useState(false)

    const clear = () => {
        setTouched(true)
        setState((prevState) => ({
            ...prevState,
            inputValue: '',
            cachedVal: '',
        }))
        const input = textInputRef?.current as unknown as HTMLInputElement
        if (input) {
            input.focus()
        }
    }

    const selectItem = (item) => {
        displaySuggest(item)
        setState((prevState) => ({
            ...prevState,
            inputValue: getPlaceName(item),
            cachedVal: getPlaceName(item),
        }))
        hideResults()
    }

    const onItemClick = (item, index) => {
        setState((prevState) => ({
            ...prevState,
            currIndex: index,
        }))
        return selectItem(item)
    }

    const onFocus = (e) => {
        e.preventDefault()
        if (!isMobileNative) {
            return
        }
        const input = e.target
        setTimeout(() => {
            input.setSelectionRange(input.value.length, input.value.length)
        }, 1)
    }

    const hideResults = () => {
        setTimeout(() => {
            const input = textInputRef?.current as unknown as HTMLInputElement
            if (input) {
                input.blur()
            }
            setState((prevState) => ({ ...prevState, showResults: false }))
        }, 300)
    }

    const onSearchClick = () => {
        const index = state.currIndex ?? 0
        const results = getResults()
        if (results === undefined || results.length - 1 < index) {
            return
        }
        selectItem(results[index])
    }

    const getValue = () => {
        return touched ? state.inputValue : defaultLocationName
    }

    const onKeyDown = (e) => {
        const event = e.nativeEvent
        setTouched(true)
        if (event.key === 'Escape') {
            hideResults()
            return
        }

        if (!state.showResults) {
            setState((prevState) => ({ ...prevState, showResults: true }))
        }

        if (!getHasResults() || !acceptedKeys.includes(event.key)) return

        const results = getResults()
        if (event.key === 'Enter') {
            event.preventDefault()
            if (state.currIndex !== null && results[state.currIndex]) {
                selectItem(results[state.currIndex])
            } else if (results.length > 0 && results[0]) {
                selectItem(results[0])
            }
            hideResults()
            return
        }

        let nextIndex: number | null

        if (event.key === 'ArrowUp') {
            event.preventDefault()
            nextIndex = state.currIndex ?? results.length
            nextIndex = nextIndex > 0 ? nextIndex - 1 : null
        } else {
            nextIndex = state.currIndex ?? -1
            nextIndex = nextIndex < results.length - 1 ? nextIndex + 1 : null
        }

        setState((prevState) => ({
            ...prevState,
            currIndex: nextIndex,
            inputValue:
                nextIndex !== null && results[nextIndex]
                    ? getPlaceName(results[nextIndex])
                    : state.cachedVal,
        }))
    }

    const onChangeViewClick = () => {
        window.scrollTo({
            top: 0,
            left: 0,
            behavior: 'smooth',
        })
        setIsShowMap(!isShowMap)
    }

    return {
        onItemClick: onItemClick,
        onFocus: onFocus,
        hideResults: hideResults,
        state: state,
        onSearchClick: onSearchClick,
        getValue: getValue,
        textInputRef: textInputRef,
        clear: clear,
        showResults: state.showResults,
        currIndex: state.currIndex,
        setState: setState,
        setTouched: setTouched,
        selectItem: selectItem,
        onKeyDown: onKeyDown,
        onChangeViewClick: onChangeViewClick,
    }
}
</file>

<file path="components/molecules/DefineLocation/useStyles.ts">
import { makeStyles } from '@mui/styles'
import { colors } from 'constants/colors'

interface StylesProps {
    isMobile: boolean
}

export const useStyles = makeStyles(() => ({
    resultList: {
        backgroundColor: 'white',
        listStyle: 'none',
        margin: 0,
        padding: 0,
        position: 'absolute',
        zIndex: 100,
        border: '1px solid #E3E3E3',
    },
    resultItem: {
        cursor: 'pointer',
        padding: '11px 10px',
        borderBottom: '0.5px solid #E3E3E3',
        '&:hover': {
            backgroundColor: 'antiquewhite',
        },
    },
    resultItemHover: {
        backgroundColor: 'antiquewhite',
    },
    paper: {
        display: 'flex',
        alignItems: 'center',
        width: '100%',
        boxShadow: 'none',
        border: 'none',
    },
    inputWrapper: {
        width: 'calc(100% - 56px)',
        boxShadow: 'none',
        border: `1px solid ${colors.custom.lightGray}`,
        borderRadius: '2px',
        display: 'flex',
        justifyContent: 'space-between',
    },
    inputSearch: (props: StylesProps) => ({
        padding: '2px 4px',
        boxShadow: 'none',
        height: 38,
        marginLeft: 16,
        flex: '1 0 1px',
        marginRight: 16,
    }),
}))
</file>

<file path="components/molecules/Header/AppSettings.tsx">
import { Box, Popover } from '@mui/material'
import { useStyles } from 'components/molecules/Header/useStyles'
import { useState } from 'react'
import { useConfig } from 'lib/sdk/hooks/useConfig'
import { DisplayAppSettingsPopup } from 'lib/state/config'
import { AppSettingsPopper } from 'components/molecules/Header/AppSettingsPopper'

export const AppSettings = () => {
    const { displayAppSettings } = useConfig()
    const classes = useStyles()
    const [anchorEl, setAnchorEl] = useState(null)

    const handleClick = (event) => {
        setAnchorEl(event.currentTarget)
    }

    const handleClose = () => {
        setAnchorEl(null)
    }

    const open = Boolean(anchorEl)
    const id = open ? "simple-popover" : undefined

    if (displayAppSettings === DisplayAppSettingsPopup.No) {
        return <></>
    }

    return (
        <>
            <Box
                className={classes.settings}
                onClick={handleClick}
                aria-describedby={id}
            >
                Settings
            </Box>
            <Popover
                id={id}
                open={open}
                anchorEl={anchorEl}
                onClose={handleClose}
                anchorOrigin={{
                    vertical: "bottom",
                    horizontal: "left"
                }}
                PaperProps={{
                    style: {
                        backgroundColor: "transparent",
                        boxShadow: 'none',
                    }
                }}
            >
                <AppSettingsPopper/>
            </Popover>
        </>
    )
}
</file>

<file path="components/molecules/Header/AppSettingsPopper.tsx">
import { Box, Button } from '@mui/material'
import { useStyles } from 'components/molecules/Header/useStyles'
import Radio from '@mui/material/Radio'
import RadioGroup from '@mui/material/RadioGroup'
import FormControlLabel from '@mui/material/FormControlLabel'
import { ChangeEvent, useState } from 'react'
import {
    DateTimeType,
    FlowType,
    MapType, useAppConfig, useSetDateTimeTypeState,
    useSetFlowTypeState,
    useSetMapTypeState
} from 'lib/state/config'
import { useSetCartIdState } from 'lib/state/cart'
import { Step } from 'lib/state/booking-flow/types'
import { useFlowStep } from 'lib/state/booking-flow'
import FormLabel from '@mui/material/FormLabel'

export const AppSettingsPopper = () => {
    const { setStep } = useFlowStep()
    const setCartIdState = useSetCartIdState()
    const classes = useStyles()

    const {getDateTimeType, getMapType, getFlowType} = useAppConfig()

    const flowTypeState = getFlowType()
    const setFlowTypeState = useSetFlowTypeState()

    const mapTypeState = getMapType()
    const setMapTypeState = useSetMapTypeState()

    const dateTimeState = getDateTimeType()
    const setDateTimeTypeState = useSetDateTimeTypeState()

    const [uiFlowType, setUiFlowType] = useState(FlowType[flowTypeState])
    const [uiMapType, setUiMapType] = useState(MapType[mapTypeState])
    const [uiDateTimeType, setUiDateTimeType] = useState(DateTimeType[dateTimeState])

    const handleUiFlowTypeChange = (event: ChangeEvent<HTMLInputElement>) => {
        setUiFlowType((event.target as HTMLInputElement).value)
    }

    const handleUiMapTypeChange = (event: ChangeEvent<HTMLInputElement>) => {
        setUiMapType((event.target as HTMLInputElement).value)
    }

    const handleUiDateTimeTypeChange = (event: ChangeEvent<HTMLInputElement>) => {
        setUiDateTimeType((event.target as HTMLInputElement).value)
    }

    const onOk = async () => {
        setFlowTypeState(uiFlowType)
        setMapTypeState(uiMapType)
        setDateTimeTypeState(uiDateTimeType)
        setCartIdState(undefined)
        await setStep(Step.LoadingStep)
        location.reload()
    }

    return (
        <Box className={classes.popperContent}>
            <Box
                className={classes.boxWrapperCommon}
                sx={{
                    pb: 3,
                }}
            >
                Cart will be cleared on saving settings.
                <br/>
                <br/>
                Settings changes will be applied only to current browser.
            </Box>
            <Box
                className={classes.boxWrapperCommon}
                sx={{
                    pb: 3,
                }}
            >
                <FormLabel>Flow</FormLabel>
                <RadioGroup
                    value={uiFlowType}
                    onChange={handleUiFlowTypeChange}
                    className={classes.radioGroup}
                >
                    <FormControlLabel value={FlowType[FlowType.SelectLocationFirst]} control={<Radio />} label="Location first" />
                    <FormControlLabel value={FlowType[FlowType.SelectServiceFirst]} control={<Radio />} label="Service First" />
                </RadioGroup>
            </Box>

            <Box
                className={classes.boxWrapperCommon}
                sx={{
                    pb: 3,
                }}
            >
                <FormLabel>Map</FormLabel>
                <RadioGroup
                    value={uiMapType}
                    onChange={handleUiMapTypeChange}
                    className={classes.radioGroup}
                >
                    <FormControlLabel value={MapType[MapType.MapBox]} control={<Radio />} label="MapBox" />
                    <FormControlLabel value={MapType[MapType.Google]} control={<Radio />} label="Google" />
                    <FormControlLabel value={MapType[MapType.None]} control={<Radio />} label="None" />
                </RadioGroup>
            </Box>

            <Box
                className={classes.boxWrapperCommon}
                sx={{
                    pb: 3,
                }}
            >
                <FormLabel>Date & Time Selection</FormLabel>
                <RadioGroup
                    value={uiDateTimeType}
                    onChange={handleUiDateTimeTypeChange}
                    className={classes.radioGroup}
                >
                    <FormControlLabel value={DateTimeType[DateTimeType.ShowTimeForOneDay]} control={<Radio />} label="Single Day at a Time (Calendar UI)" />
                    <FormControlLabel value={DateTimeType[DateTimeType.ShowTimeForManyDays]} control={<Radio />} label="List of Days & Times" />
                </RadioGroup>
            </Box>
            <Button
                variant="contained"
                sx={{
                    width: '100%'
                }}
                onClick={onOk}
            >
                OK
            </Button>
        </Box>
    )
}
</file>

<file path="components/molecules/Header/CartItem.tsx">
import { Box, Popover } from '@mui/material'
import { Cart } from 'components/icons/Cart'
import { useStyles } from 'components/molecules/Header/useStyles'
import { useSelectedServices } from 'lib/state/services'
import { useState } from 'react'
import { PopperContent } from 'components/molecules/Header/PopperContent'
import { useFlowStep } from 'lib/state/booking-flow'
import { Step } from 'lib/state/booking-flow/types'

export const CartItem = () => {
    const { currentFlowStep } = useFlowStep()
    const classes = useStyles()
    const { selectedServicesStateValue } = useSelectedServices()
    const [anchorEl, setAnchorEl] = useState(null)

    const handleClick = (event) => {
        setAnchorEl(event.currentTarget)
    }

    const handleClose = () => {
        setAnchorEl(null)
    }

    const open = Boolean(anchorEl)
    const id = open ? "simple-popover" : undefined

    if (currentFlowStep.step === Step.BookingSuccess) {
        return <></>
    }

    return (
        <>
            <Box
                className={classes.cart}
                onClick={handleClick}
                aria-describedby={id}
            >
                <Cart/>
                <Box className={classes.round}>{selectedServicesStateValue.length}</Box>
            </Box>
            <Popover
                id={id}
                open={open}
                anchorEl={anchorEl}
                onClose={handleClose}
                anchorOrigin={{
                    vertical: "bottom",
                    horizontal: "left"
                }}
                PaperProps={{
                    style: {
                        backgroundColor: "transparent",
                        boxShadow: 'none',
                    }
                }}
            >
                <PopperContent handleClose={handleClose}/>
            </Popover>
        </>
    )
}
</file>

<file path="components/molecules/Header/index.tsx">
import {
    AppBar,
    Grid,
} from '@mui/material'
import { useFlowStep } from 'lib/state/booking-flow'
import { Step } from 'lib/state/booking-flow/types'
import { useMobile } from 'lib/utils/useMobile'
import { useStyles } from 'components/molecules/Header/useStyles'
import { CartItem } from 'components/molecules/Header/CartItem'
import { Logo } from 'components/molecules/Header/Logo'
import { Steps } from 'components/molecules/Header/Steps'
import { Progress } from 'components/molecules/Header/Progress'
import { AppSettings } from 'components/molecules/Header/AppSettings'

export const Header = () => {
    const { isMobile } = useMobile()
    const { currentFlowStep } = useFlowStep()
    const classes = useStyles()

    if (currentFlowStep.step === Step.LoadingStep) {
        return <></>
    }

    return (
        <AppBar position="fixed" elevation={0} sx={{ height: isMobile ? '46px': undefined }}>
            <Grid
                container
                direction="row"
                justifyContent="flex-start"
                alignItems="center"
                className={classes.topBlock}
            >
                <Logo/>
                {!isMobile && <Steps/>}
                <AppSettings/>
                <CartItem/>
            </Grid>
            <Progress/>
        </AppBar>
    )
}
</file>

<file path="components/molecules/Header/Logo.tsx">
import { Box } from '@mui/material'
import { appExternalUrl } from 'lib/utils/locationUtils'
import { useStyles } from 'components/molecules/Header/useStyles'
const projectLogo = '/images/project_logo.png'

export const Logo = () => {
    const classes = useStyles()
    const redirectToInitialPage = () => {
        location.href = appExternalUrl
    }

    return (
        <Box
            className={classes.logo}
            onClick={redirectToInitialPage}
        >
            {/* eslint-disable-next-line @next/next/no-img-element */}
            <img
                src={projectLogo}
                alt="projectLogo"
                width={139}
                height={19}
            />
        </Box>

    )
}
</file>

<file path="components/molecules/Header/PopperContent.tsx">
import { Box } from '@mui/material'
import { PaymentSummaryControl } from 'components/molecules/PaymentSummaryControl'
import { useStyles } from 'components/molecules/Header/useStyles'
import { useFlowStep } from 'lib/state/booking-flow'
import { useSetActiveSelectedService } from 'lib/state/services'
import { Step } from 'lib/state/booking-flow/types'
import { PopperTopRow } from 'components/molecules/Header/PopperTopRow'
import { PopperLocation } from 'components/molecules/Header/PopperLocation'
import { PopperDateTime } from 'components/molecules/Header/PopperDateTime'
import { PopperPersonalInfo } from 'components/molecules/Header/PopperPersonalInfo'

interface Props {
    handleClose: () => void
}

export const PopperContent = ({handleClose}: Props) => {
    const classes = useStyles()
    const { setStep } = useFlowStep()
    const setActiveSelectedService = useSetActiveSelectedService()

    const onServiceNameClick = async (bookableItem) => {
        setActiveSelectedService(bookableItem)
        handleClose()
        await setStep(Step.SelectedServices)
    }

    return (
        <>
            <Box className={classes.popperArrow}/>
            <Box className={classes.popperContent}>
                <PopperTopRow handleClose={handleClose}/>
                <PopperLocation handleClose={handleClose}/>
                <PopperDateTime handleClose={handleClose}/>
                <PopperPersonalInfo handleClose={handleClose}/>
                <Box className={classes.dashLine}/>
                <PaymentSummaryControl isTopSummaryMode={true} onServiceNameClick={onServiceNameClick}/>
            </Box>
        </>
    )
}
</file>

<file path="components/molecules/Header/PopperDateTime.tsx">
import { useCartStoreState } from 'lib/state/store'
import { Step } from 'lib/state/booking-flow/types'
import formatDateFns, { cartTimeToDate } from 'lib/utils/formatDateFns'
import { CalendarDark } from 'components/icons/CalendarDark'
import { useCartState } from 'lib/state/cart'
import { PopperItemBase } from 'components/molecules/Header/PopperItemBase'

interface Props {
    handleClose: () => void
}

export const PopperDateTime = ({handleClose}: Props) => {
    const selectedStore = useCartStoreState()
    const cart = useCartState()

    return (
        <PopperItemBase handleClose={handleClose}
                        step={Step.ChooseDate}
                        text={cart?.startTime ? formatDateFns(
                                             cartTimeToDate(cart?.startTime),
                                             selectedStore?.location.tz,
                                             "EEEE, MMM d @ h:mmaaaaa'm'"
                                         ) : 'Pending'}
                        icon={<CalendarDark/>}
                        editable={!!cart?.startTime}
        />
    )
}
</file>

<file path="components/molecules/Header/PopperItemBase.tsx">
import { useStyles } from 'components/molecules/Header/useStyles'
import { useFlowStep } from 'lib/state/booking-flow'
import { Step } from 'lib/state/booking-flow/types'
import { Box, Typography } from '@mui/material'
import Color from 'config/colors.json'
import React from 'react'

interface Props {
    handleClose: () => void
    step: Step
    icon: React.ReactNode
    text: string
    editable: boolean
}

export const PopperItemBase = ({handleClose, step, icon, text, editable}: Props) => {
    const classes = useStyles()
    const { setStep } = useFlowStep()

    const onEdit = async () => {
        handleClose()
        await setStep(step)
    }
    return (
        <Box
            className={classes.boxWrapperCommon}
            sx={{
                pb: 1,
            }}
        >
            <Box>
                <Typography
                    sx={{ pr: 2 }}
                    variant="body2"
                    component="span"
                >
                    {icon}
                </Typography>
                <Typography component="span">
                    {text}
                </Typography>
            </Box>
            {editable && <Box onClick={onEdit} sx={{cursor: 'pointer'}}>
                <Typography sx={{color: Color.primary.main}}>
                    Edit
                </Typography>
            </Box>}
        </Box>
    )
}
</file>

<file path="components/molecules/Header/PopperLocation.tsx">
import { LocationPin } from 'components/icons/LocationPin'
import { useCartStoreState } from 'lib/state/store'
import { getLocationName } from 'lib/utils/locationUtils'
import { Step } from 'lib/state/booking-flow/types'
import { PopperItemBase } from 'components/molecules/Header/PopperItemBase'

interface Props {
    handleClose: () => void
}

export const PopperLocation = ({handleClose}: Props) => {
    const selectedStore = useCartStoreState()

    return (
        <PopperItemBase handleClose={handleClose}
                        step={Step.ChooseLocation}
                        text={selectedStore ? getLocationName(selectedStore) : 'Pending'}
                        icon={<LocationPin/>}
                        editable={!!selectedStore}
        />
    )
}
</file>

<file path="components/molecules/Header/PopperPersonalInfo.tsx">
import { Step } from 'lib/state/booking-flow/types'
import { usePersonalInformationState } from 'lib/state/personal-info'
import React from 'react'
import { User } from 'components/icons'
import { PopperItemBase } from 'components/molecules/Header/PopperItemBase'

interface Props {
    handleClose: () => void
}

export const PopperPersonalInfo = ({handleClose}: Props) => {
    const [personalInformation] = usePersonalInformationState()
    const isSet = !!personalInformation.firstName && !!personalInformation.lastName

    return (
        <PopperItemBase handleClose={handleClose}
                        step={Step.PersonalInfo}
                        text={isSet ? `${personalInformation.firstName} ${personalInformation.lastName}` : 'Pending'}
                        icon={<User/>}
                        editable={isSet}
        />
    )
}
</file>

<file path="components/molecules/Header/PopperTopRow.tsx">
import { useStyles } from 'components/molecules/Header/useStyles'
import { Box, Typography } from '@mui/material'
import { Cross } from 'components/icons/Cross'

interface Props {
    handleClose: () => void
}

export const PopperTopRow = ({handleClose}: Props) => {
    const classes = useStyles()

    return (
        <Box
            className={classes.boxWrapperCommon}
            sx={{
                pb: 3,
            }}
        >
            <Typography sx={{
                fontWeight: 700
            }}>Cart</Typography>
            <Box onClick={handleClose} sx={{cursor: 'pointer'}}><Cross/></Box>
        </Box>
    )
}
</file>

<file path="components/molecules/Header/Progress.tsx">
import { Box, LinearProgress } from '@mui/material'
import { useHeader } from 'components/molecules/Header/useHeader'

export const Progress = () => {
    const { getCurrentStepPercents } = useHeader()
    return (
        <Box sx={{ width: '100%' }}>
            <LinearProgress
                variant="determinate"
                value={getCurrentStepPercents().currentStepByPercent}
            />
        </Box>
    )
}
</file>

<file path="components/molecules/Header/Steps.tsx">
import { Typography } from '@mui/material'
import { useFlowStep } from 'lib/state/booking-flow'
import { Step } from 'lib/state/booking-flow/types'
import { useHeader } from 'components/molecules/Header/useHeader'

export const Steps = () => {
    const { currentFlowStep } = useFlowStep()
    const { getCurrentStepPercents } = useHeader()
    return (
        <>
            {currentFlowStep.step !== Step.ChooseLocation &&
                currentFlowStep.step !== Step.BookingSuccess &&
                currentFlowStep.step !== Step.LoadingStep && (
                    <Typography
                        variant="body2"
                        sx={{
                            fontWeight: 400,
                            textTransform: 'uppercase',
                        }}
                    >{`step ${
                        getCurrentStepPercents().currentStep
                    } of 5`}</Typography>
                )}
        </>
    )
}
</file>

<file path="components/molecules/Header/useHeader.ts">
import { Step } from 'lib/state/booking-flow/types'
import { useFlowStep } from 'lib/state/booking-flow'

export const useHeader = () => {
    const { currentFlowStep } = useFlowStep()

    const getCurrentStepPercents = () => {
        let currentStep = 0
        let currentStepByPercent = 0
        if (currentFlowStep.step === Step.SelectService || currentFlowStep.step === Step.SelectOptions) {
            currentStep = 1
            currentStepByPercent = 17
        } else if (currentFlowStep.step === Step.SelectedServices) {
            currentStep = 2
            currentStepByPercent = 34
        } else if (currentFlowStep.step === Step.ChooseDate) {
            currentStep = 3
            currentStepByPercent = 50
        } else if (currentFlowStep.step === Step.PersonalInfo) {
            currentStep = 4
            currentStepByPercent = 67
        } else if (currentFlowStep.step === Step.PayAndConfirm) {
            currentStep = 5
            currentStepByPercent = 84
        } else if (currentFlowStep.step === Step.BookingSuccess) {
            currentStep = 6
            currentStepByPercent = 100
        }
        return { currentStepByPercent, currentStep }
    }

    return {
        getCurrentStepPercents: getCurrentStepPercents,
    }
}
</file>

<file path="components/molecules/Header/useStyles.ts">
import { makeStyles } from '@mui/styles'
import { Theme } from '@mui/material'
import { colors } from 'constants/colors'

export const useStyles = makeStyles((theme: Theme) => ({
    topBlock: {
        height: '100%',
        paddingLeft: theme.spacing(2),
    },
    logo: {
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        paddingRight: theme.spacing(2),
        cursor: 'pointer',
    },
    cart: {
        marginRight: '37px',
        cursor: 'pointer',
    },
    settings: {
        marginLeft: 'auto',
        marginRight: '37px',
        cursor: 'pointer',
        color: 'black'
    },
    round: {
        backgroundColor: colors.primary.main,
        backgroundSize: '100%',
        borderRadius: '50%',
        display: 'inline-block',
        height: '12px',
        width: '12px',
        lineHeight: '12px',
        fontSize: '10px',
        fontWeight: 700,
        position: 'relative',
        top: '8px',
        left: '-8px',
        textAlign: 'center',
    },
    popperArrow: {
        position: "relative",
        marginTop: "10px",
        width: '354px',
        "&::before": {
            backgroundColor: "white",
            content: '""',
            display: "block",
            position: "absolute",
            width: 12,
            height: 12,
            top: '-6px',
            transform: "rotate(45deg)",
            left: "calc(50% + 127px)",
            borderTop: '1px solid #C4C4C4',
            borderLeft: '1px solid #C4C4C4',
        }
    },
    popperContent: {
        padding: theme.spacing(2),
        backgroundColor: "white",
        border: '1px solid #C4C4C4',
        borderRadius: '4px',
        width: '354px'
    },
    boxWrapperCommon: {
        display: 'flex',
        flexDirection: 'row',
        justifyContent: 'space-between',
    },
    dashLine: {
        borderTop: '1px dashed #C4C4C4',
        marginTop: '16px',
        paddingBottom: '24px',
        marginLeft: '-24px',
        marginRight: '-24px'
    },
    radioGroup: {
        width: '200px'
    }
}))
</file>

<file path="components/molecules/Map/Google/MapStore.tsx">
import { Store as StoreType } from 'lib/state/store/types'
import { isMobile } from 'react-device-detect'
import { MapStoreInfoWindow } from 'components/molecules/Map/Google/MapStoreInfoWindow'
import { MapPinIcon } from 'components/icons/MapPinIcon'
import React from 'react'
import { Box } from '@mui/material'
import { useLocationSelectedStoreState } from 'lib/state/location'
import { scrollIntoStore } from 'components/molecules/Map/helper'

interface Props {
    store?: StoreType|undefined
    lat: number
    lng: number
}

export const MapStore = ({ store }: Props) => {
    const [locationSelectedStore, setLocationSelectedStore] =
        useLocationSelectedStoreState()

    const onSelectClick = async (event?) => {
        if (!store) {
            return
        }

        event?.preventDefault()
        setLocationSelectedStore(store)
        scrollIntoStore(isMobile, store)
    }

    const size = '25px'

    const closeStorePopup = () => {
        setLocationSelectedStore(undefined)
    }
    return (
        <>
            {store && locationSelectedStore?.location.id === store.location.id && (
                <MapStoreInfoWindow
                    store={store}
                    closePopup={closeStorePopup}
                />
            )}
            <Box
                onClick={onSelectClick}
                sx={{
                    position: 'relative',
                    '& svg': {
                        width: size,
                        height: size,
                    },
                    cursor: 'pointer',
                }}
            >
                <MapPinIcon style={{ transform: 'translate(-50%, -100%)' }} />
            </Box>
        </>
    )
}
</file>

<file path="components/molecules/Map/Google/MapStoreInfoWindow.tsx">
import { Store as StoreType } from 'lib/state/store/types'
import { Box } from '@mui/material'
import React from 'react'
import { PopupCommon } from 'components/molecules/Map/PopupCommon'
import { useMapStoreInfoWindowStyles } from 'components/molecules/Map/Google/styles'

interface Props {
    store: StoreType
    closePopup?: () => void
}

export const MapStoreInfoWindow = ({ store, closePopup }: Props) => {
    const classes = useMapStoreInfoWindowStyles()
    return (
        <Box className={classes.container}>
            <Box className={classes.popup}>
                <PopupCommon closePopup={closePopup} store={store} />
            </Box>
            <Box className={classes.bottomArrow} />
        </Box>
    )
}
</file>

<file path="components/molecules/Map/Google/MapStores.tsx">
import GoogleMapReact from 'google-map-react'
import { MapStore } from 'components/molecules/Map/Google/MapStore'
import { Store } from 'lib/state/store/types'
import { useConfig } from 'lib/sdk/hooks/useConfig'
import { useMapViewportState } from 'lib/state/location'

interface Props {
    stores: Store[]
}

export const MapStores = ({ stores }: Props) => {
    const { googleMapsApiAccessToken } = useConfig()
    const [globalViewport] = useMapViewportState()
    const defaultProps = {
        center: { lat: globalViewport.latitude, lng: globalViewport.longitude },
        zoom: globalViewport.zoom,
    }
    return (
        <>
            <GoogleMapReact
                bootstrapURLKeys={{ key: googleMapsApiAccessToken }}
                center={defaultProps.center}
                defaultZoom={defaultProps.zoom}
                options={{
                    fullscreenControl: false,
                    gestureHandling: 'greedy',
                    clickableIcons: false,
                }}
            >
                {stores?.map((store) => (
                    <MapStore
                        key={'MapStore' + store.location.id}
                        lat={store.lat}
                        lng={store.lng}
                        store={store}
                    />
                ))}
            </GoogleMapReact>
        </>
    )
}
</file>

<file path="components/molecules/Map/Google/SelectedStoreMapGoogle.tsx">
import { useSuccessBookingCartInfoState } from 'lib/state/cart'
import { useCartStoreState } from 'lib/state/store'
import { useConfig } from 'lib/sdk/hooks/useConfig'
import { MapStore } from 'components/molecules/Map/Google/MapStore'
import GoogleMapReact from 'google-map-react'

export const SelectedStoreMapGoogle = () => {
    const { googleMapsApiAccessToken } = useConfig()
    const successBookingCartInfo = useSuccessBookingCartInfoState()
    const cartStore = useCartStoreState()
    const selectedStore = cartStore ?? successBookingCartInfo?.store
    const defaultProps = {
        center: { lat: selectedStore?.lat ?? 0, lng: selectedStore?.lng ?? 0 },
        zoom: 14,
    }

    return (
        <>
            {selectedStore && (
                <GoogleMapReact
                    bootstrapURLKeys={{ key: googleMapsApiAccessToken }}
                    center={defaultProps.center}
                    defaultZoom={defaultProps.zoom}
                    options={{
                        fullscreenControl: false,
                        gestureHandling: 'greedy',
                        clickableIcons: false,
                        zoomControl: false,
                    }}
                >
                    <MapStore
                        key={'MapStore' + selectedStore.location.id}
                        lat={selectedStore.lat}
                        lng={selectedStore.lng}
                    />
                </GoogleMapReact>
            )}
        </>
    )
}
</file>

<file path="components/molecules/Map/Google/styles.ts">
import { makeStyles } from '@mui/styles'

export const useMapStoreInfoWindowStyles = makeStyles(() => ({
    container: {
        position: 'absolute',
        bottom: '30px',
        left: '-130px',
        width: '260px',
        fontSize: '14px',
        zIndex: 100,
        display: 'flex',
        flexDirection: 'column',
    },
    popup: {
        backgroundColor: 'white',
        filter: 'drop-shadow(0px 8px 16px rgba(0, 0, 0, 0.15))',
        boxShadow: '0 1px 2px rgb(0 0 0 / 10%)',
        padding: '16px',
        fontSize: '14px',
        zIndex: 100,
        display: 'flex',
        flexDirection: 'column',
    },
    bottomArrow: {
        borderLeftWidth: '20px!important',
        borderRightWidth: '20px!important',
        borderTopWidth: '20px!important',
        alignSelf: 'center',
        borderBottom: 'none',
        borderTopColor: '#fff!important',
        width: 0,
        height: 0,
        border: '10px solid transparent',
        zIndex: 101,
    },
}))
</file>

<file path="components/molecules/Map/Mapbox/cursors.ts">
export const grab = 'grab'
export const pointer = 'pointer'
</file>

<file path="components/molecules/Map/Mapbox/CustomMarker.tsx">
import React from 'react'
import { Marker } from 'react-map-gl'
import { Box } from '@mui/material'
import { Store } from 'lib/state/store/types'
import { MapPinIcon } from '../../../icons/MapPinIcon'

interface Props {
    marker: Store
    openPopup?: (store: Store) => void
    size?: number | string
}

export const CustomMarker = ({ marker, openPopup, size = 65 }: Props) => {
    const onMarkerClick = () => {
        if (openPopup) {
            openPopup!(marker)
        }
    }
    return (
        <Marker longitude={marker.lng} latitude={marker.lat}>
            <Box
                onClick={onMarkerClick}
                sx={{
                    position: 'relative',
                    top: `-${size}`,
                    left: '-50%',
                    '& svg': {
                        width: size,
                        height: size,
                    },
                    cursor: 'pointer',
                }}
            >
                <MapPinIcon />
            </Box>
        </Marker>
    )
}

export default CustomMarker
</file>

<file path="components/molecules/Map/Mapbox/CustomStorePopup.tsx">
import React from 'react'
import { Popup } from 'react-map-gl'
import { makeStyles } from '@mui/styles'
import { Store } from 'lib/state/store/types'
import { useMobile } from 'lib/utils/useMobile'
import { PopupCommon } from 'components/molecules/Map/PopupCommon'

interface StylesProps {
    isMobile: boolean
}

const useStyles = makeStyles(() => ({
    popup: {
        maxWidth: (props: StylesProps) => (!props.isMobile ? '275px' : '214px'),
        '& .mapboxgl-popup-content': {
            filter: 'drop-shadow(0px 8px 16px rgba(0, 0, 0, 0.15))',
            padding: (props: StylesProps) =>
                !props.isMobile ? '16px' : '14px 33px 14px 16px',
        },
        '& .mapboxgl-popup-tip': {
            borderWidth: '20px !important',
        },
        '& .mapboxgl-popup-close-button': {
            fontFamily: 'sans-serif',
            fontSize: (props: StylesProps) =>
                !props.isMobile ? '33px' : '27px',
            fontWeight: 300,
            position: 'absolute',
            top: '-5px',
            right: '2px',
            '&:hover': {
                backgroundColor: 'rgb(255 255 255 / 0%)',
            },
        },
    },
}))

interface Props {
    store: Store
    forSmallMarker: boolean
    closePopup?: () => void
}

export const CustomStorePopup = ({
    store,
    forSmallMarker,
    closePopup,
}: Props) => {
    const { isMobile } = useMobile()
    const classes = useStyles({ isMobile })
    return (
        <Popup
            latitude={store.lat}
            longitude={store.lng}
            closeButton={false}
            offsetTop={forSmallMarker ? -30 : -80}
            className={classes.popup}
        >
            <PopupCommon closePopup={closePopup} store={store} />
        </Popup>
    )
}
</file>

<file path="components/molecules/Map/Mapbox/Layers.ts">
import { LayerProps } from 'react-map-gl/src/components/layer'

export const clusterLayer = {
    id: 'clusters',
    type: 'circle',
    source: 'stores',
    paint: {
        'circle-color': [
            'step',
            ['number', ['get', 'point_count'], 1],
            '#333333',
            100,
            '#333333',
        ],
        'circle-radius': [
            'step',
            ['number', ['get', 'point_count'], 1],
            20,
            10,
            20,
        ],
    },
} as LayerProps

export const clusterLayerShadow = {
    id: 'clustersShadow',
    type: 'circle',
    source: 'stores',
    paint: {
        'circle-radius': [
            'step',
            ['number', ['get', 'point_count'], 1],
            24,
            20,
            24,
        ],
        'circle-color': '#999',
        'circle-opacity': 0.7,
    },
} as LayerProps

export const clusterCountLayer = {
    id: 'cluster-count',
    type: 'symbol',
    source: 'stores',
    filter: ['has', 'point_count'],
    layout: {
        'text-field': '{point_count_abbreviated}',
        'text-font': ['Heebo ExtraBold'],
        'text-size': 12,
    },
    paint: {
        'text-color': '#ffffff',
    },
} as any as LayerProps

export const unclusterCountLayer = {
    id: 'uncluster-count',
    type: 'symbol',
    source: 'stores',
    filter: ['!', ['has', 'point_count']],
    layout: {
        'text-field': '1',
        'text-font': ['Heebo ExtraBold'],
        'text-size': 12,
    },
    paint: {
        'text-color': '#ffffff',
    },
} as any as LayerProps
</file>

<file path="components/molecules/Map/Mapbox/MapView.tsx">
import React, { useEffect, useRef, useState } from 'react'
import ReactMapGL, { Layer, NavigationControl, Source } from 'react-map-gl'
import { GeoJSON } from 'lib/geojson/GeoJSON'
import {
    clusterCountLayer,
    clusterLayer,
    clusterLayerShadow,
    unclusterCountLayer,
} from 'components/molecules/Map/Mapbox/Layers'
import {
    useMapViewportState,
    useLocationSelectedStoreState,
    useSetDefineLocationMapViewportState,
    useUpdateStoresViewportState,
} from 'lib/state/location'
import { CustomMarker } from 'components/molecules/Map/Mapbox/CustomMarker'
import { CustomStorePopup } from 'components/molecules/Map/Mapbox/CustomStorePopup'
import { useConfig } from 'lib/sdk/hooks/useConfig'
import { Store } from 'lib/state/store/types'
import { WebMercatorViewport } from 'viewport-mercator-project'
import {
    mapBoxLinearInterpolator,
    mapStyleTheme,
} from 'lib/utils/locationUtils'
import { grab, pointer } from 'components/molecules/Map/Mapbox/cursors'
import { useMobile } from 'lib/utils/useMobile'
import { scrollIntoStore } from 'components/molecules/Map/helper'

interface Props {
    stores: Store[]
    handleUpdate: boolean
}

export const MapView = ({ stores, handleUpdate }: Props) => {
    const { isMobile } = useMobile()
    const mapRef = useRef(null)
    const [globalViewport] = useMapViewportState()
    const updateStoresViewport = useUpdateStoresViewportState()
    const setDefineLocationMapViewportState =
        useSetDefineLocationMapViewportState()
    const [viewport, setViewport] = useState(globalViewport)
    const [locationSelectedStore, setLocationSelectedStore] =
        useLocationSelectedStoreState()
    const [storesGeo, setStoresGeo] = useState({} as any)
    const [storesToDisplay, setStoresToDisplay] = useState([] as Store[])
    const [isTransitionInProgress, setIsTransitionInProgress] = useState(false)
    const [cursor, setCursor] = useState(grab)
    const [isUnmount, setIsUnmount] = useState(false)

    const { mapboxApiAccessToken } = useConfig()
    const navControlStyle = {
        right: 20,
        bottom: 50,
    }

    const setLocationStoreSelected = (store: Store | undefined) => {
        setLocationSelectedStore(store)
    }

    useEffect(() => {
        setViewport({ ...viewport, ...globalViewport })
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [globalViewport])

    useEffect(() => {
        updateStoresToDisplayExternalViewport(updateStoresViewport)
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [updateStoresViewport])

    useEffect(() => {
        const geo = new GeoJSON()
        const geoStores = geo.parse(stores, { Point: ['lat', 'lng'] })
        setStoresGeo(geoStores)
        updateStoresToDisplay()
        return () => {
            setIsUnmount(true)
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [stores])

    const closeStorePopup = () => {
        setLocationStoreSelected(undefined)
    }

    const selectStore = (store) => {
        setLocationStoreSelected(store)
        scrollIntoStore(isMobile, store)
    }

    const handleViewportChange = (viewport) => {
        if (!handleUpdate || isUnmount) {
            return
        }
        setViewport(viewport)
        setDefineLocationMapViewportState(viewport)
    }

    const getFeatures = (pos) => {
        const map = mapRef.current as any
        if (!map || !pos || !map.getMap().loaded()) {
            return []
        }

        const queryParams = {
            layers: [clusterLayer.id!],
        }

        try {
            return map.queryRenderedFeatures(pos, queryParams)
        } catch {
            return []
        }
    }

    const getCursor = () => {
        return cursor
    }

    const onHover = (event) => {
        event.features = getFeatures(event.point)
        const feature = event.features[0]
        if (!feature) {
            if (cursor !== grab) {
                setCursor(grab)
            }
            return
        }
        if (cursor !== pointer) {
            setCursor(pointer)
        }
    }

    const onClick = (event) => {
        event.features = getFeatures(event.point)
        const feature = event.features[0]
        if (!feature) {
            return
        }
        const clusterId = feature.properties.cluster_id

        const map = mapRef.current as any
        const mapboxSource = map.getMap().getSource('stores')

        mapboxSource.getClusterExpansionZoom(clusterId, (err, zoom) => {
            if (err) {
                return
            }
            handleViewportChange({
                longitude: feature.geometry.coordinates[0],
                latitude: feature.geometry.coordinates[1],
                zoom: isNaN(zoom) ? 7 : zoom + 3,
                transitionDuration: 50,
                transitionInterpolator: mapBoxLinearInterpolator,
            })
        })
    }

    const inBounds = (point, bounds) => {
        const lng = (point.lng - bounds[0][0]) * (point.lng - bounds[1][0]) < 0
        const lat = (point.lat - bounds[0][1]) * (point.lat - bounds[1][1]) < 0
        return lng && lat
    }

    const updateStoresToDisplayExternalViewport = (externalViewport: any) => {
        if (
            externalViewport === undefined ||
            externalViewport.zoom < zoomChange ||
            isTransitionInProgress ||
            !handleUpdate
        ) {
            return
        }

        const webMercatorViewport = new WebMercatorViewport(
            externalViewport as any
        )
        const bounds = webMercatorViewport.getBounds()
        const st = stores.filter((x) => inBounds(x, bounds))

        setTimeout(() => {
            setIsTransitionInProgress(true)
        }, 1)
        setTimeout(() => {
            setStoresToDisplay(st)
            setIsTransitionInProgress(false)
        }, 10)
    }

    const updateStoresToDisplay = () => {
        updateStoresToDisplayExternalViewport(viewport)
    }

    const getMapStyle = () => {
        return {
            width: '100%',
            height: !isMobile ? '100%' : '260px',
        }
    }

    const zoomChange = 6.5
    return (
        <>
            <ReactMapGL
                ref={mapRef}
                mapboxApiAccessToken={mapboxApiAccessToken}
                mapStyle={mapStyleTheme}
                {...viewport}
                {...getMapStyle()}
                onViewportChange={handleViewportChange}
                onTransitionEnd={updateStoresToDisplay}
                onTouchEnd={updateStoresToDisplay}
                onMouseUp={updateStoresToDisplay}
                minZoom={2}
                onClick={onClick}
                getCursor={getCursor}
                onHover={onHover}
                scrollZoom={{
                    speed: 0.1,
                    smooth: false,
                }}
            >
                {viewport.zoom >= zoomChange &&
                    storesToDisplay.map((store, index) => {
                        return (
                            <CustomMarker
                                key={`store-${index}`}
                                marker={store}
                                openPopup={selectStore}
                                size="25px"
                            />
                        )
                    })}
                {viewport.zoom >= zoomChange &&
                    locationSelectedStore !== undefined && (
                        <CustomStorePopup
                            store={locationSelectedStore}
                            forSmallMarker={true}
                            closePopup={closeStorePopup}
                        />
                    )}
                {
                    <Source
                        id="stores"
                        type="geojson"
                        data={storesGeo}
                        cluster={true}
                        clusterMaxZoom={7}
                        clusterRadius={70}
                    >
                        <Layer maxzoom={zoomChange} {...clusterLayerShadow} />
                        <Layer maxzoom={zoomChange} {...clusterLayer} />
                        <Layer maxzoom={zoomChange} {...unclusterCountLayer} />
                        <Layer maxzoom={zoomChange} {...clusterCountLayer} />
                    </Source>
                }
                <NavigationControl
                    style={navControlStyle}
                    showCompass={false}
                />
            </ReactMapGL>
        </>
    )
}
</file>

<file path="components/molecules/Map/Mapbox/SelectedStoreMap.tsx">
import React, { useCallback, useEffect, useRef, useState } from 'react'
import ReactMapGL, { NavigationControl } from 'react-map-gl'
import { useSuccessBookingCartInfoState } from 'lib/state/cart'
import { useCartStoreState } from 'lib/state/store'
import { CustomMarker } from 'components/molecules/Map/Mapbox/CustomMarker'
import { CustomStorePopup } from 'components/molecules/Map/Mapbox/CustomStorePopup'
import { useConfig } from 'lib/sdk/hooks/useConfig'
import { mapStyleTheme } from 'lib/utils/locationUtils'

const mapStyle = {
    width: '100%',
    height: '100%',
}

const navControlStyle = {
    right: 20,
    bottom: 50,
}

interface Props {
    isShowStorePopup?: boolean
    displayNavigationControl?: boolean
    markerSize?: number | string
}

export const SelectedStoreMap = ({
    isShowStorePopup = true,
    displayNavigationControl = false,
    markerSize,
}: Props) => {
    const mapRef = useRef(null)
    const { mapboxApiAccessToken } = useConfig()
    const successBookingCartInfo = useSuccessBookingCartInfoState()
    const cartStore = useCartStoreState()
    const selectedStore = cartStore ?? successBookingCartInfo?.store
    const [state, setState] = useState({ viewport: {} })

    useEffect(() => {
        setState({
            ...state,
            viewport: {
                latitude: selectedStore?.lat,
                longitude: selectedStore?.lng,
                zoom: 14,
            },
        })
        // eslint-disable-next-line
    }, [selectedStore])

    const handleViewportChange = useCallback(
        (viewport) => {
            setState({ ...state, viewport })
        },
        // eslint-disable-next-line
        []
    )

    const { viewport } = state
    return (
        <>
            {selectedStore && (
                <ReactMapGL
                    ref={mapRef}
                    mapboxApiAccessToken={mapboxApiAccessToken}
                    mapStyle={mapStyleTheme}
                    {...viewport}
                    {...mapStyle}
                    onViewportChange={handleViewportChange}
                >
                    <CustomMarker
                        key={`store-${selectedStore.location.id}`}
                        marker={selectedStore}
                        size={markerSize ? markerSize : '65px'}
                    />
                    {isShowStorePopup && (
                        <CustomStorePopup
                            store={selectedStore}
                            forSmallMarker={false}
                        />
                    )}
                    {displayNavigationControl && (
                        <NavigationControl
                            style={navControlStyle}
                            showCompass={false}
                        />
                    )}
                </ReactMapGL>
            )}
        </>
    )
}
</file>

<file path="components/molecules/Map/helper.ts">
export const scrollIntoStore = (isMobile, store) => {
    if (!isMobile) {
        const element = document.getElementById(store?.location?.id)
        if (element) {
            element.scrollIntoView({
                behavior: 'smooth',
                block: 'start',
                inline: 'center',
            })
        }
    }
}
</file>

<file path="components/molecules/Map/MapFactory.tsx">
import React from 'react'
import { Store } from 'lib/state/store/types'
import { MapStores } from 'components/molecules/Map/Google/MapStores'
import { MapType, useAppConfig } from 'lib/state/config'
import { MapView } from 'components/molecules/Map/Mapbox/MapView'
import { useConfig } from 'lib/sdk/hooks/useConfig'

interface Props {
    stores: Store[]
    handleUpdate: boolean
}

export const MapFactory = ({ stores, handleUpdate }: Props) => {
    const { getMapType } = useAppConfig()
    const mapType = getMapType()
    const { mapboxApiAccessToken, googleMapsApiAccessToken } = useConfig()
    return (
        <>
            {mapType === MapType.MapBox && !!mapboxApiAccessToken && (
                <MapView stores={stores} handleUpdate={handleUpdate} />
            )}
            {mapType === MapType.Google && !!googleMapsApiAccessToken && <MapStores stores={stores} />}
        </>
    )
}
</file>

<file path="components/molecules/Map/PopupCommon.tsx">
import React from 'react'
import { Typography, Box } from '@mui/material'
import { makeStyles } from '@mui/styles'
import { FiX } from 'react-icons/fi'
import { getAddress } from 'lib/utils/locationUtils'
import { Store } from 'lib/state/store/types'
import { useMobile } from 'lib/utils/useMobile'

interface StylesProps {
    isMobile: boolean
}

const useStyles = makeStyles(() => ({
    popup: {
        maxWidth: (props: StylesProps) => (!props.isMobile ? '275px' : '214px'),
        '& .mapboxgl-popup-content': {
            filter: 'drop-shadow(0px 8px 16px rgba(0, 0, 0, 0.15))',
            padding: (props: StylesProps) =>
                !props.isMobile ? '16px' : '14px 33px 14px 16px',
        },
        '& .mapboxgl-popup-tip': {
            borderWidth: '20px !important',
        },
        '& .mapboxgl-popup-close-button': {
            fontFamily: 'sans-serif',
            fontSize: (props: StylesProps) =>
                !props.isMobile ? '33px' : '27px',
            fontWeight: 300,
            position: 'absolute',
            top: '-5px',
            right: '2px',
            '&:hover': {
                backgroundColor: 'rgb(255 255 255 / 0%)',
            },
        },
    },
    closeIcon: {
        position: 'absolute',
        top: (props: StylesProps) => (!props.isMobile ? 13 : 4),
        right: (props: StylesProps) => (!props.isMobile ? 13 : 6),
        cursor: 'pointer',
    },
}))

interface Props {
    store: Store
    closePopup?: () => void
}

export const PopupCommon = ({ store, closePopup }: Props) => {
    const { isMobile } = useMobile()
    const classes = useStyles({ isMobile })
    return (
        <>
            {!!closePopup && (
                <Box className={classes.closeIcon} onClick={closePopup}>
                    <FiX size={!isMobile ? 25 : 21} />
                </Box>
            )}
            {!isMobile && (
                <Typography variant="body2" sx={{ fontSize: 13 }}>
                    Your store
                </Typography>
            )}
            <Typography variant="h3" sx={{ pt: !isMobile ? 1 : 0 }}>
                {store.location.name}
            </Typography>
            <Typography variant="body2" sx={{ pt: 1 }}>
                {getAddress(store)}
            </Typography>
        </>
    )
}
</file>

<file path="components/molecules/MobileSelectedServiceSelector/index.tsx">
import FormControl from '@mui/material/FormControl'
import Select, { SelectChangeEvent } from '@mui/material/Select'
import {
    useActiveSelectedService,
    useSelectedServices,
    useSetActiveSelectedService,
} from 'lib/state/services'
import {
    CustomMenuItem,
    useStyles,
} from 'components/molecules/MobileSelectedServiceSelector/useStyles'
import { useSelectedServiceChange } from 'components/molecules/Services/SelectedServices/useSelectedServiceChange'

export const MobileSelectedServiceSelector = () => {
    const activeSelectedService = useActiveSelectedService()
    const setActiveSelectedService = useSetActiveSelectedService()
    const { selectedServicesStateValue, reverseSelectedServices } =
        useSelectedServices()
    const reversedList = reverseSelectedServices(selectedServicesStateValue)
    const {handleServiceChange} = useSelectedServiceChange()

    const handleChange = async (event: SelectChangeEvent) => {
        const bookableItem = selectedServicesStateValue.find((x) => x.id === event.target.value)
        setActiveSelectedService(bookableItem)
        if (bookableItem) {
            await handleServiceChange(bookableItem)
        }
    }

    const classes = useStyles()
    return (
        <FormControl className={classes.formControl}>
            <Select
                value={activeSelectedService?.id}
                onChange={handleChange}
                variant="standard"
                classes={{
                    root: classes.selectRoot,
                    icon: classes.icon,
                }}
                MenuProps={{
                    sx: {
                        '& .MuiPaper-root': { left: '0!important' },
                    },
                }}
            >
                {reversedList?.map((cartItem) => (
                    <CustomMenuItem key={cartItem.id} value={cartItem.id}>
                        {cartItem.item.name}
                    </CustomMenuItem>
                ))}
            </Select>
        </FormControl>
    )
}
</file>

<file path="components/molecules/MobileSelectedServiceSelector/useStyles.ts">
import { createStyles, makeStyles, withStyles } from '@mui/styles'
import { Theme } from '@mui/material'
import { colors } from 'constants/colors'
import MenuItem from '@mui/material/MenuItem'

export const CustomMenuItem = withStyles(() =>
    createStyles({
        root: {
            height: '72px',
            fontSize: '16px',
        },
    })
)(MenuItem)

export const useStyles = makeStyles((theme: Theme) => ({
    block: {
        padding: theme.spacing(2, 2),
        cursor: 'pointer',
        borderBottom: `1px solid ${theme.palette.custom.lightGray}`,
    },
    row: {
        display: 'flex',
        flexDirection: 'row',
    },
    arrow: {
        marginRight: '20px',
    },
    itemName: {
        fontSize: '16px',
    },
    formControl: {
        '& .MuiInput-underline:hover:not(.Mui-disabled):before': {
            borderColor: 'white',
        },
    },
    selectRoot: {
        fontSize: '16px',
        fontWeight: 700,
        borderBottom: `1px solid ${theme.palette.custom.lightGray}`,
        '&:before': {
            borderColor: 'white',
        },
        '&:after': {
            borderColor: 'white',
        },
        '&:focus-within .MuiSelect-standard': {
            backgroundColor: 'white',
        },
        '& .MuiInput-input': {
            paddingLeft: '16px',
            lineHeight: '66px',
        },
    },

    icon: {
        fill: `${colors.primary.main}`,
        marginRight: '10px',
    },
}))
</file>

<file path="components/molecules/MobileSummary/index.tsx">
import React from 'react'
import { Typography, Theme, Box, Collapse } from '@mui/material'
import { createStyles, makeStyles } from '@mui/styles'
import { FiX } from 'react-icons/fi'
import { useFlowStep } from 'lib/state/booking-flow'
import { Step } from 'lib/state/booking-flow/types'
import { useCartState } from 'lib/state/cart'
import { useCartStoreState } from 'lib/state/store'
import formatDateFns, { cartTimeToDate } from 'lib/utils/formatDateFns'
import { useIsSummaryBlockOpenState } from 'lib/state/summary'
import { getLocationName } from 'lib/utils/locationUtils'
import { theme } from 'styles/theme'
import { useMobile } from 'lib/utils/useMobile'
import { Location } from 'components/atoms/layout/summary/Location'
import { Services } from 'components/atoms/layout/summary/Services'
import { Time } from 'components/atoms/layout/summary/Time'

const useStyles = makeStyles((theme: Theme) =>
    createStyles({
        mobileSummary: {
            position: 'sticky',
            width: '100%',
            top: '46px',
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'flex-start',
            alignItems: 'flex-start',
            'z-index': '1001',
            backgroundColor: '#ffffff',
        },
        mobileTopBlock: {
            width: '100%',
            height: '52px',
            display: 'flex',
            flexDirection: 'row',
            justifyContent: 'space-between',
            alignItems: 'center',
            padding: '0 16px',
        },
        collapsedSummaryBlock: {
            width: '100%',
            position: 'absolute',
            top: '51px',
            backgroundColor: '#ffffff',
        },
    })
)

export default function MobileSummary() {
    const { isMobile } = useMobile()
    const classes = useStyles()
    const { currentFlowStep } = useFlowStep()
    const cart = useCartState()
    const selectedStore = useCartStoreState()
    const [isSummaryBlockOpen, setIsSummaryBlockOpen] =
        useIsSummaryBlockOpenState()

    const openMobileSummary = async () => {
        setIsSummaryBlockOpen(true)
    }

    const closeMobileSummary = () => {
        setIsSummaryBlockOpen(false)
    }

    if (
        !isMobile ||
        currentFlowStep.step === Step.ChooseLocation ||
        currentFlowStep.step === Step.BookingSuccess ||
        currentFlowStep.step === Step.LoadingStep
    ) {
        return null
    }

    return (
        <Box className={classes.mobileSummary}>
            <Box
                className={classes.mobileTopBlock}
                sx={{
                    boxShadow: isSummaryBlockOpen
                        ? 'none'
                        : '0px 4px 8px rgba(51, 52, 60, 0.06)',
                }}
            >
                <Box>
                    <Typography
                        color={theme.palette.primary.main}
                        fontSize="13px"
                    >
                        Your appointment
                    </Typography>
                    <Typography variant="body1" component="span">
                        {' '}
                        At{' '}
                    </Typography>
                    <Typography
                        variant="body1"
                        component="span"
                        fontWeight="bold"
                    >
                        {getLocationName(selectedStore)}
                    </Typography>
                    {cart?.startTime && (
                        <>
                            <Typography variant="body1" component="span">
                                {' '}
                                on{' '}
                            </Typography>
                            <Typography
                                variant="body1"
                                component="span"
                                fontWeight="bold"
                            >
                                {formatDateFns(
                                    cartTimeToDate(cart?.startTime),
                                    selectedStore?.location.tz,
                                    'MM/dd/yyyy'
                                )}
                            </Typography>
                        </>
                    )}
                </Box>
                {!isSummaryBlockOpen ? (
                    <Typography
                        variant="subtitle2"
                        fontWeight="500"
                        fontSize="16px"
                        sx={{ cursor: 'pointer' }}
                        onClick={openMobileSummary}
                    >
                        View
                    </Typography>
                ) : (
                    <FiX size={20} onClick={closeMobileSummary} />
                )}
            </Box>
            <Collapse
                in={isSummaryBlockOpen}
                timeout="auto"
                className={classes.collapsedSummaryBlock}
            >
                <Location />
                <Services />
                <Time />
            </Collapse>
        </Box>
    )
}
</file>

<file path="components/molecules/PaymentSummaryControl/index.tsx">
import { useCartState } from 'lib/state/cart'
import { useSelectedServices } from 'lib/state/services'
import { Box, Typography } from '@mui/material'
import { PriceLabel, PriceLabelByBookableItem } from 'lib/utils/formatCurrency'
import { useStyles } from 'components/molecules/PaymentSummaryControl/useStyles'
import Color from 'config/colors.json'

interface Props {
    isTopSummaryMode: boolean
    onServiceNameClick?: (bookableItem) => void
}

export const PaymentSummaryControl = ({isTopSummaryMode, onServiceNameClick}: Props) => {
    const classes = useStyles()
    const cart = useCartState()
    const { selectedServicesStateValue, reverseSelectedServices } =
        useSelectedServices()
    const reversedList = reverseSelectedServices(selectedServicesStateValue)
    const onServiceNameClickInternal = async (bookableItem) => {
        if (onServiceNameClick) {
            await onServiceNameClick(bookableItem)
        }
    }
    const hasServices = selectedServicesStateValue.length > 0
    return (
        <>
            <Box className={classes.servicesBlock} sx={{borderBottom: isTopSummaryMode ? 'none' : '1px solid #C4C4C4'}}>
                {reversedList.map((bookableItem) => (
                    <Box
                        key={bookableItem.id}
                        className={classes.boxWrapperCommon}
                    >
                        <Box>
                            <Typography
                                sx={{ pr: 2 }}
                                variant="body2"
                                component="span"
                            >
                                x1
                            </Typography>
                            <Typography component="span"
                                onClick={() => onServiceNameClickInternal(bookableItem)}
                                sx={{
                                    cursor: isTopSummaryMode ? "pointer" : undefined,
                                    color: isTopSummaryMode ? Color.primary.main: undefined
                            }}>
                                {` ${bookableItem.item.name}`}
                            </Typography>
                        </Box>
                        <Typography sx={{ pl: 1 }}>
                            {PriceLabelByBookableItem(bookableItem)}
                        </Typography>
                    </Box>
                ))}
            </Box>
            <Box
                className={classes.boxWrapperCommon}
                sx={{
                    pt: 2,
                }}
            >
                <Typography>Total (exc. tax)</Typography>
                <Typography>
                    {hasServices ? PriceLabel(cart?.summary.subtotal, true) : 'Pending'}
                </Typography>
            </Box>
            <Box
                className={classes.boxWrapperCommon}
                sx={{
                    pb: 3,
                }}
            >
                <Typography>Tax</Typography>
                <Typography sx={{ pl: 1 }}>
                    {hasServices ? PriceLabel(cart?.summary.taxAmount, true) : 'Pending'}
                </Typography>
            </Box>
            <Box className={classes.totalBlock}>
                <Typography>{isTopSummaryMode ? 'Estimated order total:' : 'Order total:'}</Typography>
                <Typography sx={{ pl: 1 }}>
                    {hasServices ? PriceLabel(cart?.summary.total, true) : 'Pending'}
                </Typography>
            </Box>
        </>
    )
}
</file>

<file path="components/molecules/PaymentSummaryControl/useStyles.ts">
import { makeStyles } from '@mui/styles'
import { Theme } from '@mui/material'

export const useStyles = makeStyles((theme: Theme) => ({
    servicesBlock: {
        paddingBottom: theme.spacing(2),
    },
    totalBlock: {
        display: 'flex',
        flexDirection: 'row',
        justifyContent: 'center',
        marginLeft: theme.spacing(-3),
        marginRight: theme.spacing(-3),
        paddingTop: theme.spacing(3),
        borderTop: '1px dashed #C4C4C4',
    },
    boxWrapperCommon: {
        display: 'flex',
        flexDirection: 'row',
        justifyContent: 'space-between',
    }
}))
</file>

<file path="components/molecules/Services/BookingSuccess/index.tsx">
import { Box, Button, Grid, Theme, Typography } from '@mui/material'
import { theme } from 'styles/theme'
import { makeStyles } from '@mui/styles'
import formatDateFns, { cartTimeToDate } from 'lib/utils/formatDateFns'
import getTimeZoneAbbr from 'lib/utils/getTimeZoneAbbr'
import { stepScreen } from 'constants/styles'
import { appExternalUrl, getAddress, getLocationName, getNavigationUrl, } from 'lib/utils/locationUtils'
import { SelectedStoreMap } from 'components/molecules/Map/Mapbox/SelectedStoreMap'
import { useCartMethods, useSuccessBookingCartInfoState } from 'lib/state/cart'
import { useMobile } from 'lib/utils/useMobile'
import { usePersonalInformationState } from 'lib/state/personal-info'
import { useSelectedServices } from 'lib/state/services'
import { useCartBookableItemListStaff } from 'lib/state/staff'
import { MapType, useAppConfig } from 'lib/state/config'
import { SelectedStoreMapGoogle } from 'components/molecules/Map/Google/SelectedStoreMapGoogle'
import { useConfig } from 'lib/sdk/hooks/useConfig'

interface StylesProps {
    isMobile: boolean
}

const useStyles = makeStyles((theme: Theme) => ({
    root: (props: StylesProps) => ({
        ...stepScreen(theme).root(props.isMobile),
        paddingTop: !props.isMobile ? theme.spacing(8) : '86px',
    }),
}))

export default function BookingSuccess() {
    const appointmentBooked = 'Appointment Booked!'
    const orderComplete = 'Order complete!'
    const weLookForward = 'We look forward to seeing you! Please check your email for additional details'
    const thankYou = 'Thank you for your order! Please check your email for additional details.'

    const { isMobile } = useMobile()
    const classes = useStyles({ isMobile })
    const successBookingCartInfo = useSuccessBookingCartInfoState()
    const store = successBookingCartInfo?.store
    const startTime = successBookingCartInfo?.startTime
    const icsLink = successBookingCartInfo?.icsLink
    const locationTimeZone = store?.location.tz
    const timeZoneAbbr = getTimeZoneAbbr(locationTimeZone)
    const [personalInformation] = usePersonalInformationState()
    const { selectedServicesStateValue } = useSelectedServices()
    const { isCartAvailableBookableItem } = useCartMethods()
    const hasServices = selectedServicesStateValue.filter(x=>isCartAvailableBookableItem(x.item)).length > 0
    const selectedServicesName = selectedServicesStateValue.map(
        (service) => service.item.name
    )
    const { getMapType } = useAppConfig()
    const mapType = getMapType()
    const { googleMapsApiAccessToken, mapboxApiAccessToken } = useConfig()

    const cartBookableItemListStaff = useCartBookableItemListStaff()

    const onContinueShopping = () => {
        location.href = appExternalUrl
    }

    const onBack = () => {
        location.reload()
    }

    return (
        <div className={classes.root}>
            <Grid
                container
                direction="row"
                justifyContent="center"
                alignItems="center"
            >
                <Grid
                    container
                    item
                    xs={12}
                    sm={9}
                    lg={6}
                    display="flex"
                    direction="column"
                    justifyContent="center"
                    alignItems="center"
                >
                    <Typography variant={!isMobile ? 'h1' : 'h2'}>
                        {hasServices ? appointmentBooked : orderComplete}
                    </Typography>
                    <Typography
                        variant="body2"
                        sx={{ pt: 1, textAlign: 'center' }}
                    >
                        {hasServices ? weLookForward : thankYou}
                    </Typography>
                    <Box sx={{ mt: !isMobile ? 11 : 2, width: '100%' }}>
                        <Grid
                            container
                            sx={{
                                pb: 3,
                            }}
                        >
                            <Grid
                                item
                                xs={isMobile ? 12 : 4}
                                sx={{
                                    maxWidth: !isMobile ? 200 : 'auto',
                                    display: !isMobile ? 'block' : 'flex',
                                    flexDirection: 'row',
                                    justifyContent: 'center',
                                }}
                            >
                                <Box
                                    sx={{
                                        height: 200,
                                        maxWidth: 200,
                                        width: !isMobile ? 'auto' : 200,
                                    }}
                                >
                                    {!!mapboxApiAccessToken && mapType === MapType.MapBox &&
                                        <SelectedStoreMap
                                            isShowStorePopup={false}
                                            markerSize="33px"
                                        />
                                    }
                                    {!!googleMapsApiAccessToken && mapType === MapType.Google
                                        && <SelectedStoreMapGoogle/>
                                    }
                                </Box>
                            </Grid>
                            <Grid
                                item
                                xs={isMobile ? 12 : 8}
                                sx={{ pl: 2, pt: !isMobile ? 0 : 5 }}
                            >
                                <Box
                                    sx={{
                                        pt: 1,
                                        pb: 2,
                                        pl: 2,
                                        pr: !isMobile ? 0 : 2,
                                        borderBottom: `1px solid ${theme.palette.custom.lightGray}`,
                                    }}
                                >
                                    <Box
                                        sx={{
                                            display: 'flex',
                                            flexDirection: !isMobile
                                                ? 'row'
                                                : 'column',
                                            justifyContent: 'space-between',
                                        }}
                                    >
                                        <Box>
                                            <Typography
                                                variant="h3"
                                                component="span"
                                                fontSize="16px"
                                                sx={{ pr: 2 }}
                                            >
                                                {getLocationName(store)}
                                            </Typography>
                                            <Typography
                                                variant="body2"
                                                sx={{ pt: '5px' }}
                                            >
                                                {getAddress(store)}
                                            </Typography>
                                        </Box>
                                        <a
                                            href={getNavigationUrl(
                                                store?.location
                                            )}
                                            target="_blank"
                                            rel="noreferrer"
                                            style={{
                                                textDecoration: 'none',
                                            }}
                                        >
                                            <Typography
                                                variant="subtitle2"
                                                sx={{
                                                    paddingTop: !isMobile
                                                        ? 0
                                                        : '5px',
                                                    fontSize: '13px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600',
                                                }}
                                            >
                                                Get Directions
                                            </Typography>
                                        </a>
                                    </Box>
                                </Box>
                                <Box
                                    sx={{ pt: 2, pl: 2, pr: !isMobile ? 0 : 2 }}
                                >
                                    <Typography variant="h3">
                                        {`Appointment for ${personalInformation?.firstName} ${personalInformation?.lastName}`}
                                    </Typography>

                                    <Box sx={{ pt: 1 }}>
                                        {selectedServicesName?.map(
                                            (serviceName, index) => (
                                                <Typography
                                                    key={index}
                                                    variant="body2"
                                                    sx={{
                                                        textTransform:
                                                            'capitalize',
                                                    }}
                                                >
                                                    {serviceName}
                                                </Typography>
                                            )
                                        )}
                                    </Box>

                                    {hasServices && <Box sx={{ pt: 1 }}>
                                        <Typography variant="body1">
                                            {formatDateFns(
                                                cartTimeToDate(startTime),
                                                store?.location.tz,
                                                `${
                                                    !isMobile ? 'EEEE' : 'EEE'
                                                } MM/dd/yyyy`
                                            )}{' '}
                                            {formatDateFns(
                                                cartTimeToDate(startTime),
                                                store?.location.tz,
                                                "h:mmaaaaa'm' "
                                            )}
                                            {timeZoneAbbr}
                                        </Typography>
                                        {cartBookableItemListStaff?.filter(x=>selectedServicesStateValue.find(y=> y.id === x.cartBookableItemId))
                                            .map(
                                            (cartBookableItemStaff) => (
                                                <Typography
                                                    key={
                                                        cartBookableItemStaff.cartBookableItemId
                                                    }
                                                    variant="body1"
                                                >
                                                    {`With ${cartBookableItemStaff.staff.name}`}
                                                </Typography>
                                            )
                                        )}

                                        <a
                                            href={icsLink}
                                            target="_blank"
                                            rel="noreferrer"
                                            style={{
                                                textDecoration: 'none',
                                            }}
                                        >
                                            <Typography
                                                variant="subtitle2"
                                                sx={{
                                                    pt: '5px',
                                                    cursor: 'pointer',
                                                    fontSize: '13px',
                                                    fontWeight: '600',
                                                }}
                                            >
                                                Add to Calendar
                                            </Typography>
                                        </a>
                                    </Box>}
                                </Box>
                            </Grid>
                        </Grid>
                    </Box>
                    <Button
                        variant="contained"
                        sx={{
                            mt: !isMobile ? 10 : 4,
                            width: 170,
                            height: 38,
                        }}
                        onClick={onContinueShopping}
                    >
                        Return to Website
                    </Button>
                    <Typography
                        variant="subtitle2"
                        sx={{
                            mt: 3,
                            mb: 2,
                            cursor: 'pointer',
                        }}
                        onClick={onBack}
                    >
                        Book or purchase another
                    </Typography>
                </Grid>
            </Grid>
        </div>
    )
}
</file>

<file path="components/molecules/Services/ChooseDate/ManyDays/SelectAvailability.tsx">
import React, { useState } from 'react'
import { Typography, Box, Button, Popover, Theme } from '@mui/material'
import { makeStyles } from '@mui/styles'
import { styled } from '@mui/material/styles'
import { FiCalendar, FiChevronDown, FiChevronUp } from 'react-icons/fi'
import { SelectTime } from 'components/molecules/Services/ChooseDate/ManyDays/SelectTime'
import {
    useStaffTimes,
    useStaffTimesState,
    useTimesAreLoadingState,
} from 'lib/state/staffTime'
import { useCartStoreState } from 'lib/state/store'
import { SelectDate } from 'components/molecules/Services/ChooseDate/SelectDate'
import { isSameDay } from 'date-fns'
import { CartBookableDate } from '@boulevard/blvd-book-sdk/lib/cart'
import { useCartState } from 'lib/state/cart'
import { sortByDate } from 'lib/utils/sortUtils'
import formatDateFns from 'lib/utils/formatDateFns'
import { useMobile } from 'lib/utils/useMobile'
import { useTransition, animated, config } from 'react-spring'

const SelectDateButton = styled(Button)(() => ({
    width: 145,
    height: 36,
    border: 'none',
    color: '#33343C',
    textTransform: 'capitalize',
    fontSize: '14px',
    fontWeight: 'normal',
    '&:hover': {
        border: 'none',
        backgroundColor: '#ffffff00',
    },
}))

const LoadMoreButton = styled(Button)(() => ({
    width: 134,
    height: 38,
    borderColor: '#C3C7CF',
    borderRadius: 4,
    color: '#33343C',
    textTransform: 'capitalize',
    fontSize: '14px',
    fontWeight: 'normal',
    '&:hover': {
        borderColor: '#C3C7CF',
        backgroundColor: '#F9F9FB',
    },
}))

interface StylesProps {
    isMobile: boolean
}

const useStyles = makeStyles((theme: Theme) => ({
    selectTimeDesktop: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        paddingBottom: theme.spacing(1),
    },
    selectTimeHeaderMobile: {
        position: 'fixed',
        top: '96px',
        width: '100%',
        backgroundColor: '#ffffff',
        'z-index': '1000',
        padding: '16px 16px 8px 16px',
        margin: '0 -16px',
        display: 'flex',
    },
    selectTimesBlock: {
        height: 'calc(100% - 44px)',
        margin: (props: StylesProps) => (props.isMobile ? '0 -16px' : 0),
        paddingTop: (props: StylesProps) => (props.isMobile ? '142px' : 0),
        overflowY: 'scroll',
        '&::-webkit-scrollbar': {
            display: 'none',
        },
    },
    popover: {
        '& .MuiPopover-paper': {
            borderRadius: '8px',
            boxShadow: '0px 8px 16px rgba(0, 0, 0, 0.15)',
        },
    },
}))

export const SelectAvailability = () => {
    const { isMobile } = useMobile()
    const classes = useStyles({ isMobile })
    const staffTimesArray = useStaffTimesState()
    const selectedStore = useCartStoreState()
    const [anchorEl, setAnchorEl] = useState(null)
    const [changeOpacity, setChangeOpacity] = useState(false)
    const [filteredDate, setFilteredDate] = useState<Date | undefined>(
        undefined
    )
    const [isShowSeeMoreButton, setIsShowSeeMoreButton] = useState(true)
    const { loadStaffTimes, loadNextTimesPage } = useStaffTimes()
    const cart = useCartState()
    const timesAreLoading = useTimesAreLoadingState()
    const sortedSelectTimes = staffTimesArray
        .concat()
        .filter((x) => {
            return filteredDate === undefined || isSameDay(filteredDate, x.date)
        })
        .sort(sortByDate)

    const handleSelectDateButtonClick = (event) => {
        setChangeOpacity(true)
        setAnchorEl(event.currentTarget)
    }

    const handleClose = () => {
        setAnchorEl(null)
    }

    const open = Boolean(anchorEl)
    const id = open ? 'simple-popover' : undefined

    const onDayClick = async (
        day: Date,
        cartBookableDate: CartBookableDate
    ) => {
        handleClose()
        setFilteredDate(day)

        const staffDate = {
            date: day,
            cartBookableDate: cartBookableDate,
        }
        await loadStaffTimes(cart, staffDate, selectedStore?.location.tz)
    }

    const onClearDateClick = () => {
        setFilteredDate(undefined)
    }

    const seeMoreDays = async () => {
        setChangeOpacity(false)
        const hasMoreDays = await loadNextTimesPage(
            cart,
            selectedStore?.location.tz
        )
        setIsShowSeeMoreButton(hasMoreDays)
    }

    const maxHeightValue = 200

    const transition = useTransition(sortedSelectTimes, {
        from: { opacity: changeOpacity ? 0 : 1, maxHeight: 0 },
        enter: { opacity: 1, maxHeight: maxHeightValue },
        leave: {
            opacity: 0,
            maxHeight: 0,
            config: { ...config.stiff, duration: 500 },
        },
        config: () => ({
            ...config.stiff,
            duration: filteredDate ? 0 : 1000,
        }),
        keys: (staffTimes) =>
            `selectTimeTransition-${staffTimes.day}-${staffTimes.month}-${staffTimes.year}`,
    })

    return (
        <>
            <Box
                className={
                    isMobile
                        ? classes.selectTimeHeaderMobile
                        : classes.selectTimeDesktop
                }
            >
                <Typography variant="h2">Select a Time</Typography>
                <SelectDateButton
                    variant="outlined"
                    disableRipple={true}
                    startIcon={<FiCalendar size={18} />}
                    endIcon={
                        !anchorEl ? (
                            <FiChevronDown size={15} />
                        ) : (
                            <FiChevronUp size={15} />
                        )
                    }
                    onClick={handleSelectDateButtonClick}
                >
                    {filteredDate
                        ? formatDateFns(
                              filteredDate,
                              selectedStore?.location.tz,
                              'MM/dd/yyyy'
                          )
                        : 'Select date'}
                </SelectDateButton>
                <Popover
                    id={id}
                    className={classes.popover}
                    open={open}
                    anchorEl={anchorEl}
                    onClose={handleClose}
                    anchorOrigin={{
                        vertical: 'bottom',
                        horizontal: 'right',
                    }}
                    transformOrigin={{
                        vertical: 'top',
                        horizontal: 'right',
                    }}
                    sx={{ mt: 1, '& .MuiPaper-root': { width: 352 } }}
                >
                    <SelectDate
                        onDayClick={onDayClick}
                        filteredDate={filteredDate}
                    />
                </Popover>
            </Box>
            <Box className={classes.selectTimesBlock}>
                {transition(({ maxHeight, ...restStyle }, staffTimes) => (
                    <animated.div
                        style={{
                            ...restStyle,
                            maxHeight: maxHeight.to((x) => {
                                if (x < 5 && filteredDate) {
                                    return `0px`
                                }
                                return x > maxHeightValue - 10
                                    ? '100%'
                                    : `${x}px`
                            }),
                            overflow: maxHeight.to((x) =>
                                x > maxHeightValue - 10 ? '' : `hidden`
                            ),
                        }}
                        key={`selectTimeAnimated-${staffTimes.day}-${staffTimes.month}-${staffTimes.year}`}
                    >
                        <SelectTime
                            store={selectedStore}
                            staffTimes={staffTimes}
                            onClearDateClick={onClearDateClick}
                            filteredDate={filteredDate}
                            key={`selectTime-${staffTimes.day}-${staffTimes.month}-${staffTimes.year}`}
                        />
                    </animated.div>
                ))}
                {!filteredDate && isShowSeeMoreButton && !timesAreLoading && (
                    <Box
                        display="flex"
                        flexDirection="row"
                        justifyContent="center"
                    >
                        <LoadMoreButton
                            variant="outlined"
                            onClick={seeMoreDays}
                            sx={{ mt: 5, mb: 3, borderRadius: 0 }}
                        >
                            Load more days
                        </LoadMoreButton>
                    </Box>
                )}
            </Box>
        </>
    )
}
</file>

<file path="components/molecules/Services/ChooseDate/ManyDays/SelectTime.tsx">
import { Typography, Box } from '@mui/material'
import { makeStyles } from '@mui/styles'
import { StaffTimes } from 'lib/state/staffTime/types'
import formatDateFns from 'lib/utils/formatDateFns'
import { Store } from 'lib/state/store/types'
import { differenceInDays, isSameDay } from 'date-fns'
import { utcToZonedTime } from 'date-fns-tz'
import { useMobile } from 'lib/utils/useMobile'
import { Time } from 'components/molecules/Services/ChooseDate/Time'
import { DisplayTime } from 'components/molecules/Services/ChooseDate/DisplayTime'

const useStyles = makeStyles(() => ({
    timeBlock: {
        borderBottom: '1px dashed #C3C7CF',
    },
    dayTopRow: {
        display: 'flex',
        justifyContent: 'center',
        flexWrap: 'wrap',
        flexDirection: 'row',
        alignItems: 'center',
    },
    clearDateSelection: {
        textDecoration: 'underline',
        cursor: 'pointer',
        marginLeft: '20px',
    },
    buttonsWrapper: {
        display: 'flex',
        justifyContent: 'center',
        flexWrap: 'wrap',
    },
}))

interface Props {
    staffTimes: StaffTimes
    store: Store | undefined
    onClearDateClick: () => void
    filteredDate?: Date
}

export const SelectTime = ({
    staffTimes,
    store,
    onClearDateClick,
    filteredDate,
}: Props) => {
    const { isMobile } = useMobile()
    const classes = useStyles()
    const times = staffTimes.times
    const timeZone = store?.location.tz
    const currentDate = utcToZonedTime(new Date(), timeZone)
    currentDate.setHours(0)

    const getDifferenceInDaysText = (date: Date): string => {
        if (isSameDay(date, currentDate)) {
            return 'today'
        }
        const diff = differenceInDays(date, currentDate)
        return `${diff + 1}d away`
    }

    return (
        <Box sx={{ pt: 3, pb: 2 }} className={classes.timeBlock}>
            <Box
                className={classes.dayTopRow}
                sx={{ padding: isMobile ? '0 16px' : 0 }}
            >
                <Box>
                    <Typography variant="h3" component="span">
                        {formatDateFns(
                            staffTimes.date,
                            store?.location.tz,
                            'EEEE, MMM d'
                        )}
                    </Typography>
                    <Typography variant="body1" component="span" sx={{ pl: 1 }}>
                        {getDifferenceInDaysText(staffTimes.date)}
                    </Typography>
                </Box>
                {filteredDate && isSameDay(filteredDate!, staffTimes.date) && (
                    <Typography
                        variant="body1"
                        component="span"
                        className={classes.clearDateSelection}
                        onClick={onClearDateClick}
                    >
                        Clear date selection
                    </Typography>
                )}
            </Box>
            <Box
                className={classes.buttonsWrapper}
                sx={{ padding: isMobile ? '16px 16px 0 16px' : '16px 0 0 0' }}
            >
                {times.concat().map((time) => (
                    <DisplayTime
                        key={'time' + time.cartBookableTime?.id}
                        time={time}
                        store={store}
                    />
                ))}
            </Box>
        </Box>
    )
}
</file>

<file path="components/molecules/Services/ChooseDate/ManyDays/ShowTimeForManyDaysComponent.tsx">
import { Box, Theme } from '@mui/material'
import { SelectAvailability } from 'components/molecules/Services/ChooseDate/ManyDays/SelectAvailability'
import React from 'react'
import { makeStyles } from '@mui/styles'
import { stepScreen } from 'constants/styles'

const useStyles = makeStyles((theme: Theme) => ({
    rightPanelWrapper: {
        paddingTop: '11px',
        paddingLeft: '20px',
        paddingRight: '20px',
        height: '100%',
        overflowY: 'scroll',
        position: 'sticky',
        '&::-webkit-scrollbar': {
            display: 'none',
        },
    },
    blurScreen: stepScreen(theme).blurScreen,
    loader: stepScreen(theme).loader,
}))

export const ShowTimeForManyDaysComponent = () => {
    const classes = useStyles()
    return (
        <Box className={classes.rightPanelWrapper}>
            <SelectAvailability />
        </Box>
    )
}
</file>

<file path="components/molecules/Services/ChooseDate/OneDay/DayTimes.tsx">
import { StaffTime } from 'lib/state/staffTime/types'
import { makeStyles } from '@mui/styles'
import { Box, Typography } from '@mui/material'
import { Store } from 'lib/state/store/types'
import { DisplayTime } from 'components/molecules/Services/ChooseDate/DisplayTime'

interface Props {
    staffTimes: StaffTime[]
    dayTimeName: string
    store: Store | undefined
}

const useStyles = makeStyles(() => ({
    timeContainer: {
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'flex-start',
        alignItems: 'flex-start',
        flexWrap: 'wrap',
        paddingTop: '10px',
    },
    dayTimeBlock: {
        display: 'flex',
        flexDirection: 'row',
        justifyContent: 'flex-start',
        marginTop: '10px',
        width: '100%',
        paddingBottom: '5px',
    },
    buttonsWrapper: {
        display: 'flex',
        justifyContent: 'flex-start',
        flexWrap: 'wrap',
    },
}))

export const DayTimes = ({ staffTimes, dayTimeName, store }: Props) => {
    const classes = useStyles()

    return (
        <Box className={classes.timeContainer}>
            <Box className={classes.dayTimeBlock}>
                <Box
                    sx={{
                        fontWeight: 500,
                    }}
                >
                    {dayTimeName}
                </Box>
            </Box>
            <Box className={classes.buttonsWrapper}>
                {staffTimes.length > 0 &&
                    staffTimes.map((time) => (
                        <DisplayTime
                            key={'time' + time.cartBookableTime?.id}
                            time={time}
                            store={store}
                        />
                    ))}
                {staffTimes.length === 0 && (
                    <Typography fontWeight={500} color={'#C4C4C4'}>
                        Unavailable
                    </Typography>
                )}
            </Box>
        </Box>
    )
}
</file>

<file path="components/molecules/Services/ChooseDate/OneDay/SelectTime.tsx">
import { Box } from '@mui/material'
import { makeStyles } from '@mui/styles'
import React from 'react'
import { isSameDay } from 'date-fns'
import {
    useLoadingStaffTimeState,
    useStaffTimesState,
} from 'lib/state/staffTime'
import { DayTimes } from 'components/molecules/Services/ChooseDate/OneDay/DayTimes'
import { Store } from 'lib/state/store/types'
import { BounceLoader } from 'react-spinners'
import { useMobile } from 'lib/utils/useMobile'

interface StylesProps {
    isMobile: boolean
}

const useStyles = makeStyles(() => ({
    root: {
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'flex-start',
        justifyContent: 'center',
    },
    dayTimeLoadingWrapper: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        marginTop: (props: StylesProps) => (props.isMobile ? '50px' : '100px'),
        width: (props: StylesProps) => (props.isMobile ? '100%' : 'auto'),
    },
}))

interface Props {
    filteredDate?: Date
    store: Store | undefined
}

export const SelectTime = ({ filteredDate, store }: Props) => {
    const { isMobile } = useMobile()
    const classes = useStyles({ isMobile })
    const staffTimesArray = useStaffTimesState()
    const selectedDayTimes = staffTimesArray
        .concat()
        .filter((x) => {
            return filteredDate && isSameDay(filteredDate, x.date)
        })
        .flatMap((x) => x.times)

    const morningTimes = selectedDayTimes.filter(
        (x) => x.locationTime.getHours() < 12
    )

    const afternoonTimes = selectedDayTimes.filter(
        (x) => x.locationTime.getHours() >= 12 && x.locationTime.getHours() < 17
    )

    const eveningTimes = selectedDayTimes.filter(
        (x) => x.locationTime.getHours() >= 17
    )

    const loadingStaffTimeState = useLoadingStaffTimeState()
    return (
        <Box className={classes.root}>
            {loadingStaffTimeState && (
                <Box className={classes.dayTimeLoadingWrapper}>
                    <BounceLoader color="#dadada" size={60} />
                </Box>
            )}

            {!loadingStaffTimeState && (
                <>
                    <DayTimes
                        dayTimeName="Morning"
                        staffTimes={morningTimes}
                        store={store}
                    />
                    <DayTimes
                        dayTimeName="Afternoon"
                        staffTimes={afternoonTimes}
                        store={store}
                    />
                    <DayTimes
                        dayTimeName="Evening"
                        staffTimes={eveningTimes}
                        store={store}
                    />
                </>
            )}
        </Box>
    )
}
</file>

<file path="components/molecules/Services/ChooseDate/OneDay/ShowTimeForOneDayComponent.tsx">
import React, { useState, useContext, useEffect } from 'react'
import { Grid, Theme, Typography, Box } from '@mui/material'
import { makeStyles } from '@mui/styles'
import { SelectDate } from 'components/molecules/Services/ChooseDate/SelectDate'
import { StaffsInfoList } from 'components/molecules/Services/ChooseDate/OneDay/StaffsInfoList'
import { CartBookableDate } from '@boulevard/blvd-book-sdk/lib/cart'
import { useSetLoadingStaffTimeState, useStaffTimes } from 'lib/state/staffTime'
import { useCartStoreState } from 'lib/state/store'
import { SelectTime } from 'components/molecules/Services/ChooseDate/OneDay/SelectTime'
import { cartTimeToDate } from 'lib/utils/formatDateFns'
import { useStaffDates } from 'lib/state/staffDate'
import formatDateFns from 'lib/utils/formatDateFns'
import { useCartState } from 'lib/state/cart'
import { LayoutContext } from 'components/atoms/layout/LayoutContext'
import {
    useSelectedStaffTimeState,
    useSetSelectedStaffTimeState,
} from 'lib/state/staffTime'
import { useMobile } from 'lib/utils/useMobile'

interface StylesProps {
    isMobile: boolean
}

const useStyles = makeStyles((theme: Theme) => ({
    root: {
        overflowY: 'scroll',
        position: 'sticky',
        height: 'calc(100%)',
        '&::-webkit-scrollbar': {
            display: 'none',
        },
    },
    rightPanelWrapper: {
        padding: (props: StylesProps) =>
            !props.isMobile ? theme.spacing(4) : theme.spacing(2, 4),
    },
    left: {
        [theme.breakpoints.up('lg')]: {
            minWidth: '370px',
            maxWidth: '370px',
        },
        [theme.breakpoints.down('lg')]: {
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center',
            alignItems: 'center',
        },
    },
    right: {
        [theme.breakpoints.up('lg')]: {
            maxWidth: 'calc(100% - 370px) !important',
        },
        [theme.breakpoints.down('lg')]: {
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center',
            alignItems: 'center',
            paddingTop: (props: StylesProps) =>
                !props.isMobile ? theme.spacing(4) : theme.spacing(1),
        },
        paddingBottom: (props: StylesProps) =>
            props.isMobile ? theme.spacing(6) : 0,
    },
    rightWrapper: {
        [theme.breakpoints.down('lg')]: {
            width: '320px',
        },
    },
    selectedDay: {
        width: '320px',
        borderBottom: `3px solid ${theme.palette.primary.main}`,
        marginTop: theme.spacing(2),
        marginBottom: theme.spacing(3),
    },
}))

export const ShowTimeForOneDayComponent = () => {
    const { isMobile } = useMobile()
    const classes = useStyles({ isMobile })
    const cart = useCartState()
    const { getStaffDateState } = useStaffDates()
    const staffDatesStore = getStaffDateState()
    const [filteredDate, setFilteredDate] = useState<Date | undefined>(
        cartTimeToDate(
            cart?.startTime,
            staffDatesStore &&
                staffDatesStore.length > 0 &&
                staffDatesStore[0].dates.length > 0
                ? staffDatesStore[0].dates[0].date
                : new Date()
        )
    )
    const setLoadingStaffTimeState = useSetLoadingStaffTimeState()
    const selectedStore = useCartStoreState()
    const { loadStaffTimes } = useStaffTimes()
    const layout = useContext(LayoutContext)
    const selectedStaffTime = useSelectedStaffTimeState()
    const setSelectedStaffTime = useSetSelectedStaffTimeState()

    useEffect(() => {
        if (selectedStaffTime === undefined) {
            layout.setShowBottom(false)
        }
        // eslint-disable-next-line
    }, [selectedStaffTime])

    const onDayClick = async (
        day: Date,
        cartBookableDate: CartBookableDate
    ) => {
        setSelectedStaffTime(undefined)
        setFilteredDate(day)
        setLoadingStaffTimeState(true)
        const staffDate = {
            date: day,
            cartBookableDate: cartBookableDate,
        }
        loadStaffTimes(cart, staffDate, selectedStore?.location.tz).finally(
            () => {
                setLoadingStaffTimeState(false)
            }
        )
    }

    return (
        <Box className={classes.root}>
            <Grid container className={classes.rightPanelWrapper}>
                <Grid item lg={5} md={12} sm={12} xs={12} className={classes.left}>
                    <Box>
                        {isMobile && <StaffsInfoList />}
                        <Box className={classes.selectedDay}>
                            <Typography variant="h3" component="span">
                                {formatDateFns(
                                    filteredDate,
                                    selectedStore?.location.tz,
                                    'EEEE, MMMM d'
                                )}
                            </Typography>
                        </Box>
                        <SelectDate
                            onDayClick={onDayClick}
                            filteredDate={filteredDate}
                        />
                    </Box>
                </Grid>
                <Grid item lg={7} md={12} sm={12} xs={12} className={classes.right}>
                    <Box className={classes.rightWrapper}>
                        {!isMobile && <StaffsInfoList />}
                        <SelectTime
                            filteredDate={filteredDate}
                            store={selectedStore}
                        />
                        <Box sx={{ pt: 8 }} />
                    </Box>
                </Grid>
            </Grid>
        </Box>
    )
}
</file>

<file path="components/molecules/Services/ChooseDate/OneDay/StaffsInfoList.tsx">
import React from 'react'
import { makeStyles } from '@mui/styles'
import { Box, Theme, Typography } from '@mui/material'
import { useCartBookableItemListStaff } from 'lib/state/staff'
import { useSelectedServices } from 'lib/state/services'
import { CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import clsx from 'clsx'
import { useCartMethods } from 'lib/state/cart'

const useStyles = makeStyles((theme: Theme) => ({
    staffInfoList: {
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'flex-start',
        alignItems: 'flex-start',
    },
    item: {
        display: 'flex',
        flexDirection: 'row',
        justifyContent: 'flex-start',
        alignItems: 'center',
    },
    avatar: {
        width: 40,
        height: 40,
        display: 'inline-block',
        borderRadius: '50%',
        backgroundSize: '100%',
        marginRight: theme.spacing(2),
        marginTop: '5px',
        backgroundColor: theme.palette.primary.main + '4C',
        lineHeight: '40px',
        fontWeight: 'bold',
        fontSize: 16,
    },
    emptyAvatar: {
        textAlign: 'center',
        fontSize: '20px',
        color: '#FFFFFF',
    },
}))

export const StaffsInfoList = () => {
    const classes = useStyles()
    const { selectedServicesStateValue, reverseSelectedServices } =
        useSelectedServices()
    const reversedList = reverseSelectedServices(selectedServicesStateValue)
    const cartBookableItemListStaff = useCartBookableItemListStaff()
    const { isCartAvailableBookableItem } = useCartMethods()

    const getStaff = (bookableItemId: string) => {
        return cartBookableItemListStaff?.find(
            (s) => s.cartBookableItemId === bookableItemId
        )?.staff
    }

    return (
        <Box className={classes.staffInfoList}>
            {reversedList?.filter(x=>isCartAvailableBookableItem(x.item))
                .map((bookableItem: CartBookableItem) => (
                <Box key={bookableItem.id} className={classes.item}>
                    {getStaff(bookableItem.id)?.avatar ? (
                        <Box
                            className={classes.avatar}
                            sx={{
                                backgroundImage: `url(${
                                    getStaff(bookableItem.id)?.avatar
                                })`,
                            }}
                        />
                    ) : (
                        <Box
                            className={clsx(
                                classes.avatar,
                                classes.emptyAvatar
                            )}
                        >
                            N
                        </Box>
                    )}

                    <Box>
                        <Typography variant="h4">
                            {getStaff(bookableItem.id)?.name}
                        </Typography>
                        <Typography>{bookableItem.item.name}</Typography>
                    </Box>
                </Box>
            ))}
        </Box>
    )
}
</file>

<file path="components/molecules/Services/ChooseDate/ChooseDateScreen.tsx">
import React from 'react'
import WithLayout from 'components/atoms/layout/WithLayout'
import { DateTimeType, useAppConfig } from 'lib/state/config'
import { ShowTimeForOneDayComponent } from 'components/molecules/Services/ChooseDate/OneDay/ShowTimeForOneDayComponent'
import { ShowTimeForManyDaysComponent } from 'components/molecules/Services/ChooseDate/ManyDays/ShowTimeForManyDaysComponent'
import { Step } from 'lib/state/booking-flow/types'
import { useMobile } from 'lib/utils/useMobile'
import formatDateFns from 'lib/utils/formatDateFns'
import { useCartStoreState } from 'lib/state/store'
import { useSelectedStaffTimeState } from 'lib/state/staffTime'
import { WorkshopPanel } from 'components/molecules/Services/ChooseDate/WorkshopPanel'

export default function ChooseDateScreen() {
    const { isMobile } = useMobile()
    const { getDateTimeType } = useAppConfig()
    const dateTimeType = getDateTimeType()
    const selectedStaffTime = useSelectedStaffTimeState()
    const selectedStore = useCartStoreState()

    return (
        <WithLayout
            isShowLoader={false}
            rightPanel={
                <>
                    {dateTimeType === DateTimeType.ShowTimeForOneDay && (
                        <ShowTimeForOneDayComponent />
                    )}
                    {dateTimeType === DateTimeType.ShowTimeForManyDays && (
                        <ShowTimeForManyDaysComponent />
                    )}
                </>
            }
            rightPanelCaption="Select an availability"
            rightPanelBtnCaption={`Continue with ${formatDateFns(
                selectedStaffTime?.locationTime,
                selectedStore?.location.tz,
                'h:mmaaa'
            )}`}
            showBottom={false}
            addBackArrow={isMobile}
            backArrowStep={Step.SelectedServices}
            workshopPanel={<WorkshopPanel />}
        />
    )
}
</file>

<file path="components/molecules/Services/ChooseDate/DisplayTime.tsx">
import { StaffTime } from 'lib/state/staffTime/types'
import { Store } from 'lib/state/store/types'
import { useSelectedStaffTimeState } from 'lib/state/staffTime'
import { SelectedTime } from 'components/molecules/Services/ChooseDate/SelectedTime'
import { Time } from 'components/molecules/Services/ChooseDate/Time'

interface Props {
    time: StaffTime
    store: Store | undefined
}

export const DisplayTime = ({ time, store }: Props) => {
    const selectedStaffTime = useSelectedStaffTimeState()
    if (time.cartBookableTime?.id === selectedStaffTime?.cartBookableTime?.id) {
        return <SelectedTime store={store} />
    }

    return <Time time={time} store={store} />
}
</file>

<file path="components/molecules/Services/ChooseDate/SelectDate.tsx">
import { useState } from 'react'
import { DayModifiers } from 'react-day-picker'
import DayPicker from 'react-day-picker'
import { Theme, Box } from '@mui/material'
import { makeStyles } from '@mui/styles'
import 'react-day-picker/lib/style.css'
import { useCartState } from 'lib/state/cart'
import { useCartStoreState } from 'lib/state/store'
import { useStaffDates } from 'lib/state/staffDate'
import { CartBookableDate } from '@boulevard/blvd-book-sdk/lib/cart'

const useStyles = makeStyles((theme: Theme) => ({
    dayPickerWrapper: {
        backgroundColor: '#ffffff',
        boxShadow:
            '0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12)',
        borderRadius: '4px',
        width: '310px',
        height: '323px',
        padding: theme.spacing(3, 1, 1, 1),
    },
    calendarDayPicker: {
        width: '100%',
        height: '100%',
        '& .DayPicker-Caption': {
            padding: '0 10px !important',
            '& div': {
                fontWeight: 'normal !important',
                fontSize: '16px !important',
                textTransform: 'capitalize',
            },
        },
        '& .DayPicker-WeekdaysRow': {
            justifyContent: 'space-between',
        },
        '& .DayPicker-Weekday abbr': {
            fontSize: '12px',
        },
        '&.DayPicker:not(.DayPicker--interactionDisabled) .DayPicker-Day:not(.DayPicker-Day--disabled):not(.DayPicker-Day--selected):not(.DayPicker-Day--outside):hover > div > div > div':
            {
                backgroundColor: '#e2e8ed !important',
                borderRadius: '50% !important',
                color: '#33343C !important',
            },
    },
    calendarDayCell: {
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
        display: 'flex',
    },
    notAvailable: {
        '& div > div': {
            textDecoration: 'line-through',
            color: '#C3C7CF',
        },
    },
    disabled: {
        '& div > div': {
            color: '#C3C7CF',
        },
    },
    dateWrapper: {
        display: 'inline-block',
        width: '36px',
        height: '36px',
        lineHeight: '35px',
        marginTop: '-15px',
        boxSizing: 'content-box',
        fontSize: '14px',
        fontWeight: 400,
    },
    today: {
        color: '#33343C !important',
        textDecoration: 'underline !important',
        textUnderlineOffset: '2px !important',
        textDecorationThickness: '2px !important',
        fontWeight: 'bold!important' as any,
    },
    selected: {
        backgroundColor: theme.palette.primary.main,
        borderRadius: '50%',
        color: `${theme.palette.primary.contrastText} !important`,
    },
    calendarDayDate: {
        height: 0,
        lineHeight: 0,
    },
}))

interface Props {
    onDayClick: (day: Date, cartBookableDate: CartBookableDate) => void
    filteredDate?: Date
}

export const SelectDate = ({ onDayClick, filteredDate }: Props) => {
    const classes = useStyles()
    const fromMonth = new Date()
    fromMonth.setHours(0, 0, 0, 0)

    const cartState = useCartState()
    const cartStoreState = useCartStoreState()
    const [displayedMonth, setDisplayedMonth] = useState(
        filteredDate ?? new Date()
    )
    const { loadStaffDates, getStaffDateState } = useStaffDates()
    const staffDatesStore = getStaffDateState()
    const weekdaysShort = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']
    const [refresher, setRefresher] = useState(0)
    const onMonthChange = async (date: Date) => {
        setDisplayedMonth(date)
        await loadStaffDates(
            date.getFullYear(),
            date.getMonth(),
            cartState,
            cartStoreState?.location.tz
        )
        setRefresher(refresher + 1) //that forces the control to be refreshed and display available dates
    }

    const getAllowedDaysInMonth = (day: Date) => {
        if (staffDatesStore === undefined) {
            return []
        }
        return staffDatesStore
            .filter(
                (x) =>
                    x.month === day.getUTCMonth() &&
                    x.year === day.getUTCFullYear()
            )
            .flatMap((x) => x.dates)
    }

    const handleDayClick = async (day, modifiers: DayModifiers) => {
        if (modifiers.disabled) {
            return
        }
        const daysInMonth = getAllowedDaysInMonth(day)
        const selectedDays = daysInMonth.filter(
            (x) =>
                x.date.getUTCDate() === day.getUTCDate() &&
                x.date.getUTCMonth() === day.getUTCMonth() &&
                x.date.getUTCFullYear() == day.getUTCFullYear()
        )
        if (selectedDays.length === 0) {
            return
        }

        onDayClick(day, selectedDays[0].cartBookableDate)
    }

    const isDisabled = (day: Date) => {
        if (day < fromMonth) {
            return true
        }
        const daysInMonth = getAllowedDaysInMonth(day)
        const hasDay = daysInMonth.filter(
            (x) => x.date.getUTCDate() === day.getUTCDate()
        )
        return hasDay.length === 0
    }

    const renderDay = (day: Date, modifiers: any) => {
        let dayClassName = classes.calendarDayCell
        let dateWrapperClassName = classes.dateWrapper
        if (day < fromMonth && modifiers?.disabled) {
            dayClassName += ` ${classes.disabled}`
        }
        if (day > fromMonth && modifiers?.disabled) {
            dayClassName += ` ${classes.notAvailable}`
        }
        if (modifiers?.today) {
            dateWrapperClassName += ` ${classes.today}`
        }
        if (modifiers?.selected) {
            dateWrapperClassName += ` ${classes.selected}`
        }

        return (
            <div className={dayClassName}>
                <div className={classes.calendarDayDate}>
                    <div className={dateWrapperClassName}>{day.getDate()}</div>
                </div>
            </div>
        )
    }
    return (
        <Box className={classes.dayPickerWrapper}>
            <DayPicker
                month={displayedMonth}
                className={classes.calendarDayPicker}
                fromMonth={new Date()}
                selectedDays={filteredDate}
                weekdaysShort={weekdaysShort}
                disabledDays={isDisabled}
                onMonthChange={onMonthChange}
                onDayClick={handleDayClick}
                renderDay={renderDay}
            />
        </Box>
    )
}
</file>

<file path="components/molecules/Services/ChooseDate/SelectedTime.tsx">
import { Button } from '@mui/material'
import { Checked } from 'components/icons/Checked'
import { theme } from 'styles/theme'
import formatDateFns from 'lib/utils/formatDateFns'
import { useSelectedStaffTimeState } from 'lib/state/staffTime'
import { Store } from 'lib/state/store/types'

interface Props {
    store: Store | undefined
}

export const SelectedTime = ({ store }: Props) => {
    const selectedStaffTime = useSelectedStaffTimeState()

    return (
        <Button
            variant="text"
            color="secondary"
            startIcon={<Checked color={theme.palette.primary.main} />}
            sx={{
                width: 'auto',
                padding: theme.spacing(0, 2),
                marginRight: '8px',
                marginTop: '-3px',
            }}
        >
            {formatDateFns(
                selectedStaffTime?.locationTime,
                store?.location.tz,
                'h:mmaaa'
            )}
        </Button>
    )
}
</file>

<file path="components/molecules/Services/ChooseDate/ServerError.tsx">
import { useErrorMessage } from 'lib/state/error'
import { ErrorType } from 'lib/state/error/enums'
import React, { useContext, useEffect } from 'react'
import { LayoutContext } from 'components/atoms/layout/LayoutContext'

export const ServerError = () => {
    const errorMessage = useErrorMessage()
    const layout = useContext(LayoutContext)
    useEffect(() => {
        layout.setIsBlurScreen(errorMessage !== ErrorType.NoError)
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [errorMessage])
    return <>{errorMessage !== ErrorType.NoError && <ServerError />}</>
}
</file>

<file path="components/molecules/Services/ChooseDate/Time.tsx">
import React, { useContext } from 'react'
import { Button } from '@mui/material'
import { makeStyles } from '@mui/styles'
import { StaffTime } from 'lib/state/staffTime/types'
import formatDateFns, { TimeFormat } from 'lib/utils/formatDateFns'
import { Store } from 'lib/state/store/types'
import { useSetSelectedStaffTimeState } from 'lib/state/staffTime'
import { LayoutContext } from 'components/atoms/layout/LayoutContext'

const useStyles = makeStyles(() => ({
    selectTimeBtn: {
        width: 68,
        height: 32,
        fontWeight: 500,
        textTransform: 'lowercase',
    },
}))

interface Props {
    time: StaffTime
    store: Store | undefined
}

export const Time = ({ time, store }: Props) => {
    const classes = useStyles()
    const setSelectedStaffTimeState = useSetSelectedStaffTimeState()
    const layout = useContext(LayoutContext)

    const onSelectTime = async () => {
        setSelectedStaffTimeState(time)
        layout.setShowBottom(true)
    }

    return (
        <Button
            key={'time' + time.cartBookableTime?.id}
            variant="contained"
            className={classes.selectTimeBtn}
            sx={{
                mr: 1,
                mb: 1,
            }}
            onClick={onSelectTime}
        >
            {formatDateFns(time.locationTime, store?.location.tz, TimeFormat)}
        </Button>
    )
}
</file>

<file path="components/molecules/Services/ChooseDate/WorkshopPanel.tsx">
import { useContext, useEffect } from 'react'
import { LayoutContext } from 'components/atoms/layout/LayoutContext'
import { useSelectedStaffTimeState } from 'lib/state/staffTime'
import { Step } from 'lib/state/booking-flow/types'
import { ErrorType } from 'lib/state/error/enums'
import { useCartMethods, useCartState } from 'lib/state/cart'
import { useErrorMessageType } from 'lib/state/error'
import { useCartStoreState } from 'lib/state/store'
import { useFlowStep } from 'lib/state/booking-flow'

export const WorkshopPanel = () => {
    const selectedStaffTime = useSelectedStaffTimeState()
    const layout = useContext(LayoutContext)
    const { reserveBookableTime } = useCartMethods()
    const [, setErrorMessageType] = useErrorMessageType()
    const cartStoreState = useCartStoreState()
    const cart = useCartState()
    const { setStep } = useFlowStep()

    const onReserveBookableTime = async () => {
        layout.setIsShowLoader(true)
        try {
            await reserveBookableTime(
                cart,
                selectedStaffTime?.cartBookableTime,
                cartStoreState
            )
            await setStep(Step.PersonalInfo)
        } catch (e) {
            layout.setIsShowLoader(false)
            if ((e as Error).message.indexOf('CART_TIME_NOT_AVAILABLE') >= 0) {
                setErrorMessageType(ErrorType.TimeIsNoLongerAvailable)
            } else {
                setErrorMessageType(ErrorType.SomethingWentWrong)
            }
        } finally {
            layout.setIsShowLoader(false)
        }
    }


    useEffect(() => {
        layout.setShowBottom(selectedStaffTime !== undefined)
        // eslint-disable-next-line
    }, [])

    useEffect(() => {
        layout.setOnRightPanelBtnClick(async () => {
            await onReserveBookableTime()
        })
        // eslint-disable-next-line
    }, [selectedStaffTime])
    return <></>
}
</file>

<file path="components/molecules/Services/ChooseLocation/ChooseLocationScreen.tsx">
import { RightPanel } from 'components/molecules/Services/ChooseLocation/RightPanel'
import { LeftPanel } from 'components/molecules/Services/ChooseLocation/LeftPanel'
import WithLayout from 'components/atoms/layout/WithLayout'

export default function ChooseLocationScreen() {
    return (
        <WithLayout
            isShowLoader={false}
            leftPanel={<LeftPanel/>}
            rightPanel={<RightPanel />}
        />
    )
}
</file>

<file path="components/molecules/Services/ChooseLocation/LeftPanel.tsx">
import { Box, Typography } from '@mui/material'
import { DefineLocationFactory } from 'components/molecules/DefineLocation/DefineLocationFactory'
import { colors } from 'constants/colors'
import { MapFactory } from 'components/molecules/Map/MapFactory'
import { StoreList } from 'components/molecules/Services/ChooseLocation/StoreList'
import { useMobile } from 'lib/utils/useMobile'
import { useIsShowMap } from 'lib/state/location'
import { useLeftPanel } from 'components/molecules/Services/ChooseLocation/useLeftPanel'
import { GetLocation } from 'components/molecules/GeoLocation'
import { useLeftPanelStyles } from 'components/molecules/Services/ChooseLocation/useStyles'
import Font from 'config/fonts.json'
import { useAppConfig } from 'lib/state/config'

export const LeftPanel = () => {
    const { isMobile } = useMobile()
    const {onSelected, stores, orderStores, onUserLocationChange} = useLeftPanel()
    const [isShowMap] = useIsShowMap()
    const { isMapAvailable } = useAppConfig()
    const displaySearch = isMapAvailable()
    const classes = useLeftPanelStyles({ displaySearch })
    return (
        <Box className={classes.locationBlock}>
            <GetLocation onUserLocationChange={onUserLocationChange} />
            <Box
                className={`${
                    isMobile ? classes.mobileSearchBlock : classes.searchBlock
                }`}
            >
                <Typography
                    variant="h2"
                    component="span"
                    fontFamily={Font.headings_family}
                >
                    Select a store location
                </Typography>
                <Box sx={{ mt: 1 }}>
                    <DefineLocationFactory onSelected={onSelected} />
                </Box>
            </Box>
            {isMobile && isShowMap && (
                <Box
                    sx={{
                        marginTop: '107px',
                        height: '260px',
                        backgroundColor: colors.map.backgroundColor,
                    }}
                >
                    <MapFactory stores={stores} handleUpdate={isMobile} />
                </Box>
            )}
            <Box
                sx={{
                    height: !isMobile ? 'calc(100% - 108px)' : 'auto',
                    marginTop: isMobile && !isShowMap ? (displaySearch ? '107px' : '67px') : 'auto',
                }}
            >
                <StoreList stores={orderStores} />
            </Box>
        </Box>
    )
}
</file>

<file path="components/molecules/Services/ChooseLocation/LocationDistance.tsx">
import { Typography } from '@mui/material'
import { useIsLocationAccessAllowed } from 'lib/state/currentPosition'
import { Store } from 'lib/state/store/types'

interface Props {
    store: Store | undefined
}

export const LocationDistance = ({ store }: Props) => {
    const isLocationAccessAllowed = useIsLocationAccessAllowed()
    return (
        <>
            {isLocationAccessAllowed && (
                <Typography
                    variant="body1"
                    component="span"
                    sx={{ pl: 1 }}
                >{`${store?.distance} mi`}</Typography>
            )}
        </>
    )
}
</file>

<file path="components/molecules/Services/ChooseLocation/RightPanel.tsx">
import React from 'react'
import { MapFactory } from 'components/molecules/Map/MapFactory'
import { useMobile } from 'lib/utils/useMobile'
import { useStores } from 'lib/sdk/hooks/useStores'

export const RightPanel = () => {
    const { isMobile } = useMobile()
    const { stores } = useStores()
    if (isMobile) {
        return <></>
    }
    return <MapFactory stores={stores} handleUpdate={!isMobile} />
}
</file>

<file path="components/molecules/Services/ChooseLocation/SelectStore.tsx">
import { Typography, Box, Button } from '@mui/material'
import { Store } from 'lib/state/store/types'
import { Step } from 'lib/state/booking-flow/types'
import {
    getAddress,
    getLocationName,
    limitedMapBoxFlyToInterpolator,
} from 'lib/utils/locationUtils'
import { useCartMethods, useCartState } from 'lib/state/cart'
import { useFlowStep } from 'lib/state/booking-flow'
import {
    useLocationSelectedStoreState,
    useMapView,
    useSetMapViewportState,
    useSetUpdateStoresViewportState,
} from 'lib/state/location'
import { useMobile } from 'lib/utils/useMobile'
import { LocationDistance } from 'components/molecules/Services/ChooseLocation/LocationDistance'
import { LayoutListItem } from 'components/atoms/layout/LayoutListItem'
import { FlowType, useAppConfig } from 'lib/state/config'
import { useCartStoreState } from 'lib/state/store'
import { useIsShowMap } from 'lib/state/location'
import {
    useLastSelectedBookableItem,
    useResetLastSelectedBookableItem,
    useSelectedServices,
} from 'lib/state/services'
import { useContext } from 'react'
import { LayoutContext } from 'components/atoms/layout/LayoutContext'

interface Props {
    store: Store | undefined
}

export const SelectStore = ({ store }: Props) => {
    const { isMobile } = useMobile()
    const [isShowMap] = useIsShowMap()
    const { createCart, setCartLocation, loadSelectedServices } =
        useCartMethods()
    const { setStep } = useFlowStep()
    const setMapViewportState = useSetMapViewportState()
    const { getMapViewportState } = useMapView()
    const setUpdateStoresState = useSetUpdateStoresViewportState()
    const [locationSelectedStore, setLocationSelectedStore] =
        useLocationSelectedStoreState()
    const { getFlowType } = useAppConfig()
    const flowType = getFlowType()
    const cart = useCartState()
    const cartStore = useCartStoreState()
    const { selectedServicesStateValue, loadSelectedServicesFromCart } = useSelectedServices()
    const lastSelectedBookableItem = useLastSelectedBookableItem()
    const resetLastSelectedBookableItem = useResetLastSelectedBookableItem()
    const layout = useContext(LayoutContext)

    const continueSelectLocationFirst = async () => {
        const location = store?.location
        const cart = await createCart(location, store)
        await loadSelectedServicesFromCart(cart, [])
        await setStep(Step.SelectService)
    }

    const continueSelectServiceFirst = async () => {
        if (!cart || !store) {
            return
        }
        const selectedServices = await setCartLocation(
            cart,
            store,
            cartStore,
            lastSelectedBookableItem,
            selectedServicesStateValue
        )
        await loadSelectedServices(cart, selectedServices)
        resetLastSelectedBookableItem()
        await setStep(Step.SelectedServices)
    }

    const onContinue = async () => {
        layout.setIsShowLoader(true)
        if (store?.location === undefined) {
            return
        }

        try {
            if (flowType === FlowType.SelectLocationFirst) {
                await continueSelectLocationFirst()
            } else {
                await continueSelectServiceFirst()
            }
        } catch {
            layout.setIsShowLoader(false)
        }
    }

    const onSelect = async () => {
        if (!isMobile || isShowMap) {
            const viewport = getMapViewportState()
            let zoom = 8
            if (viewport) {
                zoom =
                    isNaN(viewport?.zoom) || viewport.zoom < zoom
                        ? zoom
                        : viewport.zoom
            }
            const currentViewport = {
                ...viewport,
                longitude: store?.lng!,
                latitude: store?.lat!,
                transitionDuration: 'auto',
                transitionInterpolator: limitedMapBoxFlyToInterpolator,
                zoom: zoom,
            }

            setLocationSelectedStore(store)
            setMapViewportState(currentViewport)
            setUpdateStoresState(currentViewport)

            if (isMobile) {
                window.scrollTo({
                    top: 0,
                    left: 0,
                    behavior: 'smooth',
                })
            }
        }
    }

    const storeSelected =
        locationSelectedStore?.location?.id === store?.location?.id

    return (
        <LayoutListItem
            id={store?.location.id}
            selected={!isMobile || isShowMap ? storeSelected : undefined}
            onClick={onSelect}
            useDefaultCursor={isMobile && !isShowMap}
        >
            <Box
                display="flex"
                flexDirection="column"
                justifyContent="space-between"
                alignItems="flex-start"
            >
                <Box>
                    <Typography variant="h3" component="span">
                        {getLocationName(store)}
                    </Typography>
                    <LocationDistance store={store} />
                </Box>
                <Box sx={{ pt: 1 }}>
                    <Typography variant="body2">{getAddress(store)}</Typography>
                </Box>
            </Box>

            <Button
                variant="contained"
                sx={{
                    width: 125,
                    height: 38,
                    mt: 2,
                    fontSize: '16px',
                    fontWeight: 500,
                    textTransform: 'capitalize',
                }}
                onClick={onContinue}
            >
                Select Store
            </Button>
        </LayoutListItem>
    )
}
</file>

<file path="components/molecules/Services/ChooseLocation/StoreList.tsx">
import React from 'react'
import { Store } from 'lib/state/store/types'
import { SelectStore } from 'components/molecules/Services/ChooseLocation/SelectStore'
import BounceLoader from 'react-spinners/BounceLoader'
import { Box } from '@mui/material'
import { useMobile } from 'lib/utils/useMobile'
import { useIsLocationAccessAnsweredByUser } from 'lib/state/currentPosition'
import { useStoreListStyles } from 'components/molecules/Services/ChooseLocation/useStyles'

interface Props {
    stores: Store[]
}

export const StoreList = ({ stores }: Props) => {
    const { isMobile } = useMobile()
    const isLocationAccessAnsweredByUser = useIsLocationAccessAnsweredByUser()
    const classes = useStoreListStyles({ isMobile, isLocationAccessAnsweredByUser })

    return (
        <Box className={classes.selectStoresBlock}>
            {isLocationAccessAnsweredByUser &&
                stores.map((store) => (
                    <SelectStore key={store.location.id} store={store} />
                ))}
            {!isLocationAccessAnsweredByUser && (
                <Box
                    sx={{
                        position: 'absolute',
                        left: 'calc(50% - 30px)',
                        top: 'calc(50% - 30px)',
                    }}
                >
                    <BounceLoader color="#dadada" size={60} />
                </Box>
            )}
        </Box>
    )
}
</file>

<file path="components/molecules/Services/ChooseLocation/useLeftPanel.ts">
import { useMobile } from 'lib/utils/useMobile'
import { useIsShowMap, useLocationSelectedStoreState, useMapView, useSetMapViewportState } from 'lib/state/location'
import { useStores } from 'lib/sdk/hooks/useStores'
import { useCartStoreState } from 'lib/state/store'
import { useEffect, useState } from 'react'
import { sortByDistance } from 'lib/utils/sortUtils'
import { PositionCoordinates } from 'lib/state/currentPosition/types'
import {
    defaultZoom,
    mapBoxFlyToInterpolator,
    mapBoxLongTransitionDuration,
    scrollMapToTop
} from 'lib/utils/locationUtils'
import { Store } from 'lib/state/store/types'

export const useLeftPanel = () => {
    const { isMobile } = useMobile()
    const [isShowMap] = useIsShowMap()
    const setViewport = useSetMapViewportState()
    const { getMapViewportState } = useMapView()
    const { stores, getDistanceByPosition } = useStores()
    const selectedStore = useCartStoreState()
    const [locationSelectedStore, setLocationSelectedStore] =
        useLocationSelectedStoreState()
    const [orderStores, setOrderStores] = useState(
        stores.concat().sort((a, b) => sortByDistance(a, b, undefined))
    )

    useEffect(() => {
        if (orderStores.length === 0) {
            setOrderStores(stores)
        }
        // eslint-disable-next-line
    }, [stores])

    useEffect(() => {
        if (isMobile) {
            setOrderStores(
                orderStores
                    .concat()
                    .sort((a, b) =>
                        sortByDistance(
                            a,
                            b,
                            isShowMap ? locationSelectedStore : undefined
                        )
                    )
            )
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [locationSelectedStore, isShowMap])

    const onUserLocationChange = (positionCoordinates: PositionCoordinates) => {
        if (
            locationSelectedStore?.location?.id !== selectedStore?.location?.id
        ) {
            setLocationSelectedStore(selectedStore)
        }
        if (selectedStore === undefined) {
            const viewport = getMapViewportState()
            const updatedViewPort = {
                ...viewport,
                ...{
                    longitude: positionCoordinates.longitude,
                    latitude: positionCoordinates.latitude,
                    zoom: defaultZoom,
                    transitionDuration: 0,
                },
            }
            updateStoreDistance(
                updatedViewPort.longitude,
                updatedViewPort.latitude
            )
            setViewport(updatedViewPort)
        }
    }

    const updateStoreDistance = (longitude, latitude): Store[] => {
        let updatedStores: Store[] = []
        setOrderStores((prevStores) => {
            updatedStores = prevStores
                .map((store: Store) => {
                    return {
                        ...store,
                        distance: getDistanceByPosition(
                            {
                                latitude,
                                longitude,
                            },
                            {
                                latitude:
                                    store.location.coordinates?.latitude ?? 0,
                                longitude:
                                    store.location.coordinates?.longitude ?? 0,
                            }
                        ),
                    }
                })
                .sort((a, b) => sortByDistance(a, b, locationSelectedStore))
            return updatedStores
        })
        return updatedStores
    }

    const onSelected = (viewport) => {
        scrollMapToTop()
        updateStoreDistance(viewport.longitude, viewport.latitude)
        setViewport({
            ...viewport,
            transitionDuration: mapBoxLongTransitionDuration,
            transitionInterpolator: mapBoxFlyToInterpolator,
        })
        setLocationSelectedStore(undefined)
    }

    return {
        onSelected: onSelected,
        orderStores: orderStores,
        stores: stores,
        onUserLocationChange: onUserLocationChange,
    }
}
</file>

<file path="components/molecules/Services/ChooseLocation/useStyles.ts">
import { makeStyles } from '@mui/styles'
import { Theme } from '@mui/material'
import { stepScreen } from 'constants/styles'

interface LeftStylesProps {
    displaySearch: boolean
}

export const useLeftPanelStyles = makeStyles((theme: Theme) => ({
    searchBlock: {
        height: (props: LeftStylesProps) => props.displaySearch ? '108px' : '56px',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        padding: theme.spacing(0, 2),
        borderBottom: `1px solid ${theme.palette.custom.lightGray}`,
    },
    mobileSearchBlock: {
        position: 'fixed',
        top: '46px',
        padding: theme.spacing(2),
        width: '100%',
        'z-index': '1000',
        backgroundColor: '#ffffff',
        borderBottom: `1px solid ${theme.palette.custom.lightGray}`,
    },
    hiddenSearchBlock: {
        maxHeight: 0,
        opacity: 0,
    },
    locationBlock: {
        height: '100%',
        maxHeight: '100%',
        opacity: 1,
    },
}))

interface StylesProps {
    isMobile: boolean
    isLocationAccessAnsweredByUser: boolean
}
export const useStoreListStyles = makeStyles((theme: Theme) => ({
    loader: stepScreen(theme).loader,
    selectStoresBlock: {
        position: 'sticky',
        overflowY: 'scroll',
        height: (props: StylesProps) =>
            props.isMobile
                ? props.isLocationAccessAnsweredByUser
                    ? 'auto'
                    : 'calc(100% - 411px)'
                : '100%',
        '&::-webkit-scrollbar': {
            display: 'none',
        },
    },
}))
</file>

<file path="components/molecules/Services/ChooseStaff/SelectedButton.tsx">
import { Box, Typography } from '@mui/material'
import { colors } from 'constants/colors'
import React from 'react'
import { useSelectedButton } from 'components/molecules/Services/ChooseStaff/useStyles'
import { Checked } from 'components/icons/Checked'
import { useMobile } from 'lib/utils/useMobile'

export const SelectedButton = () => {
    const { isMobile } = useMobile()
    const classes = useSelectedButton({ isMobile })
    return (
        <Box className={classes.selectedWrapper}>
            <Box className={classes.svgWrapper}>
                <Box className={classes.btn}>
                    <Checked color={colors.primary.main} />
                </Box>
            </Box>
            <Typography className={classes.selectedTxt}> Selected </Typography>
        </Box>
    )
}
</file>

<file path="components/molecules/Services/ChooseStaff/Staff.tsx">
import {
    CartBookableItemStaff,
    Staff as StaffType,
} from 'lib/state/staff/types'
import { Box } from '@mui/material'
import { useStaffStyles } from 'components/molecules/Services/ChooseStaff/useStyles'
import clsx from 'clsx'
import {
    useCartBookableItemListStaff,
    useSetCartBookableItemListStaff,
} from 'lib/state/staff'
import {
    useActiveSelectedService,
    useSelectedServices,
} from 'lib/state/services'
import { useCartMethods, useCartState } from 'lib/state/cart'
import React, { useContext } from 'react'
import { LayoutContext } from 'components/atoms/layout/LayoutContext'
import { LayoutListItem } from 'components/atoms/layout/LayoutListItem'
import { SelectableListBtn } from 'components/atoms/layout/selectable-list-item/SelectableListBtn'
import { SelectedButton } from 'components/molecules/Services/ChooseStaff/SelectedButton'
import { useMobile } from 'lib/utils/useMobile'

interface Props {
    staff: StaffType
}
export const Staff = ({ staff }: Props) => {
    const { isMobile } = useMobile()
    const classes = useStaffStyles()
    const activeSelectedService = useActiveSelectedService()
    const setCartBookableItemListStaff = useSetCartBookableItemListStaff()
    const { selectStaff, isCartAvailableBookableItem } = useCartMethods()
    const cart = useCartState()
    const cartBookableItemListStaff = useCartBookableItemListStaff()
    const selectedStaff = cartBookableItemListStaff?.find(
        (s) => s.cartBookableItemId === activeSelectedService?.id
    )?.staff
    const layout = useContext(LayoutContext)
    const { selectedServicesStateValue } = useSelectedServices()

    const onSelectClick = async () => {
        const service = selectedServicesStateValue.find(
            (x) => x.id === activeSelectedService?.id
        )
        if (
            activeSelectedService === undefined ||
            cart === undefined ||
            service === undefined
        ) {
            return
        }
        let newCartBookableItemListStaff: CartBookableItemStaff[] | undefined
        setCartBookableItemListStaff((oldValue) => {
            newCartBookableItemListStaff = oldValue
                ? [
                      ...oldValue.filter(
                          (s) =>
                              s.cartBookableItemId !== activeSelectedService.id
                      ),
                  ]
                : []
            newCartBookableItemListStaff.push({
                cartBookableItemId: activeSelectedService.id,
                staff: staff,
            })

            return newCartBookableItemListStaff
        })
        const isAllStaffAssigned =
            selectedServicesStateValue
                .filter(x=>isCartAvailableBookableItem(x.item))
                .map((x) =>
                    newCartBookableItemListStaff?.find(
                        (s) => s.cartBookableItemId === x.id
                    )
                )
                .filter((x) => x === undefined).length === 0
        layout.setShowBottom(isAllStaffAssigned)
        layout.setShowLeftBottom(isAllStaffAssigned)
        await selectStaff(cart, service, staff)
    }

    const isSelectedStaffState = selectedStaff?.id === staff.id

    return (
        <LayoutListItem
            useDefaultCursor={true}
            sx={{
                paddingTop: '19px!important',
                paddingBottom: '16px!important',
                paddingLeft: '24px!important',
            }}
        >
            <Box className={classes.row}>
                {staff.avatar && (
                    <Box
                        className={clsx(classes.staffBoxAvatar)}
                        sx={{ backgroundImage: `url(${staff.avatar})` }}
                    />
                )}
                {!staff.avatar && !staff.id && (
                    <Box
                        className={clsx(
                            classes.staffBoxAvatar,
                            classes.staffBoxAvatarEmpty
                        )}
                    >
                        N
                    </Box>
                )}
                <Box className={classes.staffTextBlock}>
                    <Box
                        className={clsx(
                            classes.staffTextItem,
                            classes.staffName
                        )}
                    >
                        {staff.name}
                    </Box>
                    {staff.id && (
                        <Box className={classes.staffTextItem}>
                            {staff.name}
                        </Box>
                    )}
                </Box>

                {!isSelectedStaffState && (
                    <SelectableListBtn
                        btnWidth={78}
                        btnName="Select"
                        onSelectClick={onSelectClick}
                        btnTop={'0px'}
                        sxWrapper={{
                            marginLeft: isMobile ? 'auto!important' : undefined,
                            marginRight: isMobile
                                ? '16px!important'
                                : undefined,
                            display: isMobile ? 'flex' : undefined,
                            flexDirection: isMobile ? 'column' : undefined,
                        }}
                        sxButton={{
                            marginTop: isMobile ? 'auto!important' : undefined,
                            marginBottom: isMobile
                                ? 'auto!important'
                                : undefined,
                        }}
                    />
                )}
                {isSelectedStaffState && <SelectedButton />}
            </Box>
        </LayoutListItem>
    )
}
</file>

<file path="components/molecules/Services/ChooseStaff/StaffsList.tsx">
import { Staff } from 'components/molecules/Services/ChooseStaff/Staff'
import { useBookableStaffVariants } from 'lib/state/staff'
import { Box, Typography } from '@mui/material'
import { useStaffListStyles } from 'components/molecules/Services/ChooseStaff/useStyles'
import { useCartMethods } from 'lib/state/cart'
import { useActiveSelectedService } from 'lib/state/services'

export const StaffsList = () => {
    const classes = useStaffListStyles()
    const activeSelectedService = useActiveSelectedService()
    const {isCartAvailableBookableItem} = useCartMethods()
    let staffs = useBookableStaffVariants()

    if (staffs && isCartAvailableBookableItem(activeSelectedService?.item)) {
        let staffsWithNoPreference = staffs.concat()
        staffsWithNoPreference.unshift({
            id: null,
            name: 'No Preference',
            description: 'Match with any staff member',
        })
        staffs = staffsWithNoPreference
    }

    const hasStaff = staffs && staffs.length > 0

    return (
        <Box className={classes.root}>
            {staffs?.map((staff) => (
                <Staff key={staff.id} staff={staff} />
            ))}
            {!hasStaff && <Box className={classes.noOptionsAvailableWrapper}>
                <Typography>
                    No options available
                </Typography>
            </Box>}
        </Box>
    )
}
</file>

<file path="components/molecules/Services/ChooseStaff/useStyles.ts">
import { makeStyles } from '@mui/styles'
import { colors } from 'constants/colors'

interface StylesProps {
    isMobile: boolean
}

export const useStaffStyles = makeStyles(() => ({
    row: {
        display: 'flex',
        flexDirection: 'row',
    },
    staffTextBlock: {
        display: 'flex',
        flexDirection: 'column',
        marginLeft: '26px',
    },
    staffTextItem: {
        marginTop: 'auto',
        marginBottom: 'auto',
    },
    staffName: {
        fontWeight: 700,
        fontSize: '16px',
    },
    root: {
        margin: '5px 10px 5px 0px',
        textAlign: 'center',
        width: '185px',
        border: '1px solid #dcedc8',
        padding: '15px 10px 16px 10px',
    },
    selected: {
        border: '1px solid #40c4ff',
    },
    staffBoxAvatar: {
        backgroundColor: colors.primary.main + '4C',
        backgroundSize: '100%',
        borderRadius: '50%',
        display: 'inline-block',
        height: '80px',
        width: '80px',
        lineHeight: '80px',
        fontSize: '20px',
        fontWeight: 'bold',
    },
    staffBoxAvatarEmpty: {
        textAlign: 'center',
        fontSize: '30px',
        color: '#FFFFFF',
    },
    staffDescBlock: {
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'right',
        height: '85px',
        padding: '5px 0px 0px 0',
    },
    staffNameTextBlock: {
        fontWeight: 500,
        fontSize: '15px',
        color: '#000000',
        height: '25px',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        display: '-webkit-box',
        '-webkit-line-clamp': '2',
        '-webkit-box-orient': 'vertical',
    },
    staffDescText: {
        marginTop: '0px',
        fontSize: '13px',
        color: '#737373',
        height: '50px',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        display: '-webkit-box',
        '-webkit-line-clamp': '2',
        '-webkit-box-orient': 'vertical',
    },
}))

export const useStaffListStyles = makeStyles(() => ({
    root: {
        overflowY: 'scroll',
        position: 'sticky',
        height: 'calc(100% - 57px)',
        '&::-webkit-scrollbar': {
            display: 'none',
        },
    },
    titleText: {
        fontWeight: 'bold',
        fontSize: '19px',
    },
    selectedItemText: {
        fontSize: '17px',
        paddingLeft: '8px',
    },
    staffBlock: {
        display: 'flex',
        flexDirection: 'row',
        flexWrap: 'wrap',
        justifyContent: 'flex-start',
        alignItems: 'flex-start',
        paddingTop: '5px',
        paddingBottom: '74px',
    },
    bottomBtn: {
        width: '200px',
        height: '40px',
        fontSize: '16px',
        fontWeight: 500,
        textTransform: 'capitalize',
        marginTop: '10px',
        marginRight: '10px',
    },
    noOptionsAvailableWrapper: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        marginTop: '15%',
    },
}))

export const useSelectedButton = makeStyles(() => ({
    selectedWrapper: {
        marginLeft: 'auto',
        marginRight: (props: StylesProps) => (props.isMobile ? '16px' : '32px'),
        marginTop: '32px',
        display: 'flex',
        flexDirection: 'row',
    },
    selectedTxt: {
        fontWeight: 700,
        fontSize: '14px',
        marginLeft: '15px',
        color: '#000000',
    },

    svgWrapper: {
        marginTop: '-3px',
    },

    btn: {
        cursor: 'pointer',
    },
}))
</file>

<file path="components/molecules/Services/PayAndConfirm/ts/constants.ts">
export const cardHoldersNameFieldName = 'cardHoldersName'
export const cardNumberFieldName = 'cardNumber'
export const expirationDateFieldName = 'expirationDate'
export const cvcFieldName = 'cvc'
export const addressPostalCodeFieldName = 'addressPostalCode'
</file>

<file path="components/molecules/Services/PayAndConfirm/ts/types.ts">
export interface Card {
    name: string
    number: string
    cvv: string
    exp_month: number
    exp_year: number
    address_postal_code: string
}
</file>

<file path="components/molecules/Services/PayAndConfirm/ts/useButtons.ts">
import { useContext } from 'react'
import { FormikValues } from 'formik'
import { Step } from 'lib/state/booking-flow/types'
import {
    useCartState,
    useSetCartIdState,
    useSetCartState,
    useSetSuccessBookingCartInfoState,
} from 'lib/state/cart'
import { useFlowStep } from 'lib/state/booking-flow'
import { useSetBookingAnswersState } from 'lib/state/booking-answers'
import { useCartStoreState, useSetCartStoreState } from 'lib/state/store'
import { useErrorMessageType } from 'lib/state/error'
import { ErrorType } from 'lib/state/error/enums'
import { LayoutContext } from 'components/atoms/layout/LayoutContext'
import { Blvd } from 'lib/sdk/blvd'
import { Card } from './types'

export const useButtons = () => {
    const { setStep } = useFlowStep()
    const cart = useCartState()
    const setBookingAnswers = useSetBookingAnswersState()
    const setCart = useSetCartState()
    const setCartIdState = useSetCartIdState()
    const setCartStore = useSetCartStoreState()
    const [, setErrorMessageType] = useErrorMessageType()
    const layout = useContext(LayoutContext)
    const cartStoreState = useCartStoreState()
    const setSuccessBookingCartInfoState = useSetSuccessBookingCartInfoState()

    const getFormatedCardHoldersName = (cardHoldersName: string) => {
        return cardHoldersName.toUpperCase()
    }
    const getFormatedCardNumber = (cardNumber: string) => {
        return cardNumber.replace(/\s+/g, '')
    }
    const getExpirationMonth = (expirationDate: string) => {
        return Number(expirationDate.substring(0, 2))
    }
    const getExpirationYear = (expirationDate: string) => {
        return Number(expirationDate.substring(3, 5))
    }

    const getAddressPostalCode = (addressPostalCode: string) => {
        return addressPostalCode.trim()
    }

    const onContinue = async (values: FormikValues) => {
        layout.setIsShowLoader(true)

        try {
            if (!cart) throw new Error('cart is missing, but required')

            layout.setIsShowLoader(true)
            let icsLink: string = ''
            try {
                const card: Card = {
                    name: getFormatedCardHoldersName(values.cardHoldersName),
                    number: getFormatedCardNumber(values.cardNumber),
                    cvv: values.cvc,
                    exp_month: getExpirationMonth(values.expirationDate),
                    exp_year: getExpirationYear(values.expirationDate),
                    address_postal_code: getAddressPostalCode(
                        values.addressPostalCode
                    ),
                }

                await cart.addCardPaymentMethod({ card })
                const checkoutCartPayload = await cart.checkout()
                if (
                    checkoutCartPayload?.appointments &&
                    checkoutCartPayload?.appointments?.length > 0
                ) {
                    const appointmentId =
                        checkoutCartPayload?.appointments[0].appointmentId
                    const appointment = await Blvd.appointments.getFromCart(
                        appointmentId,
                        cart.id
                    )
                    icsLink = appointment?.calendarLinks?.icsDownload
                }
            } catch (e) {
                if (
                    (e as Error).message.indexOf('CART_TIME_NOT_AVAILABLE') >= 0
                ) {
                    setErrorMessageType(ErrorType.TimeIsNoLongerAvailable)
                } else {
                    setErrorMessageType(ErrorType.SomethingWentWrong)
                }
                return
            } finally {
                layout.setIsShowLoader(false)
            }

            await setSuccessBookingCartInfoState({
                total: cart?.summary.total,
                startTime: cart?.startTime,
                endTime: cart?.endTime,
                store: cartStoreState!,
                icsLink: icsLink,
            })

            setBookingAnswers([])
            setCartStore(undefined)
            setCartIdState(undefined)
            setCart(undefined) //set cart to undefined after saving all data
            setErrorMessageType(ErrorType.NoError)
            await setStep(Step.BookingSuccess)
        } catch {
            layout.setIsShowLoader(false)
        }
    }

    const onMoveBack = async () => {
        await setStep(Step.PersonalInfo)
    }

    return {
        onContinue: onContinue,
        onMoveBack: onMoveBack,
        isFormSubmitting: layout.isShowLoader,
    }
}
</file>

<file path="components/molecules/Services/PayAndConfirm/BLVDLogo.tsx">
import { Typography, Box } from '@mui/material'
import { useMobile } from 'lib/utils/useMobile'
const blvdLogo = '/images/blvd_logo.png'

export const BLVDLogo = () => {
    const { isMobile } = useMobile()

    return (
        <Box
            sx={{
                width: !isMobile ? '200px' : '100%',
                display: 'flex',
                flexDirection: 'row',
                justifyContent: !isMobile ? 'flex-start': 'center',
                alignItems: 'center',
                '& img': {
                    width: '105px',
                    height: '15px',
                },
            }}
        >
            <Typography variant="h4" sx={{ pr: 1 }}>
                Powered by{' '}
            </Typography>
            {/* eslint-disable-next-line @next/next/no-img-element */}
            <img src={blvdLogo} alt="BOULEVARD" width={105} height={15} />
        </Box>
    )
}
</file>

<file path="components/molecules/Services/PayAndConfirm/CardHoldersName.tsx">
import { useFormikContext } from 'formik'
import TextFieldBase from 'components/atoms/formik/TextFieldBase'
import { cardHoldersNameFieldName } from '../PayAndConfirm/ts/constants'

export default function CardHoldersName() {
    const { errors, touched } = useFormikContext()

    return (
        <TextFieldBase
            id={cardHoldersNameFieldName}
            label="Card holder’s name"
            error={
                errors[cardHoldersNameFieldName] &&
                touched[cardHoldersNameFieldName]
            }
            helperText={
                errors[cardHoldersNameFieldName] &&
                touched[cardHoldersNameFieldName] &&
                errors[cardHoldersNameFieldName]
            }
            inputProps={{ sx: { textTransform: 'uppercase' } }}
        />
    )
}
</file>

<file path="components/molecules/Services/PayAndConfirm/CreditCardNumber.tsx">
import { forwardRef } from 'react'
import { useFormikContext } from 'formik'
import MaskedInput from 'react-text-mask'
import { cardNumberMask } from 'constants/regexps'
import TextFieldBase from 'components/atoms/formik/TextFieldBase'
import { cardNumberFieldName } from './ts/constants'

// eslint-disable-next-line react/display-name
const CardNumberMaskCustom = forwardRef((props, ref) => {
    return <MaskedInput {...props} placeholder="" mask={cardNumberMask} />
})

export default function CreditCardNumber() {
    const { errors, touched } = useFormikContext()

    return (
        <TextFieldBase
            id={cardNumberFieldName}
            label="Credit card number"
            InputProps={{
                inputComponent: CardNumberMaskCustom,
            }}
            error={errors[cardNumberFieldName] && touched[cardNumberFieldName]}
            helperText={
                errors[cardNumberFieldName] &&
                touched[cardNumberFieldName] &&
                errors[cardNumberFieldName]
            }
        />
    )
}
</file>

<file path="components/molecules/Services/PayAndConfirm/ExpirationCVCAndZipcode.tsx">
import { forwardRef } from 'react'
import { useFormikContext } from 'formik'
import { Grid } from '@mui/material'
import MaskedInput from 'react-text-mask'
import { cardExpirationDateMask, cvcMask } from 'constants/regexps'
import TextFieldBase from 'components/atoms/formik/TextFieldBase'
import {
    expirationDateFieldName,
    cvcFieldName,
    addressPostalCodeFieldName,
} from '../PayAndConfirm/ts/constants'

// eslint-disable-next-line react/display-name
const ExpirationDateMaskCustom = forwardRef((props, ref) => {
    return (
        <MaskedInput
            {...props}
            placeholder="  /  "
            mask={cardExpirationDateMask}
        />
    )
})

// eslint-disable-next-line react/display-name
const CVCMaskCustom = forwardRef((props, ref) => {
    return <MaskedInput {...props} placeholder="" mask={cvcMask} />
})

export default function ExpirationCVCAndZipcode() {
    const { errors, touched } = useFormikContext()

    return (
        <>
            <Grid item lg={2} md={5} sm={5} xs={6}>
                <TextFieldBase
                    id={expirationDateFieldName}
                    label="Expiration"
                    InputProps={{
                        inputComponent: ExpirationDateMaskCustom,
                    }}
                    error={
                        errors[expirationDateFieldName] &&
                        touched[expirationDateFieldName]
                    }
                    helperText={
                        errors[expirationDateFieldName] &&
                        touched[expirationDateFieldName] &&
                        errors[expirationDateFieldName]
                    }
                />
            </Grid>
            <Grid item lg={2} md={5} sm={5} xs={6}>
                <TextFieldBase
                    id={cvcFieldName}
                    label="CVC"
                    InputProps={{
                        inputComponent: CVCMaskCustom,
                    }}
                    error={errors[cvcFieldName] && touched[cvcFieldName]}
                    helperText={
                        errors[cvcFieldName] &&
                        touched[cvcFieldName] &&
                        errors[cvcFieldName]
                    }
                />
            </Grid>
            <Grid item lg={2} md={5} sm={5} xs={6}>
                <TextFieldBase
                    id={addressPostalCodeFieldName}
                    label="Postal Code"
                    error={
                        errors[addressPostalCodeFieldName] &&
                        touched[addressPostalCodeFieldName]
                    }
                    helperText={
                        errors[addressPostalCodeFieldName] &&
                        touched[addressPostalCodeFieldName] &&
                        errors[addressPostalCodeFieldName]
                    }
                />
            </Grid>
        </>
    )
}
</file>

<file path="components/molecules/Services/PayAndConfirm/PayAndConfirmScreen.tsx">
import WithLayout from 'components/atoms/layout/WithLayout'
import PaymentAndTerms from 'components/molecules/Services/PayAndConfirm/PaymentAndTerms'
import { Step } from 'lib/state/booking-flow/types'
import { useMobile } from 'lib/utils/useMobile'

export default function PayAndConfirmScreen() {
    const { isMobile } = useMobile()

    return (
        <WithLayout
            isShowLoader={false}
            leftPanel={<></>}
            rightPanel={<PaymentAndTerms />}
            rightPanelCaption="Confirm and pay"
            addBackArrow={isMobile}
            backArrowStep={Step.PersonalInfo}
        />
    )
}
</file>

<file path="components/molecules/Services/PayAndConfirm/PaymentAndTerms.tsx">
import React from 'react'
import { Formik } from 'formik'
import { Box, Button } from '@mui/material'
import { theme } from 'styles/theme'
import * as Yup from 'yup'
import valid from 'card-validator'
import { useButtons } from 'components/molecules/Services/PayAndConfirm/ts/useButtons'
import { usePaymentInformationState } from 'lib/state/payment-info'
import PaymentInfo from 'components/molecules/Services/PayAndConfirm/PaymentInfo'
import PaymentSummary from 'components/molecules/Services/PayAndConfirm/PaymentSummary'
import Terms from 'components/molecules/Services/PayAndConfirm/Terms'
import { BLVDLogo } from 'components/molecules/Services/PayAndConfirm/BLVDLogo'
import {
    cardHoldersNameFieldName,
    cardNumberFieldName,
    expirationDateFieldName,
} from './ts/constants'
import { useMobile } from 'lib/utils/useMobile'
import { Services } from 'components/atoms/layout/summary/Services'
import { useSelectedServices } from 'lib/state/services'
import { useCartMethods } from 'lib/state/cart'

export default function PaymentAndTerms() {
    const [paymentInformation] = usePaymentInformationState()
    const { onContinue, isFormSubmitting } = useButtons()
    const { isMobile } = useMobile()
    const { selectedServicesStateValue } = useSelectedServices()
    const { isCartAvailableBookableItem } = useCartMethods()
    const hasServices =
        selectedServicesStateValue.filter((x) =>
            isCartAvailableBookableItem(x.item)
        ).length > 0
    return (
        <Formik
            initialValues={{
                cardHoldersName: paymentInformation.cardHoldersName,
                cardNumber: paymentInformation.cardNumber,
                expirationDate: paymentInformation.expirationDate,
                cvc: '',
            }}
            validationSchema={Yup.object().shape({
                cardHoldersName: Yup.string()
                    .test(
                        cardHoldersNameFieldName,
                        'Card holder’s name is invalid',
                        (value) => valid.cardholderName(value).isValid
                    )
                    .required('Required'),
                cardNumber: Yup.string()
                    .test(
                        cardNumberFieldName,
                        'Credit Card number is invalid',
                        (value) => valid.number(value).isValid
                    )
                    .required('Required'),
                expirationDate: Yup.string()
                    .test(
                        expirationDateFieldName,
                        'Expiration date is invalid',
                        (value) => valid.expirationDate(value).isValid
                    )
                    .required('Required'),
                cvc: Yup.string().required('Required'),
                addressPostalCode: Yup.string().required('Required'),
            })}
            onSubmit={(values) => onContinue(values)}
            validateOnChange
        >
            {({ handleSubmit }) => (
                <Box
                    sx={{
                        padding: !isMobile
                            ? theme.spacing(5, 1, 5, 8)
                            : theme.spacing(0, 3, 3, 3),
                        height: '100%',
                        overflowY: 'scroll',
                        position: 'sticky',
                        '&::-webkit-scrollbar': {
                            display: 'none',
                        },
                    }}
                >
                    {isMobile && <Services />}
                    <PaymentSummary />
                    <PaymentInfo hasServices={hasServices} />
                    <Terms />
                    <Button
                        variant="contained"
                        onClick={() => handleSubmit()}
                        disabled={isFormSubmitting}
                        sx={{ mt: 3, mb: 4 }}
                    >
                        {hasServices ? 'Pay and Book' : 'Pay'}
                    </Button>
                    <BLVDLogo />
                </Box>
            )}
        </Formik>
    )
}
</file>

<file path="components/molecules/Services/PayAndConfirm/PaymentInfo.tsx">
import { Box, Typography, Grid } from '@mui/material'
import CardHoldersName from 'components/molecules/Services/PayAndConfirm/CardHoldersName'
import CreditCardNumber from 'components/molecules/Services/PayAndConfirm/CreditCardNumber'
import ExpirationCVCAndZipcode from 'components/molecules/Services/PayAndConfirm/ExpirationCVCAndZipcode'

interface Props {
    hasServices: boolean
}

export default function PaymentInfo({hasServices}: Props) {
    return (
        <Box>
            <Typography variant="h3" sx={{ pb: 1 }}>
                Payment info
            </Typography>
            {hasServices && <Typography sx={{ pb: 1 }}>
                Your card will not be charged until your appointment is completed.
            </Typography>}
            <Grid item lg={4} md={10} sm={10} xs={12}>
                <CardHoldersName />
            </Grid>
            <Grid item lg={4} md={10} sm={10} xs={12}>
                <CreditCardNumber />
            </Grid>
            <ExpirationCVCAndZipcode />
        </Box>
    )
}
</file>

<file path="components/molecules/Services/PayAndConfirm/PaymentSummary.tsx">
import React from 'react'
import { Box, Theme, Typography } from '@mui/material'
import { usePersonalInformationState } from 'lib/state/personal-info'
import { useMobile } from 'lib/utils/useMobile'
import { PaymentSummaryControl } from 'components/molecules/PaymentSummaryControl'
import { makeStyles } from '@mui/styles'
import { useSelectedServices } from 'lib/state/services'
import { useCartMethods } from 'lib/state/cart'
interface StylesProps {
    isMobile: boolean
}

export const useStyles = makeStyles((theme: Theme) => ({
    summaryBlock: {
        width: '100%',
        maxWidth: (props: StylesProps) => (!props.isMobile ? '458px' : '100%'),
        background: 'rgba(255, 255, 255, 0.05)',
        padding: (props: StylesProps) => (!props.isMobile ? theme.spacing(3) : 0),
        marginLeft: (props: StylesProps) => (!props.isMobile ? theme.spacing(-3) : 0),
        border: (props: StylesProps) => (!props.isMobile ? '1px solid #C4C4C4' : 'none'),
        borderRadius: '8px',
        boxShadow: (props: StylesProps) => (!props.isMobile ? '4px 4px 4px rgba(0, 0, 0, 0.1)' : 'none'),
        '& .MuiTypography-root': {
            fontWeight: 500,
        },
    },
}))

export default function PaymentSummary() {
    const { isMobile } = useMobile()
    const [personalInformation] = usePersonalInformationState()
    const classes = useStyles({ isMobile })
    const { selectedServicesStateValue } = useSelectedServices()
    const { isCartAvailablePurchasableItem } = useCartMethods()
    const hasProducts = selectedServicesStateValue.filter(x=>isCartAvailablePurchasableItem(x.item)).length > 0
    const appointmentOrderText = hasProducts ? 'Order' : 'Appointment'
    return (
        <Box sx={{ pt: isMobile ? 5 : 0, pb: 5 }}>
            <Typography variant="h3" sx={{ pb: 3 }}>
                {`${appointmentOrderText} summary for ${personalInformation.firstName} ${personalInformation.lastName}`}
            </Typography>
            <Box className={classes.summaryBlock}>
                <PaymentSummaryControl isTopSummaryMode={false}/>
            </Box>
        </Box>
    )
}
</file>

<file path="components/molecules/Services/PayAndConfirm/Terms.tsx">
import React from 'react'
import { Grid, Typography } from '@mui/material'
import { useSelectedServices } from 'lib/state/services'
import { useCartMethods } from 'lib/state/cart'
const cancellationPolicyURL = 'https://www.joinblvd.com/legal/cancellations'
const termsOfServiceURL = 'https://www.joinblvd.com/legal/terms'

export default function Terms() {
    const { selectedServicesStateValue } = useSelectedServices()
    const { isCartAvailableBookableItem } = useCartMethods()
    const hasServices = selectedServicesStateValue.filter(x=>isCartAvailableBookableItem(x.item)).length > 0
    const bookingOrPurchasingText = hasServices ? 'By booking this appointment' : 'By purchasing this product'
    return (
        <Grid item lg={4} md={10} sm={10} xs={12} sx={{ pt: 4 }}>
            <Typography variant="h3" sx={{ pb: 1 }}>
                Terms
            </Typography>
            <Typography sx={{ pb: 1, '& a': {color: '#33343C', fontSize: 14} }}>
                {bookingOrPurchasingText + ', you agree to LOGO’s'} <a target="_blank" rel="noreferrer" href={cancellationPolicyURL}>Cancellation
                Policy</a> as well as Boulevard’s <a target="_blank" rel="noreferrer" href={termsOfServiceURL}>Terms Of Service</a>.
            </Typography>
        </Grid>
    )
}
</file>

<file path="components/molecules/Services/PersonalInfo/Questions/CartBookingQuestionDisplayType.ts">
export enum CartBookingQuestionDisplayType {
    Boolean = 'BOOLEAN',
    Datetime = 'DATETIME',
    Float = 'FLOAT',
    Integer = 'INTEGER',
    LongText = 'LONG_TEXT',
    Multiselect = 'MULTISELECT',
    Select = 'SELECT',
    ShortText = 'SHORT_TEXT',
}
</file>

<file path="components/molecules/Services/PersonalInfo/Questions/QuestionCheckbox.tsx">
import { useFormikContext } from 'formik'
import {
    FormControl,
    FormLabel,
    FormGroup,
    FormControlLabel,
    Checkbox,
    FormHelperText,
} from '@mui/material'

export default function QuestionCheckbox({
    question,
    answer = false,
    onchange,
}) {
    const { errors, handleChange, touched } = useFormikContext()
    return (
        <FormControl
            component="fieldset"
            error={errors[question.id] && touched[question.id]}
        >
            <FormLabel component="legend">
                {question.label}
                {question.required && '*'}
            </FormLabel>
            <FormGroup>
                <FormControlLabel
                    label={question.label}
                    control={
                        <Checkbox
                            id={question.id}
                            name={question.id}
                            checked={answer}
                            onChange={(e) => {
                                onchange({
                                    questionId: question.id,
                                    answer: !answer,
                                })
                                handleChange(e)
                            }}
                        />
                    }
                />
            </FormGroup>
            {errors[question.id] && touched[question.id] && (
                <FormHelperText>{errors[question.id]}</FormHelperText>
            )}
        </FormControl>
    )
}
</file>

<file path="components/molecules/Services/PersonalInfo/Questions/QuestionDatetime.tsx">
import { useFormikContext } from 'formik'
import DatePicker from '@mui/lab/DatePicker'
import { TextField } from '@mui/material'

export default function QuestionDatetime({ question, answer = '', onchange }) {
    const { handleChange } = useFormikContext()
    return (
        <DatePicker
            label={`${question.label}${question.required && '*'}`}
            openTo="year"
            views={['year', 'month', 'day']}
            value={answer}
            onChange={(date) => {
                onchange({
                    questionId: question.id,
                    answer: date,
                })
                handleChange(date)
            }}
            renderInput={(params) => <TextField {...params} />}
        />
    )
}
</file>

<file path="components/molecules/Services/PersonalInfo/Questions/QuestionElement.tsx">
import { useBookingAnswersState } from 'lib/state/booking-answers'
import { BookingAnswer } from 'lib/state/booking-answers/types'
import QuestionCheckbox from './QuestionCheckbox'
import QuestionDatetime from './QuestionDatetime'
import QuestionFloat from './QuestionFloat'
import QuestionInteger from './QuestionInteger'
import QuestionLongText from './QuestionLongText'
import QuestionMultiselect from './QuestionMultiselect'
import QuestionSelect from './QuestionSelect'
import QuestionShortText from './QuestionShortText'
import { CartBookingQuestionDisplayType } from 'components/molecules/Services/PersonalInfo/Questions/CartBookingQuestionDisplayType'

interface Props {
    question: any
}

export default function QuestionElement({ question }: Props) {
    const [bookingAnswers, setBookingAnswers] = useBookingAnswersState()
    const bookingAnswersState = bookingAnswers.find(
        (q) => q.questionId === question.id
    )
    const answer = bookingAnswersState?.answer

    const handleChange = (answer: BookingAnswer) => {
        setBookingAnswers([
            ...bookingAnswers.filter((q) => q.questionId !== answer.questionId),
            answer,
        ])
    }

    return (
        <div>
            {question.displayType ===
                CartBookingQuestionDisplayType.Boolean && (
                <QuestionCheckbox
                    answer={answer}
                    question={question}
                    onchange={handleChange}
                />
            )}
            {question.displayType ===
                CartBookingQuestionDisplayType.Datetime && (
                <QuestionDatetime
                    answer={answer}
                    question={question}
                    onchange={handleChange}
                />
            )}
            {question.displayType === CartBookingQuestionDisplayType.Float && (
                <QuestionFloat
                    answer={answer}
                    question={question}
                    onchange={handleChange}
                />
            )}
            {question.displayType ===
                CartBookingQuestionDisplayType.Integer && (
                <QuestionInteger
                    answer={answer}
                    question={question}
                    onchange={handleChange}
                />
            )}
            {question.displayType ===
                CartBookingQuestionDisplayType.LongText && (
                <QuestionLongText
                    answer={answer}
                    question={question}
                    onchange={handleChange}
                />
            )}
            {question.displayType ===
                CartBookingQuestionDisplayType.Multiselect && (
                <QuestionMultiselect
                    answer={answer}
                    question={question}
                    onchange={handleChange}
                />
            )}
            {question.displayType === CartBookingQuestionDisplayType.Select && (
                <>
                    <QuestionSelect
                        answer={answer}
                        question={question}
                        onchange={handleChange}
                    />
                </>
            )}
            {question.displayType ===
                CartBookingQuestionDisplayType.ShortText && (
                <QuestionShortText
                    answer={answer}
                    question={question}
                    onchange={handleChange}
                />
            )}
        </div>
    )
}
</file>

<file path="components/molecules/Services/PersonalInfo/Questions/QuestionFloat.tsx">
import { useFormikContext } from 'formik'
import { TextField } from '@mui/material'

export default function QuestionFloat({ question, answer = 0.0, onchange }) {
    const { errors, handleChange, touched } = useFormikContext()
    return (
        <TextField
            id={question.id}
            label={`${question.label}${question.required && '*'}`}
            value={answer}
            onChange={(e) => {
                onchange({
                    questionId: question.id,
                    answer: parseFloat(e.target.value),
                })
                handleChange(e)
            }}
            inputProps={{
                type: 'number',
                maxLength: 13,
                step: '0.01',
            }}
            error={errors[question.id] && touched[question.id]}
            helperText={
                errors[question.id] &&
                touched[question.id] &&
                errors[question.id]
            }
        />
    )
}
</file>

<file path="components/molecules/Services/PersonalInfo/Questions/QuestionInteger.tsx">
import { useFormikContext } from 'formik'
import { TextField } from '@mui/material'

export default function QuestionInteger({ question, answer = 0, onchange }) {
    const { errors, handleChange, touched } = useFormikContext()
    return (
        <TextField
            id={question.id}
            type="number"
            label={`${question.label}${question.required && '*'}`}
            value={answer}
            onChange={(e) => {
                onchange({
                    questionId: question.id,
                    answer: e.target.value,
                })
                handleChange(e)
            }}
            error={errors[question.id] && touched[question.id]}
            helperText={
                errors[question.id] &&
                touched[question.id] &&
                errors[question.id]
            }
        />
    )
}
</file>

<file path="components/molecules/Services/PersonalInfo/Questions/QuestionLongText.tsx">
import { useFormikContext } from 'formik'
import { TextField } from '@mui/material'

export default function QuestionLongText({ question, answer = '', onchange }) {
    const { errors, handleChange, touched } = useFormikContext()
    return (
        <TextField
            id={question.id}
            label={`${question.label}${question.required && '*'}`}
            multiline
            rows={4}
            value={answer}
            onChange={(e) => {
                onchange({
                    questionId: question.id,
                    answer: e.target.value,
                })
                handleChange(e)
            }}
            error={errors[question.id] && touched[question.id]}
            helperText={errors[question.id] && touched[question.id]}
        />
    )
}
</file>

<file path="components/molecules/Services/PersonalInfo/Questions/QuestionMultiselect.tsx">
import { useFormikContext } from 'formik'
import {
    FormControl,
    FormLabel,
    FormGroup,
    FormControlLabel,
    Checkbox,
    FormHelperText,
} from '@mui/material'
import { CartBookingQuestionOption } from '@boulevard/blvd-book-sdk/lib/carts/bookingQuestions'

export default function QuestionMultiselect({
    question,
    answer = [],
    onchange,
}) {
    const { errors, handleChange, touched } = useFormikContext()
    const answers = answer as Array<CartBookingQuestionOption>

    const preChangeValue = (e) => {
        const optionId = e.target.value
        const option = question.options.find((x) => x.id == optionId)
        handleChange(e)
        onchange({
            questionId: question.id,
            answer:
                answers.filter(
                    (x: CartBookingQuestionOption) => x.id == option.id
                ).length > 0
                    ? [...answers.filter((s) => s.id !== optionId)]
                    : [...answers, option],
        })
    }

    return (
        <FormControl
            component="fieldset"
            error={errors[question.id] && touched[question.id]}
        >
            <FormLabel component="legend">
                {question.label}
                {question.required && '*'}
            </FormLabel>
            <FormGroup>
                {question.options.map((option) => (
                    <FormControlLabel
                        key={option.id}
                        label={option.label}
                        control={
                            <Checkbox
                                id={question.id}
                                name={question.id}
                                value={option.id}
                                checked={
                                    answers.filter(
                                        (x: CartBookingQuestionOption) =>
                                            x.id == option.id
                                    ).length > 0
                                }
                                onChange={preChangeValue}
                            />
                        }
                    />
                ))}
            </FormGroup>
            {errors[question.id] && touched[question.id] && (
                <FormHelperText>{errors[question.id]}</FormHelperText>
            )}
        </FormControl>
    )
}
</file>

<file path="components/molecules/Services/PersonalInfo/Questions/QuestionSelect.tsx">
import { useFormikContext } from 'formik'
import {
    FormControl,
    InputLabel,
    Select,
    MenuItem,
    FormHelperText,
    Grid,
} from '@mui/material'

export default function QuestionSelect({ question, answer, onchange }) {
    const { errors, handleChange, touched } = useFormikContext()
    return (
        <Grid item md={6} sm={12} xs={12}>
            <FormControl
                error={errors[question.id] && touched[question.id]}
                fullWidth
            >
                <InputLabel htmlFor={question.id}>
                    {question.label}
                    {question.required && '*'}
                </InputLabel>
                <Select
                    id={question.id}
                    value={answer?.id ?? ''}
                    name={question.id}
                    placeholder="Select an option"
                    onChange={(e) => {
                        onchange({
                            questionId: question.id,
                            answer: question.options.find(
                                (x) => x.id == e.target.value
                            ),
                        })
                        handleChange(e)
                    }}
                >
                    <MenuItem />
                    {question.options.map((option) => (
                        <MenuItem key={option.id} value={option.id}>
                            {option.label}
                        </MenuItem>
                    ))}
                </Select>
                {errors[question.id] && touched[question.id] && (
                    <FormHelperText>{errors[question.id]}</FormHelperText>
                )}
            </FormControl>
        </Grid>
    )
}
</file>

<file path="components/molecules/Services/PersonalInfo/Questions/QuestionShortText.tsx">
import { useFormikContext } from 'formik'
import { TextField } from '@mui/material'

export default function QuestionShortText({ question, answer = '', onchange }) {
    const { errors, handleChange, touched } = useFormikContext()
    return (
        <TextField
            id={question.id}
            label={`${question.label}${question.required && '*'}`}
            value={answer}
            onChange={(e) => {
                onchange({
                    questionId: question.id,
                    answer: e.target.value,
                })
                handleChange(e)
            }}
            error={errors[question.id] && touched[question.id]}
            helperText={
                errors[question.id] &&
                touched[question.id] &&
                errors[question.id]
            }
        />
    )
}
</file>

<file path="components/molecules/Services/PersonalInfo/ts/constants.ts">
export const firstNameFieldName = 'firstName'
export const lastNameFieldName = 'lastName'
export const emailFieldName = 'email'
export const phoneFieldName = 'phone'
</file>

<file path="components/molecules/Services/PersonalInfo/ts/formikUtils.ts">
import * as Yup from 'yup'
import { Cart } from '@boulevard/blvd-book-sdk/lib/cart'
import { BookingAnswer } from 'lib/state/booking-answers/types'

export const getBookingQuestionsInitialValues = (
    cart: Cart | undefined,
    bookingAnswers: BookingAnswer[]
) => {
    let initialValuesObject = {}

    const bookingQuestions = cart?.bookingQuestions.map((question) => {
        return {
            id: question.id,
            required: question.required,
        }
    })
    if (bookingQuestions) {
        for (let bq of bookingQuestions) {
            if (bq.required) {
                initialValuesObject[bq.id] = ''
            }
        }
    }

    for (let bookingAnswer of bookingAnswers) {
        initialValuesObject[bookingAnswer.questionId] = bookingAnswer.answer
    }
    return initialValuesObject
}

export const getBookingQuestionsValidationSchema = (cart: Cart | undefined) => {
    let validationSchemaObject = {}

    const bookingQuestions = cart?.bookingQuestions.map((question) => {
        return {
            id: question.id,
            required: question.required,
        }
    })
    if (bookingQuestions) {
        for (let bq of bookingQuestions) {
            if (bq.required) {
                validationSchemaObject[bq.id] = Yup.mixed().required('Required')
            }
        }
    }
    return validationSchemaObject
}
</file>

<file path="components/molecules/Services/PersonalInfo/ts/useButtons.ts">
import { useContext } from 'react'
import { FormikValues } from 'formik'
import { Step } from 'lib/state/booking-flow/types'
import { useCartState } from 'lib/state/cart'
import { useFlowStep } from 'lib/state/booking-flow'
import { useBookingAnswers } from 'lib/state/booking-answers'
import { usePersonalInformationState } from 'lib/state/personal-info'
import { CartBookingQuestionDisplayType } from 'components/molecules/Services/PersonalInfo/Questions/CartBookingQuestionDisplayType'
import { useUrlParams } from 'lib/sdk/hooks/useUrlParams'
import { useErrorMessageType } from 'lib/state/error'
import { ErrorType } from 'lib/state/error/enums'
import { LayoutContext } from 'components/atoms/layout/LayoutContext'

export const useButtons = () => {
    const layout = useContext(LayoutContext)
    const { setStep } = useFlowStep()
    const cart = useCartState()
    const [, setPersonalInformation] = usePersonalInformationState()
    const bookingAnswers = useBookingAnswers()
    const [, setErrorMessageType] = useErrorMessageType()
    const { getUrlParams } = useUrlParams()

    const getFieldOrUndefined = (value: string | undefined) => {
        let result: string | undefined
        if (value?.length && value.length > 0) {
            result = value
        }
        return result
    }

    const onContinue = async (values: FormikValues) => {
        layout.setIsShowLoader(true)
        try {
            layout.setIsShowLoader(true)

            let phone: string | undefined
            if (values?.phone?.length && values.phone.length > 0) {
                phone = values.phone.startsWith('+')
                    ? values.phone
                    : `+1${values.phone}`
            }

            let updatedCart = await cart?.update({
                referralSource: getUrlParams().ref,
                clientInformation: {
                    externalId: getUrlParams().shopperId,
                    email: getFieldOrUndefined(values?.email),
                    firstName: getFieldOrUndefined(values?.firstName),
                    lastName: getFieldOrUndefined(values?.lastName),
                    phoneNumber: phone?.replace(/[-_ ()]/g, ''),
                },
            })

            const bookingQuestions = updatedCart?.bookingQuestions
            const answers = bookingAnswers.concat()

            // for CartBookingQuestionDisplayType.Select if user hasn't chosen answer explicitly - set first option as answer
            if (bookingQuestions && answers) {
                for (let bookingQuestion of bookingQuestions.filter(
                    (x) =>
                        x.displayType ===
                            CartBookingQuestionDisplayType.Select &&
                        x.options.length > 0 &&
                        x.required
                )) {
                    const answer = answers.find(
                        (x) => x.questionId == bookingQuestion.id
                    )
                    if (answer == undefined) {
                        answers.push({
                            questionId: bookingQuestion.id,
                            answer: bookingQuestion.options[0],
                        })
                    }
                }

                for (let bookingAnswer of answers) {
                    const bookingQuestion = bookingQuestions.find(
                        (x) => x.id == bookingAnswer.questionId
                    )
                    if (bookingQuestion && bookingAnswer.answer) {
                        updatedCart = await bookingQuestion.submitAnswer(
                            bookingAnswer.answer
                        )
                    }
                }
            }

            await setPersonalInformation({
                email: getFieldOrUndefined(values?.email)!,
                firstName: getFieldOrUndefined(values?.firstName)!,
                lastName: getFieldOrUndefined(values?.lastName)!,
                phone: values.phone,
            })
            setErrorMessageType(ErrorType.NoError)
            await setStep(Step.PayAndConfirm)
        } catch {
            layout.setIsShowLoader(false)
        }
    }

    const onMoveBack = async () => {
        await setStep(Step.ChooseDate)
    }

    return {
        onContinue: onContinue,
        onMoveBack: onMoveBack,
        isFormSubmitting: layout.isShowLoader,
    }
}
</file>

<file path="components/molecules/Services/PersonalInfo/AdditionalInfo.tsx">
import React from 'react'
import { Box, Typography } from '@mui/material'
import { useCartState } from 'lib/state/cart'
import QuestionElement from './Questions/QuestionElement'

export default function AdditionalInfo() {
    const cartState = useCartState()

    return (
        <Box sx={{ pt: 5 }}>
            <Typography variant="h3" sx={{ pb: 1 }}>
                Additional Information
            </Typography>
            {cartState &&
                cartState.bookingQuestions.map((question) => (
                    <QuestionElement key={question.id} question={question} />
                ))}
        </Box>
    )
}
</file>

<file path="components/molecules/Services/PersonalInfo/BasicInfo.tsx">
import React from 'react'
import { Box, Typography } from '@mui/material'
import FirstLastName from 'components/molecules/Services/PersonalInfo/FirstLastName'

export default function BasicInfo() {
    return (
        <Box>
            <Typography variant="h3" sx={{ pb: 1 }}>
                Basic info
            </Typography>
            <FirstLastName />
        </Box>
    )
}
</file>

<file path="components/molecules/Services/PersonalInfo/ContactInfo.tsx">
import React from 'react'
import { Box, Typography } from '@mui/material'
import EmailPhone from 'components/molecules/Services/PersonalInfo/EmailPhone'

export default function ContactInfo() {
    return (
        <Box sx={{ pt: 5 }}>
            <Typography variant="h3" sx={{ pb: 1 }}>
                Contact info
            </Typography>
            <EmailPhone />
        </Box>
    )
}
</file>

<file path="components/molecules/Services/PersonalInfo/EmailPhone.tsx">
import { useFormikContext } from 'formik'
import { Grid } from '@mui/material'
import MaskedInput from 'react-text-mask'
import { phoneMask } from 'constants/regexps'
import TextFieldBase from 'components/atoms/formik/TextFieldBase'
import { emailFieldName, phoneFieldName } from '../PersonalInfo/ts/constants'
import { forwardRef } from 'react'

// eslint-disable-next-line react/display-name
const TextMaskCustom = forwardRef((props, ref) => {
    return (
        <MaskedInput {...props} placeholder="(000) 000-0000" mask={phoneMask} />
    )
})

export default function EmailPhone() {
    const { errors, touched } = useFormikContext()

    return (
        <>
            <Grid item md={5} sm={12} xs={12}>
                <TextFieldBase
                    id={emailFieldName}
                    label="Email"
                    type="email"
                    error={errors[emailFieldName] && touched[emailFieldName]}
                    helperText={
                        errors[emailFieldName] &&
                        touched[emailFieldName] &&
                        errors[emailFieldName]
                    }
                />
            </Grid>
            <Grid item md={4} sm={12} xs={12}>
                <TextFieldBase
                    id={phoneFieldName}
                    label="Phone"
                    type="tel"
                    InputProps={{
                        inputComponent: TextMaskCustom,
                    }}
                    error={errors[phoneFieldName] && touched[phoneFieldName]}
                    helperText={
                        errors[phoneFieldName] &&
                        touched[phoneFieldName] &&
                        errors[phoneFieldName]
                    }
                />
            </Grid>
        </>
    )
}
</file>

<file path="components/molecules/Services/PersonalInfo/FirstLastName.tsx">
import { useFormikContext } from 'formik'
import { Grid } from '@mui/material'
import TextFieldBase from 'components/atoms/formik/TextFieldBase'
import {
    firstNameFieldName,
    lastNameFieldName,
} from '../PersonalInfo/ts/constants'

export default function FirstLastName() {
    const { errors, touched } = useFormikContext()

    return (
        <Grid item md={6} sm={12} xs={12}>
            <TextFieldBase
                id={firstNameFieldName}
                label="First Name"
                fullWidth
                error={
                    errors[firstNameFieldName] && touched[firstNameFieldName]
                }
                helperText={
                    errors[firstNameFieldName] &&
                    touched[firstNameFieldName] &&
                    errors[firstNameFieldName]
                }
            />
            <TextFieldBase
                id={lastNameFieldName}
                label="Last Name"
                error={errors[lastNameFieldName] && touched[lastNameFieldName]}
                helperText={
                    errors[lastNameFieldName] &&
                    touched[lastNameFieldName] &&
                    errors[lastNameFieldName]
                }
            />
        </Grid>
    )
}
</file>

<file path="components/molecules/Services/PersonalInfo/PersonalInfoScreen.tsx">
import WithLayout from 'components/atoms/layout/WithLayout'
import YourAndAdditionalInfo from 'components/molecules/Services/PersonalInfo/YourAndAdditionalInfo'
import { Step } from 'lib/state/booking-flow/types'
import { useMobile } from 'lib/utils/useMobile'

export default function PersonalInfoScreen() {
    const { isMobile } = useMobile()

    return (
        <WithLayout
            isShowLoader={false}
            leftPanel={<></>}
            rightPanel={<YourAndAdditionalInfo />}
            rightPanelCaption="Your information"
            rightPanelBtnCaption="Continue"
            showBottom={true}
            addBackArrow={isMobile}
            backArrowStep={Step.ChooseDate}
        />
    )
}
</file>

<file path="components/molecules/Services/PersonalInfo/YourAndAdditionalInfo.tsx">
import React from 'react'
import { Formik } from 'formik'
import * as Yup from 'yup'
import { useCartState } from 'lib/state/cart'
import { useButtons } from 'components/molecules/Services/PersonalInfo/ts/useButtons'
import {
    getBookingQuestionsInitialValues,
    getBookingQuestionsValidationSchema,
} from 'components/molecules/Services/PersonalInfo/ts/formikUtils'
import { usePersonalInformationState } from 'lib/state/personal-info'
import { phoneRegExp } from '../../../../constants/regexps'
import YourInfoForm from 'components/molecules/Services/PersonalInfo/YourInfoForm'
import { useBookingAnswers } from 'lib/state/booking-answers'

export default function YourAndAdditionalInfo() {
    const cart = useCartState()
    const [personalInformation] = usePersonalInformationState()
    const { onContinue } = useButtons()
    const bookingAnswers = useBookingAnswers()

    return (
        <Formik
            initialValues={{
                firstName: personalInformation.firstName,
                lastName: personalInformation.lastName,
                email: personalInformation.email,
                phone: personalInformation.phone,
                ...getBookingQuestionsInitialValues(cart, bookingAnswers),
            }}
            validationSchema={Yup.object().shape({
                firstName: Yup.string().required('Required'),
                lastName: Yup.string().required('Required'),
                email: Yup.string()
                    .email('Email address is not valid')
                    .required('Required'),
                phone: Yup.string()
                    .matches(phoneRegExp, 'Phone number is not valid')
                    .required('Required'),
                ...getBookingQuestionsValidationSchema(cart),
            })}
            onSubmit={(values) => onContinue(values)}
            validateOnChange
        >
            {() => <YourInfoForm />}
        </Formik>
    )
}
</file>

<file path="components/molecules/Services/PersonalInfo/YourInfoForm.tsx">
import React, { useContext, useEffect } from 'react'
import { useFormikContext } from 'formik'
import { Box } from '@mui/material'
import { useCartState } from 'lib/state/cart'
import { LayoutContext } from 'components/atoms/layout/LayoutContext'
import BasicInfo from 'components/molecules/Services/PersonalInfo/BasicInfo'
import ContactInfo from 'components/molecules/Services/PersonalInfo/ContactInfo'
import AdditionalInfo from 'components/molecules/Services/PersonalInfo/AdditionalInfo'
import { useMobile } from 'lib/utils/useMobile'
import { theme } from 'styles/theme'

export default function YourInfoForm() {
    const { isMobile } = useMobile()
    const cartState = useCartState()
    const { handleSubmit } = useFormikContext()
    const layout = useContext(LayoutContext)

    useEffect(() => {
        layout.setOnRightPanelBtnClick(() => {
            handleSubmit()
        })
        // eslint-disable-next-line
    }, [])

    return (
        <Box sx={{
            padding: !isMobile ? 5 : theme.spacing(3, 4, 10, 5),
            height: 'calc(100% - 57px)',
            overflowY: 'scroll',
            position: 'sticky',
            '&::-webkit-scrollbar': {
                display: 'none',
            },
        }}>
            <BasicInfo />
            <ContactInfo />
            {!!cartState?.bookingQuestions.length && <AdditionalInfo />}
        </Box>
    )
}
</file>

<file path="components/molecules/Services/SelectedServices/AvailableServiceOption.tsx">
import { CartAvailableBookableItemOption } from '@boulevard/blvd-book-sdk/lib/carts/items'
import { CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { FiPlusCircle } from 'react-icons/fi'
import { Box } from '@mui/material'
import { useCartMethods, useCartState } from 'lib/state/cart'
import { useAvailableServiceOptionStyles } from 'components/molecules/Services/SelectedServices/useStyles'
import { Option } from 'components/molecules/Services/SelectedServices/Option'

interface Props {
    option: CartAvailableBookableItemOption
    bookableItem: CartBookableItem
}

export const AvailableServiceOption = ({ option, bookableItem }: Props) => {
    const classes = useAvailableServiceOptionStyles()
    const cart = useCartState()
    const { addAddon } = useCartMethods()
    const addOption = async () => {
        if (cart === undefined) {
            return
        }

        await addAddon(cart, bookableItem, option)
    }

    return (
        <Box className={classes.optionRoot}>
            <Box className={classes.plus} onClick={addOption}>
                <FiPlusCircle size={15} />
            </Box>
            <Box className={classes.textWrapper}>
                <Option option={option} />
                <Box component="span" className={classes.description}>
                    {option.description}
                </Box>
            </Box>
        </Box>
    )
}
</file>

<file path="components/molecules/Services/SelectedServices/AvailableServiceOptions.tsx">
import { CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { Box } from '@mui/material'
import { AvailableServiceOption } from 'components/molecules/Services/SelectedServices/AvailableServiceOption'
import { useAvailableServiceOptionsStyles } from 'components/molecules/Services/SelectedServices/useStyles'

interface Props {
    bookableItem: CartBookableItem
}

export const AvailableServiceOptions = ({ bookableItem }: Props) => {
    const classes = useAvailableServiceOptionsStyles()

    if (!bookableItem.item.optionGroups) {
        return <></>
    }
    const additionalOptions = bookableItem.item.optionGroups.length
        ? bookableItem.item.optionGroups[0].options
        : undefined
    const addedAdditionalOptions = bookableItem.selectedOptions
        .map((selectedOption) => selectedOption.id)
        .sort()
        .join(',')
    const allExistingAdditionalOptions = additionalOptions
        ?.map((additionalOption) => additionalOption.id)
        .sort()
        .join(',')
    const areAllAdditionalOptionsAdded =
        addedAdditionalOptions === allExistingAdditionalOptions
    return (
        <>
            {!areAllAdditionalOptionsAdded && additionalOptions && (
                <Box>
                    <Box
                        component="span"
                        className={classes.customizeYourService}
                    >
                        Customize your service
                    </Box>
                    {additionalOptions.map((option) => (
                        <AvailableServiceOption
                            key={option.id}
                            option={option}
                            bookableItem={bookableItem}
                        />
                    ))}
                </Box>
            )}
        </>
    )
}
</file>

<file path="components/molecules/Services/SelectedServices/DurationPrice.tsx">
import { getDurationText } from 'lib/utils/durationUtils'
import { CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { PriceLabel } from 'lib/utils/formatCurrency'

interface Props {
    bookableItem: CartBookableItem
}
export const DurationPrice = ({ bookableItem }: Props) => {
    const durationText = getDurationText(bookableItem.item)
    return (
        <>
            {durationText && (
                <>
                    <span>{durationText}</span>
                    <span> &bull; </span>
                </>
            )}
            <span>{PriceLabel(bookableItem.item.listPriceRange.min)}</span>
        </>
    )
}
</file>

<file path="components/molecules/Services/SelectedServices/MobileAddAnotherService.tsx">
import { useMobile } from 'lib/utils/useMobile'
import { Box, Button } from '@mui/material'
import { useMobileAddAnotherServiceStyles } from 'components/molecules/Services/SelectedServices/useStyles'
import { Step } from 'lib/state/booking-flow/types'
import { useFlowStep } from 'lib/state/booking-flow'
import { useContext } from 'react'
import { LayoutContext } from 'components/atoms/layout/LayoutContext'
import { useActiveSelectedService, useServiceActions } from 'lib/state/services'
import { useSelectedServiceChange } from 'components/molecules/Services/SelectedServices/useSelectedServiceChange'

interface Props {
    allowAddAnotherService?: boolean
    allowRemoveService?: boolean
    allowEditAddonService?: boolean
}

export const MobileAddAnotherService = ({
    allowAddAnotherService,
    allowRemoveService,
    allowEditAddonService,
}: Props) => {
    const { setStep } = useFlowStep()
    const { isMobile } = useMobile()
    const classes = useMobileAddAnotherServiceStyles({ isMobile })
    const layout = useContext(LayoutContext)
    const activeSelectedService = useActiveSelectedService()
    const {handleServiceChange} = useSelectedServiceChange()
    const hasAddons =
        activeSelectedService &&
        activeSelectedService.item.optionGroups?.flatMap((x) => x.options)
            .length > 0

    const { onRemoveClick, onEditAddonClick } = useServiceActions(
        activeSelectedService
    )

    const onRemoveInternal = async () => {
        const removeClickResult = await onRemoveClick()
        if (handleServiceChange && removeClickResult) {
            await handleServiceChange(removeClickResult.activeItem)
        }
    }

    const onAddAnotherServiceClick = async () => {
        await setStep(Step.SelectService)
    }

    if (!isMobile) {
        return <></>
    }

    return (
        <>
            <Box
                sx={{
                    marginTop: '160px',
                }}
            />
            <Box className={classes.leftPanelBottom} sx={{
                bottom: layout.showBottom ? '56px' : '0px!important',
            }}>
                {layout.showBottom && allowAddAnotherService && (
                    <Button
                        variant="text"
                        color="secondary"
                        className={classes.leftPanelBottomBtn}
                        onClick={onAddAnotherServiceClick}
                        sx={{
                            width: 'auto',
                        }}
                    >
                        Add another
                    </Button>
                )}
                {allowRemoveService && (
                    <Button
                        variant="text"
                        color="secondary"
                        className={classes.leftPanelBottomBtn}
                        onClick={onRemoveInternal}
                        sx={{
                            width: 'auto',
                        }}
                    >
                        Remove
                    </Button>
                )}
                {hasAddons && allowEditAddonService && (
                    <Button
                        variant="text"
                        color="secondary"
                        className={classes.leftPanelBottomBtn}
                        onClick={onEditAddonClick}
                        sx={{
                            width: 'auto',
                            textTransform: 'none',
                        }}
                    >
                        Edit add-ons
                    </Button>
                )}
            </Box>
        </>
    )
}
</file>

<file path="components/molecules/Services/SelectedServices/MobileRightSection.tsx">
import { useMobile } from 'lib/utils/useMobile'
import { useFlowStep } from 'lib/state/booking-flow'
import { Step } from 'lib/state/booking-flow/types'
import { BackHeader } from 'components/atoms/layout/mobile/BackHeader'
import { MobileSelectedServiceSelector } from 'components/molecules/MobileSelectedServiceSelector'
import React from 'react'
import { FlowType, useAppConfig } from 'lib/state/config'
import { useSelectedServices } from 'lib/state/services'
import { useCartMethods } from 'lib/state/cart'

export const MobileRightSection = () => {
    const { isMobile } = useMobile()
    const { setStep } = useFlowStep()
    const { getFlowType } = useAppConfig()
    const flowType = getFlowType()
    const { selectedServicesStateValue } = useSelectedServices()
    const {isCartAvailableBookableItem} = useCartMethods()
    const isAnyServiceExist = selectedServicesStateValue.filter(x=>isCartAvailableBookableItem(x.item)).length > 0

    const onBackHeaderClick = async () => {
        const step =
            flowType === FlowType.SelectLocationFirst
                ? Step.SelectService
                : Step.ChooseLocation
        await setStep(step)
    }

    if (!isMobile) {
        return <></>
    }

    return (
        <>
            <BackHeader caption={isAnyServiceExist ? "Select stylist" : 'Select and manage options'} onClick={onBackHeaderClick} />
            <MobileSelectedServiceSelector />
        </>
    )
}
</file>

<file path="components/molecules/Services/SelectedServices/Option.tsx">
import { CartAvailableBookableItemOption } from '@boulevard/blvd-book-sdk/lib/carts/items'
import { Box } from '@mui/material'
import { PriceLabel } from 'lib/utils/formatCurrency'

interface Props {
    option: CartAvailableBookableItemOption
}
export const Option = ({ option }: Props) => {
    return (
        <Box>
            {option.name} (+
            {PriceLabel(option.priceDelta)})
        </Box>
    )
}
</file>

<file path="components/molecules/Services/SelectedServices/RightPanel.tsx">
import { StaffsList } from 'components/molecules/Services/ChooseStaff/StaffsList'
import { MobileRightSection } from 'components/molecules/Services/SelectedServices/MobileRightSection'
import { MobileAddAnotherService } from 'components/molecules/Services/SelectedServices/MobileAddAnotherService'
import { useSelectedServices } from 'lib/state/services'
import { useCartMethods } from 'lib/state/cart'
import { OptionsList } from 'components/molecules/Services/SelectOptions/OptionsList'
import React from 'react'

export const RightPanel = () => {
    const { selectedServicesStateValue } = useSelectedServices()
    const { isCartAvailableBookableItem } = useCartMethods()
    const hasServices = selectedServicesStateValue.filter(x=>isCartAvailableBookableItem(x.item)).length > 0
    return (
        <>
            <MobileRightSection />
            {hasServices && <StaffsList />}
            {!hasServices && <OptionsList />}
            <MobileAddAnotherService
                allowAddAnotherService={true}
                allowEditAddonService={true}
                allowRemoveService={true}
            />
        </>
    )
}
</file>

<file path="components/molecules/Services/SelectedServices/SelectedOption.tsx">
import { CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { Box } from '@mui/material'
import { FiXCircle } from 'react-icons/fi'
import { useCartMethods, useCartState } from 'lib/state/cart'
import { CartAvailableBookableItemOption } from '@boulevard/blvd-book-sdk/lib/carts/items'
import { useSelectedOptionStyles } from 'components/molecules/Services/SelectedServices/useStyles'
import { Option } from 'components/molecules/Services/SelectedServices/Option'

interface Props {
    bookableItem: CartBookableItem
    option: CartAvailableBookableItemOption
    isReadMode?: boolean
}

export const SelectedOption = ({ bookableItem, option, isReadMode }: Props) => {
    const classes = useSelectedOptionStyles()
    const cart = useCartState()
    const { removeAddon } = useCartMethods()
    const removeOption = async (option: CartAvailableBookableItemOption) => {
        if (cart === undefined || isReadMode) {
            return
        }

        await removeAddon(cart, bookableItem, option)
    }

    return (
        <Box className={classes.root}>
            <Option option={option} />
            {!isReadMode && (
                <Box
                    component="span"
                    className={classes.remove}
                    onClick={() => removeOption(option)}
                >
                    <FiXCircle size={15} />
                </Box>
            )}
        </Box>
    )
}
</file>

<file path="components/molecules/Services/SelectedServices/SelectedOptions.tsx">
import { CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { Box } from '@mui/material'
import { SelectedOption } from 'components/molecules/Services/SelectedServices/SelectedOption'

interface Props {
    bookableItem: CartBookableItem
    isReadMode?: boolean
}

export const SelectedOptions = ({ bookableItem, isReadMode }: Props) => {
    return (
        <>
            {bookableItem.selectedOptions && bookableItem.selectedOptions.length !== 0 && (
                <Box>
                    {bookableItem.selectedOptions.map((selectedOption) => (
                        <SelectedOption
                            key={selectedOption.id}
                            bookableItem={bookableItem}
                            option={selectedOption}
                            isReadMode={isReadMode}
                        />
                    ))}
                </Box>
            )}
        </>
    )
}
</file>

<file path="components/molecules/Services/SelectedServices/SelectedServices.tsx">
import { useSelectedServices } from 'lib/state/services'
import { Service } from 'components/molecules/Services/SelectedServices/Service'
import { Box } from '@mui/material'
import { CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { useServicesListStyles } from 'components/molecules/Services/SelectService/useStyles'

interface Props {
    handleServiceChange?: (bookableItem: CartBookableItem) => void
}

export const SelectedServices = ({ handleServiceChange }: Props) => {
    const classes = useServicesListStyles()
    const { selectedServicesStateValue, reverseSelectedServices } =
        useSelectedServices()
    const reversedList = reverseSelectedServices(selectedServicesStateValue)

    return (
        <Box className={classes.root} sx={{ height: 'calc(100% - 87px)' }}>
            {reversedList?.map((cartItem) => (
                <Service
                    key={cartItem.id}
                    bookableItem={cartItem}
                    handleServiceChange={handleServiceChange}
                />
            ))}
        </Box>
    )
}
</file>

<file path="components/molecules/Services/SelectedServices/SelectedServicesScreen.tsx">
import { SelectedServices } from 'components/molecules/Services/SelectedServices/SelectedServices'
import { Box } from '@mui/material'
import { useSelectedServicesScreenStyles } from 'components/molecules/Services/SelectedServices/useStyles'
import WithLayout from 'components/atoms/layout/WithLayout'
import { useFlowStep } from 'lib/state/booking-flow'
import { Step } from 'lib/state/booking-flow/types'
import { RightPanel } from 'components/molecules/Services/SelectedServices/RightPanel'
import { WorkshopPanel } from 'components/molecules/Services/SelectedServices/WorkshopPanel'
import { useCartMethods } from 'lib/state/cart'
import { useSelectedServices } from 'lib/state/services'
import { useSelectedServiceChange } from 'components/molecules/Services/SelectedServices/useSelectedServiceChange'
import { useMobile } from 'lib/utils/useMobile'

export const SelectedServicesScreen = () => {
    const classes = useSelectedServicesScreenStyles()
    const { setStep } = useFlowStep()
    const { isMobile } = useMobile()
    const {isCartAvailableBookableItem} = useCartMethods()
    const {handleServiceChange} = useSelectedServiceChange()
    const { selectedServicesStateValue } = useSelectedServices()
    const hasServices = selectedServicesStateValue.filter(x=>isCartAvailableBookableItem(x.item)).length > 0
    let rightPanelCaption = 'Select options'
    if (isMobile) {
        rightPanelCaption = ''
    } else if (hasServices) {
        rightPanelCaption = 'Select a specialist'
    }

    const onLeftPanelBtnClick = async () => {
        await setStep(Step.SelectService)
    }

    return (
        <WithLayout
            isShowLoader={false}
            leftPanel={
                <Box className={classes.servicesRoot}>
                    <SelectedServices
                        handleServiceChange={handleServiceChange}
                    />
                </Box>
            }
            rightPanel={<RightPanel />}
            showBottom={false}
            rightPanelCaption={rightPanelCaption}
            rightPanelBtnCaption="Continue"
            leftPanelBtnCaption={'Add another'}
            onLeftPanelBtnClick={onLeftPanelBtnClick}
            workshopPanel={<WorkshopPanel />}
        />
    )
}
</file>

<file path="components/molecules/Services/SelectedServices/SelectedTime.tsx">
import { Typography } from '@mui/material'
import { useCartState } from 'lib/state/cart'
import { Step } from 'lib/state/booking-flow/types'
import { useFlowStep } from 'lib/state/booking-flow'
import { format as formatFn, toDate } from 'date-fns-tz'
import { useCartStoreState } from 'lib/state/store'
import { useStaffTimes } from 'lib/state/staffTime'

export const SelectedTime = () => {
    const { setStep } = useFlowStep()
    const cart = useCartState()
    const store = useCartStoreState()
    const { loadDatesAndTimes } = useStaffTimes()
    const bookedTime = cart?.startTime
        ? `at ${formatFn(toDate(cart?.startTime), 'h:mmaaa')}`
        : ''

    const onStepClick = async () => {
        await loadDatesAndTimes(cart!, store?.location!, new Date())
        await setStep(Step.ChooseDate)
    }

    if (!cart?.startTime) {
        return null
    }

    return (
        <Typography
            onClick={onStepClick}
            variant="subtitle2"
            sx={{
                pl: '3px',
                cursor: 'pointer',
                fontWeight: '400'
            }}
        >
            {bookedTime}
        </Typography>
    )
}
</file>

<file path="components/molecules/Services/SelectedServices/Service.tsx">
import { CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { Button } from '@mui/material'
import { Step } from 'lib/state/booking-flow/types'
import { useFlowStep } from 'lib/state/booking-flow'
import {
    useActiveSelectedService,
    useServiceActions,
    useSetActiveSelectedService,
} from 'lib/state/services'
import { useServiceStyles } from 'components/molecules/Services/SelectedServices/useStyles'
import { WithService } from 'components/molecules/Services/SelectedServices/WithService'

interface Props {
    bookableItem: CartBookableItem
    handleServiceChange?: (bookableItem: CartBookableItem) => void
}

export const Service = ({ bookableItem, handleServiceChange }: Props) => {
    const activeSelectedService = useActiveSelectedService()
    const setActiveSelectedService = useSetActiveSelectedService()
    const classes = useServiceStyles()
    const { currentFlowStep } = useFlowStep()
    const { onRemoveClick, onEditAddonClick } = useServiceActions(bookableItem)

    const hasAddons =
        bookableItem.item.optionGroups?.flatMap((x) => x.options).length > 0

    const onRemoveInternal = async () => {
        const removeClickResult = await onRemoveClick()
        if (handleServiceChange && removeClickResult && removeClickResult.activeItem) {
            await handleServiceChange(removeClickResult.activeItem)
        }
    }
    const handleChange = async () => {
        if (activeSelectedService?.id === bookableItem.id) {
            return
        }
        setActiveSelectedService(bookableItem)
        if (handleServiceChange) {
            await handleServiceChange(bookableItem)
        }
    }

    const selected = activeSelectedService?.id === bookableItem.id

    return (
        <WithService
            bookableItem={bookableItem}
            selected={selected}
            handleChange={handleChange}
            isReadMode={true}
            addRightArrow={true}
        >
            {hasAddons && currentFlowStep.step !== Step.SelectOptions && (
                <Button
                    variant="contained"
                    className={classes.editAddOn}
                    onClick={onEditAddonClick}
                >
                    Edit add-ons
                </Button>
            )}
            <Button
                variant="contained"
                className={classes.removeBtn}
                onClick={onRemoveInternal}
            >
                Remove
            </Button>
        </WithService>
    )
}
</file>

<file path="components/molecules/Services/SelectedServices/ServiceStaff.tsx">
import { CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { useCartBookableItemListStaff } from 'lib/state/staff'
import { Box, Typography } from '@mui/material'
import { useServiceStaffStyles } from 'components/molecules/Services/SelectedServices/useStyles'
import { StaffError } from 'components/molecules/Services/SelectedServices/StaffError'
import { SelectedTime } from 'components/molecules/Services/SelectedServices/SelectedTime'
import { useCartMethods } from 'lib/state/cart'

interface Props {
    bookableItem: CartBookableItem
}

export const ServiceStaff = ({ bookableItem }: Props) => {
    const classes = useServiceStaffStyles()
    const cartBookableItemListStaff = useCartBookableItemListStaff()
    const staff = cartBookableItemListStaff?.find(
        (s) => s.cartBookableItemId === bookableItem.id
    )?.staff
    const {isCartAvailableBookableItem} = useCartMethods()

    return (
        <>
            {staff && staff.avatar && (
                <Box className={classes.staffSelected}>
                    <Typography>with {staff.name}</Typography>
                    <SelectedTime />
                </Box>
            )}
            {staff && !staff.id && (
                <Box className={classes.staffSelected}>
                    <Typography>with first available</Typography>
                    <SelectedTime />
                </Box>
            )}
            {isCartAvailableBookableItem(bookableItem.item) && <StaffError staff={staff} />}
        </>
    )
}
</file>

<file path="components/molecules/Services/SelectedServices/StaffError.tsx">
import { Staff } from 'lib/state/staff/types'
import { Box } from '@mui/material'
import { useStaffErrorStyles } from 'components/molecules/Services/SelectedServices/useStyles'
import { useAllowChooseStaffError } from 'lib/state/staff'
import { Step } from 'lib/state/booking-flow/types'
import { useFlowStep } from 'lib/state/booking-flow'

interface Props {
    staff: Staff | undefined
}
export const StaffError = ({ staff }: Props) => {
    const classes = useStaffErrorStyles()
    const allowChooseStaffError = useAllowChooseStaffError()
    const { currentFlowStep } = useFlowStep()
    return (
        <>
            {!staff &&
                allowChooseStaffError &&
                currentFlowStep.step !== Step.SelectOptions && (
                    <Box className={classes.staffError}>
                        <Box className={classes.staffErrorIconInline}>!</Box>
                        <Box component="span">
                            Choose a staff member to continue
                        </Box>
                    </Box>
                )}
        </>
    )
}
</file>

<file path="components/molecules/Services/SelectedServices/useSelectedServiceChange.ts">
import { CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import {
    cartAvailableBookableItemStaffVariantToStaff,
    useSetAllowChooseStaffError,
    useSetBookableStaffVariants
} from 'lib/state/staff'
import { useCartMethods } from 'lib/state/cart'

export const useSelectedServiceChange = () => {
    const {isCartAvailableBookableItem} = useCartMethods()
    const setBookableStaffVariants = useSetBookableStaffVariants()
    const setAllowChooseStaffError = useSetAllowChooseStaffError()

    const handleServiceChange = async (bookableItem: CartBookableItem) => {
        setAllowChooseStaffError(true)
        if (isCartAvailableBookableItem(bookableItem.item)) {
            const staffs = await bookableItem.item.getStaffVariants()
            setBookableStaffVariants(
                staffs.flatMap((z) =>
                    cartAvailableBookableItemStaffVariantToStaff(z)
                )
            )
        } else {
            setBookableStaffVariants([])
        }
    }

    return {
        handleServiceChange: handleServiceChange,
    }
}
</file>

<file path="components/molecules/Services/SelectedServices/useStyles.ts">
import { makeStyles } from '@mui/styles'
import { colors } from 'constants/colors'

export const useSelectedServicesScreenStyles = makeStyles(() => ({
    servicesRoot: {
        paddingTop: '1px',
        paddingBottom: '1px',
        height: 'calc(100% - 117px)',
    },
}))

export const useAvailableServiceOptionsStyles = makeStyles(() => ({
    customizeYourService: {
        fontWeight: 500,
    },
}))

export const useStaffErrorStyles = makeStyles(() => ({
    staffError: {
        display: 'flex',
        flexDirection: 'row',
        justifyContent: 'flex-start',
        alignItems: 'center',
        paddingTop: '20px',
    },
    staffErrorIconInline: {
        display: 'inline-block',
        border: '1px solid red',
        color: 'red',
        width: '25px',
        height: '25px',
        lineHeight: '25px',
        textAlign: 'center',
        fontSize: '20px',
        fontWeight: 'bold',
        borderRadius: '50%',
        marginRight: '10px',
    },
}))

export const useServiceStaffStyles = makeStyles(() => ({
    staffSelected: {
        lineHeight: '25px',
        display: 'flex',
        flexDirection: 'row',
        justifyContent: 'flex-start',
        alignItems: 'center',
    },
    staffAvatar: {
        backgroundSize: '100%',
        borderRadius: '50%',
        height: '32px',
        width: '32px',
        display: 'inline-block',
        marginRight: '10px',
    },
    chosenItemStaffBoxAvatarEmpty: {
        border: '1px solid #e3e3e3',
        backgroundSize: '100%',
        borderRadius: '50%',
        display: 'inline-block',
        lineHeight: '32px',
        fontWeight: 'bold',
        textAlign: 'center',
    },
}))

export const useAvailableServiceOptionStyles = makeStyles(() => ({
    optionRoot: {
        display: 'flex',
        flexDirection: 'row',
        justifyContent: 'flex-start',
        alignItems: 'flex-start',
        paddingTop: '10px',
    },
    plus: {
        cursor: 'pointer',
        display: 'flex',
        paddingTop: '3px',
    },
    textWrapper: {
        paddingLeft: '8px',
    },
    description: {
        fontSize: '13px',
        color: '#737373',
    },
}))

export const useServiceStyles = makeStyles(() => ({
    serviceNameText: {
        fontWeight: 700,
    },
    serviceExpanded: {
        margin: '15px 0px!important',
    },
    summaryWrapper: {
        display: 'flex',
        flexDirection: 'column',
    },
    removeServiceWrapper: {
        borderTop: '1px #e3e3e3 solid',
        paddingTop: '12px',
        marginTop: '12px',
    },
    removeServiceText: {
        cursor: 'pointer',
        width: 'fit-content',
        color: colors.primary.main,
        '&:hover': {
            filter: 'brightness(1.2)',
            transform: 'scale(1) rotate(0.2deg)',
        },
    },
    removeBtn: {
        width: 125,
        height: 38,
        fontSize: '16px',
        fontWeight: 500,
        textTransform: 'capitalize',
        marginTop: '16px',
    },
    editAddOn: {
        width: 'auto',
        height: 38,
        fontSize: '16px',
        fontWeight: 500,
        marginTop: '16px',
        marginRight: '10px',
        textTransform: 'none',
    },
}))

export const useSelectedOptionStyles = makeStyles(() => ({
    root: {
        paddingBottom: '2px',
        display: 'flex',
        flexDirection: 'row',
        justifyContent: 'flex-start',
        alignItems: 'center',
    },
    remove: {
        cursor: 'pointer',
        display: 'flex',
        paddingLeft: '8px',
    },
}))

export const useMobileAddAnotherServiceStyles = makeStyles(() => ({
    leftPanelBottom: {
        height: '62px',
        display: 'flex',
        position: 'fixed',
        bottom: '56px',
        width: '100%',
        backgroundColor: 'white',
        paddingTop: '10px',
    },
    leftPanelBottomBtn: {
        fontSize: '16px',
        fontWeight: 500,
        marginLeft: 'auto',
        marginRight: 'auto',
    },
}))
</file>

<file path="components/molecules/Services/SelectedServices/WithService.tsx">
import { LayoutListItem } from 'components/atoms/layout/LayoutListItem'
import { Box } from '@mui/material'
import { ServiceStaff } from 'components/molecules/Services/SelectedServices/ServiceStaff'
import { SelectedOptions } from 'components/molecules/Services/SelectedServices/SelectedOptions'
import { CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { useServiceStyles } from 'components/molecules/Services/SelectedServices/useStyles'
import { ServicePrice } from 'components/atoms/layout/service/ServicePrice'
import { ServiceCartBookableItemCaption } from 'components/atoms/layout/service/ServiceCartBookableItemCaption'
import { ReactNode } from 'react'

interface Props {
    bookableItem: CartBookableItem
    handleChange?: () => void
    selected?: boolean
    children?: ReactNode
    isReadMode?: boolean
    hideBorderBottom?: boolean
    addRightArrow?: boolean
}

export const WithService = ({
    bookableItem,
    handleChange,
    selected,
    children,
    isReadMode,
    hideBorderBottom,
    addRightArrow,
}: Props) => {
    const classes = useServiceStyles()
    return (
        <LayoutListItem
            onClick={handleChange}
            selected={selected}
            useDefaultCursor={isReadMode}
            hideBorderBottom={hideBorderBottom}
            addRightArrow={addRightArrow}
            useBottomShadow={true}
        >
            <Box>
                <Box className={classes.summaryWrapper}>
                    <ServiceCartBookableItemCaption bookableItem={bookableItem} useBold={selected === true} />
                    <ServicePrice bookableItem={bookableItem.item} />
                </Box>
                <SelectedOptions
                    bookableItem={bookableItem}
                    isReadMode={isReadMode}
                />
                <ServiceStaff bookableItem={bookableItem} />
                {children}
            </Box>
        </LayoutListItem>
    )
}
</file>

<file path="components/molecules/Services/SelectedServices/WorkshopPanel.tsx">
import { useMobile } from 'lib/utils/useMobile'
import { useContext, useEffect } from 'react'
import { LayoutContext } from 'components/atoms/layout/LayoutContext'
import { useSelectedServices } from 'lib/state/services'
import { useCartBookableItemListStaff } from 'lib/state/staff'
import { useFlowStep } from 'lib/state/booking-flow'
import { Step } from 'lib/state/booking-flow/types'
import { useCartMethods, useCartState } from 'lib/state/cart'
import { useCartStoreState } from 'lib/state/store'
import { useStaffTimes } from 'lib/state/staffTime'

export const WorkshopPanel = () => {
    const { isMobile } = useMobile()
    const layout = useContext(LayoutContext)
    const { selectedServicesStateValue } = useSelectedServices()
    const cartBookableItemListStaff = useCartBookableItemListStaff()
    const { setStep } = useFlowStep()
    const { isCartAvailableBookableItem } = useCartMethods()
    const cart = useCartState()
    const store = useCartStoreState()
    const { loadDatesAndTimes } = useStaffTimes()

    const getShowBottom = () => {
        return (
            selectedServicesStateValue
                .filter(x=>isCartAvailableBookableItem(x.item))
                .map((x) =>
                    cartBookableItemListStaff?.find(
                        (s) => s.cartBookableItemId === x.id
                    )
                )
                .filter((x) => x === undefined).length === 0
        )
    }

    const onRightPanelBtnClick = async () => {
        layout.setIsShowLoader(true)
        try {
            const servicesCount = selectedServicesStateValue.filter(x=>isCartAvailableBookableItem(x.item)).length
            if (servicesCount > 0) {
                await loadDatesAndTimes(cart!, store?.location!, new Date())
                await setStep(Step.ChooseDate)
            } else {
                await setStep(Step.PersonalInfo)
            }
        } finally {
            layout.setIsShowLoader(false)
        }
    }

    useEffect(() => {
        if (selectedServicesStateValue.length === 0) {
            setStep(Step.SelectService).finally() //noop
            return
        }
        // eslint-disable-next-line
    }, [])

    useEffect(() => {
        layout.setHideLeftPanel(isMobile)
        const showBottom = getShowBottom()
        layout.setShowBottom(showBottom)
        layout.setShowLeftBottom(showBottom)
        layout.setOnRightPanelBtnClick(onRightPanelBtnClick)
        // eslint-disable-next-line
    }, [isMobile, selectedServicesStateValue])
    return <></>
}
</file>

<file path="components/molecules/Services/SelectOptions/LeftPanel.tsx">
import { useSelectedServicesScreenStyles } from 'components/molecules/Services/SelectOptions/useStyles'
import { Box } from '@mui/material'
import { SelectedServices } from 'components/molecules/Services/SelectedServices/SelectedServices'
import React from 'react'

export const LeftPanel = () => {
    const classes = useSelectedServicesScreenStyles()
    return (
        <Box className={classes.servicesRoot}>
            <SelectedServices />
        </Box>
    )
}
</file>

<file path="components/molecules/Services/SelectOptions/MobileRightSection.tsx">
import { useMobile } from 'lib/utils/useMobile'
import { useFlowStep } from 'lib/state/booking-flow'
import { Step } from 'lib/state/booking-flow/types'
import { BackHeader } from 'components/atoms/layout/mobile/BackHeader'
import { MobileSelectedServiceSelector } from 'components/molecules/MobileSelectedServiceSelector'
import React from 'react'

export const MobileRightSection = () => {
    const { isMobile } = useMobile()
    const { setStep } = useFlowStep()

    const onBackHeaderClick = async () => {
        await setStep(Step.SelectService)
    }

    if (!isMobile) {
        return <></>
    }

    return (
        <>
            <BackHeader caption="Select and manage options" onClick={onBackHeaderClick} />
            <MobileSelectedServiceSelector />
        </>
    )
}
</file>

<file path="components/molecules/Services/SelectOptions/Option.tsx">
import { CartAvailableBookableItemOption } from '@boulevard/blvd-book-sdk/lib/carts/items'
import { SelectableListItem } from 'components/atoms/layout/selectable-list-item/SelectableListItem'
import { Caption } from 'components/atoms/layout/selectable-list-item/Caption'
import { Price } from 'components/atoms/layout/selectable-list-item/Price'
import { useOption } from 'components/molecules/Services/SelectOptions/useStyles'
import { PriceLabel } from 'lib/utils/formatCurrency'
import { getDurationTextFromNumber } from 'lib/utils/durationUtils'
import { CartBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { useCartMethods, useCartState } from 'lib/state/cart'
import { useSetActiveSelectedService } from 'lib/state/services'
import React from 'react'
import { SelectedButton } from 'components/molecules/Services/SelectOptions/SelectedButton'

interface Props {
    option: CartAvailableBookableItemOption
    bookableItem: CartBookableItem
}
export const Option = ({ option, bookableItem }: Props) => {
    const classes = useOption()
    const cart = useCartState()
    const { addAddon, removeAddon } = useCartMethods()
    const setActiveSelectedService = useSetActiveSelectedService()
    const addOption = async () => {
        if (!cart || !bookableItem) {
            return
        }

        const cartServices = await addAddon(cart, bookableItem, option)
        setActiveSelectedService(
            cartServices.services.find((x) => x.id === bookableItem.id)
        )
    }
    const removeOption = async () => {
        if (!cart || !bookableItem) {
            return
        }

        const cartServices = await removeAddon(cart, bookableItem, option)
        setActiveSelectedService(
            cartServices.services.find((x) => x.id === bookableItem.id)
        )
    }

    const selected = bookableItem?.selectedOptions?.find(
        (x) => x.id === option.id
    )

    return (
        <SelectableListItem
            captionComponent={
                <Caption
                    name={option.name}
                    durationText={getDurationTextFromNumber(
                        option.durationDelta
                    )}
                    useBold={true}
                />
            }
            priceComponent={
                <Price
                    classesCardItemPrice={classes.cardItemPrice}
                    priceStr={PriceLabel(option.priceDelta)}
                />
            }
            onSelectClick={addOption}
            btnName="Select"
            btnWidth={80}
            description={option.description as string | undefined}
            buttonComponent={
                selected && <SelectedButton removeOption={removeOption} />
            }
        />
    )
}
</file>

<file path="components/molecules/Services/SelectOptions/OptionsList.tsx">
import {
    useActiveSelectedService,
    useSelectedCartAvailableCategory,
} from 'lib/state/services'
import { Box, Typography } from '@mui/material'
import { useOptionsListStyles } from 'components/molecules/Services/SelectOptions/useStyles'
import { Option } from 'components/molecules/Services/SelectOptions/Option'
import React from 'react'
import { CartBookableItem } from '@boulevard/blvd-book-sdk/lib/carts/items'

export const OptionsList = () => {
    const classes = useOptionsListStyles()
    const activeSelectedService = useActiveSelectedService() as CartBookableItem
    const optionGroups = activeSelectedService?.item?.optionGroups
    const options = optionGroups?.flatMap((x) => x.options)
    return (
        <Box className={classes.root}>
            {options?.map((option) => (
                <Option
                    key={option.id}
                    option={option}
                    bookableItem={activeSelectedService}
                />
            ))}
            {!options?.length && (
                <Box className={classes.noOptionsAvailableWrapper}>
                    <Typography>No options available</Typography>
                </Box>
            )}
        </Box>
    )
}
</file>

<file path="components/molecules/Services/SelectOptions/RightPanel.tsx">
import { OptionsList } from 'components/molecules/Services/SelectOptions/OptionsList'
import React from 'react'
import { MobileRightSection } from 'components/molecules/Services/SelectOptions/MobileRightSection'
import { MobileAddAnotherService } from 'components/molecules/Services/SelectedServices/MobileAddAnotherService'

export const RightPanel = () => {
    return (
        <>
            <MobileRightSection />
            <OptionsList />
            <MobileAddAnotherService allowRemoveService={true} />
        </>
    )
}
</file>

<file path="components/molecules/Services/SelectOptions/SelectedButton.tsx">
import { Box, Typography } from '@mui/material'
import { TrashCan } from 'components/icons/TrashCan'
import { colors } from '../../../../constants/colors'
import React from 'react'
import { useSelectedButton } from 'components/molecules/Services/SelectOptions/useStyles'
import { useMobile } from 'lib/utils/useMobile'

interface Props {
    removeOption: () => void
}

export const SelectedButton = ({ removeOption }: Props) => {
    const { isMobile } = useMobile()
    const classes = useSelectedButton({ isMobile })
    return (
        <Box className={classes.selectedWrapper}>
            <Typography className={classes.selectedTxt}> Selected </Typography>
            <Box className={classes.svgWrapper}>
                <Box onClick={removeOption} className={classes.btn}>
                    <TrashCan color={colors.primary.main} />
                </Box>
            </Box>
        </Box>
    )
}
</file>

<file path="components/molecules/Services/SelectOptions/SelectOptionsScreen.tsx">
import React from 'react'
import WithLayout from 'components/atoms/layout/WithLayout'
import { LeftPanel } from 'components/molecules/Services/SelectOptions/LeftPanel'
import { RightPanel } from 'components/molecules/Services/SelectOptions/RightPanel'
import { useFlowStep } from 'lib/state/booking-flow'
import { Step } from 'lib/state/booking-flow/types'
import { WorkshopPanel } from 'components/molecules/Services/SelectOptions/WorkshopPanel'
import { useMobile } from 'lib/utils/useMobile'
import { useActiveSelectedService } from 'lib/state/services'

export const SelectOptionsScreen = () => {
    const { setStep } = useFlowStep()
    const { isMobile } = useMobile()
    const onRightPanelBtnClick = async () => {
        await setStep(Step.SelectedServices)
    }
    const activeSelectedService = useActiveSelectedService()
    const hasSelectedOptions = activeSelectedService?.selectedOptions && activeSelectedService?.selectedOptions?.length > 0
    return (
        <WithLayout
            isShowLoader={false}
            leftPanel={<LeftPanel />}
            rightPanel={<RightPanel />}
            showBottom={true}
            rightPanelCaption={isMobile ? '' : 'Select options'}
            rightPanelBtnCaption={hasSelectedOptions ? 'Continue' : 'Continue without options'}
            onRightPanelBtnClick={onRightPanelBtnClick}
            workshopPanel={<WorkshopPanel />}
        />
    )
}
</file>

<file path="components/molecules/Services/SelectOptions/useStyles.ts">
import { makeStyles } from '@mui/styles'

interface StylesProps {
    isMobile: boolean
}

export const useOptionsListStyles = makeStyles(() => ({
    root: {
        overflowY: 'scroll',
        position: 'sticky',
        height: 'calc(100% - 57px)',
        '&::-webkit-scrollbar': {
            display: 'none',
        },
    },
    noOptionsAvailableWrapper: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        marginTop: '15%',
    },
}))

export const useSelectedServicesScreenStyles = makeStyles(() => ({
    servicesRoot: {
        paddingTop: '1px',
        paddingBottom: '1px',
        height: 'calc(100% - 55px)',
    },
}))

export const useOption = makeStyles(() => ({
    cardItemPrice: {
        display: 'inline-block',
        textTransform: 'lowercase',
        fontSize: '14px',
        fontWeight: 'bold',
        '&:first-letter': {
            textTransform: 'uppercase',
        },
    },
}))

export const useSelectedButton = makeStyles(() => ({
    selectedWrapper: {
        marginLeft: (props: StylesProps) => (props.isMobile ? '0px' : 'auto'),
        marginRight: '32px',
        marginTop: (props: StylesProps) => (props.isMobile ? '21px' : '32px'),
        display: 'flex',
        flexDirection: 'row',
    },
    selectedTxt: {
        fontWeight: 700,
        fontSize: '14px',
        marginRight: '15px',
    },

    svgWrapper: {
        marginTop: '-3px',
        marginLeft: (props: StylesProps) => (props.isMobile ? 'auto' : '0px'),
    },

    btn: {
        cursor: 'pointer',
    },
}))
</file>

<file path="components/molecules/Services/SelectOptions/WorkshopPanel.tsx">
import { useMobile } from 'lib/utils/useMobile'
import { useContext, useEffect } from 'react'
import { LayoutContext } from 'components/atoms/layout/LayoutContext'
import { useSelectedServices } from 'lib/state/services'
import { Step } from 'lib/state/booking-flow/types'
import { useFlowStep } from 'lib/state/booking-flow'
import { useCartMethods } from 'lib/state/cart'

export const WorkshopPanel = () => {
    const { isMobile } = useMobile()
    const layout = useContext(LayoutContext)
    const { selectedServicesStateValue } = useSelectedServices()
    const { setStep } = useFlowStep()
    const { isCartAvailableBookableItem } = useCartMethods()
    const servicesCount = selectedServicesStateValue.filter(x=>isCartAvailableBookableItem(x.item)).length

    useEffect(() => {
        layout.setHideLeftPanel(isMobile)
        if (selectedServicesStateValue.length === 0) {
            setStep(Step.SelectService).finally() //noop
        }
        // eslint-disable-next-line
    }, [isMobile])

    useEffect(() => {
        if (selectedServicesStateValue.length > 0 && servicesCount === 0) {
            setStep(Step.SelectedServices).finally() //noop
        }
        // eslint-disable-next-line
    }, [selectedServicesStateValue])
    return <></>
}
</file>

<file path="components/molecules/Services/SelectService/CategoriesList.tsx">
import { Box } from '@mui/material'
import { useCategoriesListStyles } from 'components/molecules/Services/SelectService/useStyles'
import { Category } from 'components/molecules/Services/SelectService/Category'
import { CartAvailableCategory } from '@boulevard/blvd-book-sdk/lib/cart'

interface Props {
    availableCategories: CartAvailableCategory[]
}
export const CategoriesList = ({ availableCategories }: Props) => {
    const classes = useCategoriesListStyles()
    return (
        <Box className={classes.root}>
            {availableCategories?.map((availableCategory) => (
                <Category
                    key={availableCategory.id}
                    category={availableCategory}
                />
            ))}
        </Box>
    )
}
</file>

<file path="components/molecules/Services/SelectService/Category.tsx">
import { CartAvailableCategory } from '@boulevard/blvd-book-sdk/lib/cart'
import { LayoutListItem } from 'components/atoms/layout/LayoutListItem'
import { Box } from '@mui/material'
import { useCategoryStyles } from 'components/molecules/Services/SelectService/useStyles'
import {
    useSelectedCartAvailableCategory,
    useSetSelectedCartAvailableCategory,
} from 'lib/state/services'
import clsx from 'clsx'
import { useMobile } from 'lib/utils/useMobile'
import { useContext } from 'react'
import { LayoutContext } from 'components/atoms/layout/LayoutContext'

interface Props {
    category: CartAvailableCategory
}
export const Category = ({ category }: Props) => {
    const classes = useCategoryStyles()
    const { isMobile } = useMobile()
    const layout = useContext(LayoutContext)
    const setSelectedCartAvailableCategory =
        useSetSelectedCartAvailableCategory()
    const selectedCartAvailableCategory = useSelectedCartAvailableCategory()
    const onSelect = () => {
        setSelectedCartAvailableCategory(category)
        if (isMobile) {
            layout.setHideLeftPanel(true)
            layout.setHideRightPanel(false)
        }
    }
    const selected =
        selectedCartAvailableCategory?.id === category.id && !isMobile

    return (
        <LayoutListItem
            useBottomShadow={true}
            onClick={onSelect}
            selected={selected}
            addRightArrow={true}
        >
            <Box
                className={clsx(
                    classes.cardItemName,
                    (selected || isMobile) && classes.cardItemNameSelected
                )}
            >
                {category.name}
            </Box>
        </LayoutListItem>
    )
}
</file>

<file path="components/molecules/Services/SelectService/LeftPanel.tsx">
import { Box, Typography } from '@mui/material'
import React from 'react'
import { useSelectServiceScreenStyles } from 'components/molecules/Services/SelectService/useStyles'
import { theme } from 'styles/theme'
import { CategoriesList } from 'components/molecules/Services/SelectService/CategoriesList'
import { ServiceSearch } from 'components/molecules/Services/SelectService/ServiceSearch'
import { CartAvailableCategory } from '@boulevard/blvd-book-sdk/lib/cart'
import { useAvailableCategories } from 'lib/state/services'
import { useCartMethods } from 'lib/state/cart'
import Font from 'config/fonts.json'

interface Props {
    onSearchChange: (event) => void
    availableCategories: CartAvailableCategory[]
    searchString: string,
    clear: () => void
}

export const LeftPanel = ({
    onSearchChange,
    availableCategories,
    searchString,
    clear,
}: Props) => {
    const classes = useSelectServiceScreenStyles()
    const {isCartAvailableBookableItem} = useCartMethods()
    const initialAvailableCategories = useAvailableCategories()
    const isAnyServiceExist = initialAvailableCategories.flatMap(x=>x.availableItems).filter(x=>isCartAvailableBookableItem(x)).length > 0

    return (
        <Box className={classes.listWrapper}>
            <Box
                sx={{
                    p: 2,
                    borderBottom: `1px solid ${theme.palette.custom.lightGray}`,
                }}
            >
                <Typography
                    variant="h6"
                    component="span"
                    fontFamily={Font.headings_family}
                >
                    {isAnyServiceExist ? 'Select a service' : 'Select an item'}
                </Typography>
                <Box sx={{ mt: 1 }}>
                    <ServiceSearch
                        onChange={onSearchChange}
                        searchString={searchString}
                        clear={clear}
                        isAnyServiceExist={isAnyServiceExist}
                    />
                </Box>
            </Box>
            <CategoriesList availableCategories={availableCategories} />
        </Box>
    )
}
</file>

<file path="components/molecules/Services/SelectService/SelectServiceScreen.tsx">
import React, { useState } from 'react'
import { LeftPanel } from 'components/molecules/Services/SelectService/LeftPanel'
import WithLayout from 'components/atoms/layout/WithLayout'
import {
    useAvailableCategories,
    useSelectedCartAvailableCategory,
    useSetSelectedCartAvailableCategory,
} from 'lib/state/services'
import { ServicesList } from 'components/molecules/Services/SelectService/ServicesList'
import { WorkshopPanel } from 'components/molecules/Services/SelectService/WorkshopPanel'

export const SelectServiceScreen = () => {
    const [searchString, setSearchString] = useState('')
    const initialAvailableCategories = useAvailableCategories()
    const [availableCategories, setAvailableCategories] = useState(
        initialAvailableCategories
    )
    const setSelectedCartAvailableCategory =
        useSetSelectedCartAvailableCategory()
    const selectedCartAvailableCategory = useSelectedCartAvailableCategory()

    const onSearchChange = (event) => {
        const search = event.target.value
        setSearchString(search)
        const categories = initialAvailableCategories.filter(
            (x) =>
                search === '' ||
                x.availableItems.some(
                    (ai) =>
                        ai.name.toLowerCase().indexOf(search.toLowerCase()) !==
                        -1
                )
        )
        setAvailableCategories(categories)
        if (
            !categories.find((x) => x.id === selectedCartAvailableCategory?.id)
        ) {
            setSelectedCartAvailableCategory(categories[0])
        }
    }

    const clear = async () => {
        await setSelectedCartAvailableCategory(initialAvailableCategories[0])
        await setAvailableCategories(initialAvailableCategories)
        await setSearchString('')
    }

    return (
        <WithLayout
            isShowLoader={false}
            leftPanel={
                <LeftPanel
                    availableCategories={availableCategories}
                    onSearchChange={onSearchChange}
                    searchString={searchString}
                    clear={clear}
                />
            }
            rightPanel={<ServicesList searchString={searchString} />}
            workshopPanel={<WorkshopPanel />}
        />
    )
}
</file>

<file path="components/molecules/Services/SelectService/Service.tsx">
import { CartAvailableBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { useServiceStyles } from 'components/molecules/Services/SelectService/useStyles'
import { useCartMethods, useCartState } from 'lib/state/cart'
import { Step } from 'lib/state/booking-flow/types'
import { useFlowStep } from 'lib/state/booking-flow'
import { useCartStoreState } from 'lib/state/store'
import { useSetLastSelectedBookableItem } from 'lib/state/services'
import { useContext } from 'react'
import { LayoutContext } from 'components/atoms/layout/LayoutContext'
import { FlowType, useAppConfig } from 'lib/state/config'
import { ServiceAvailableBookableItem } from 'components/atoms/layout/service/ServiceAvailableBookableItem'
import { ServicePrice } from 'components/atoms/layout/service/ServicePrice'
import { SelectableListItem } from 'components/atoms/layout/selectable-list-item/SelectableListItem'

interface Props {
    bookableItem: CartAvailableBookableItem
}

export const Service = ({ bookableItem }: Props) => {
    const classes = useServiceStyles()
    const cart = useCartState()
    const {
        addService,
        loadSelectedServices,
        loadStoresForCartBookableItems,
        isCartAvailableBookableItem,
    } = useCartMethods()
    const { setStep } = useFlowStep()
    const cartStore = useCartStoreState()
    const layout = useContext(LayoutContext)
    const { getFlowType } = useAppConfig()
    const flowType = getFlowType()
    const setLastSelectedBookableItem = useSetLastSelectedBookableItem()
    const hasOptions = bookableItem.optionGroups?.length > 0
    const selectClickLocationBase = async () => {
        if (cart === undefined || cartStore?.location === undefined) {
            return false
        }
        layout.setIsShowLoader(true)
        const cartServices = await addService(cart, bookableItem)
        await loadSelectedServices(cart, cartServices.services)
        if (hasOptions) {
            await setStep(Step.SelectOptions)
        } else {
            await setStep(Step.SelectedServices)
        }
        return true
    }

    const onSelectClickLocationFirst = async () => {
        await selectClickLocationBase()
    }

    const onSelectClickServiceFirst = async () => {
        const success = await selectClickLocationBase()
        if (success) {
            return
        }
        setLastSelectedBookableItem(bookableItem)
        await loadStoresForCartBookableItems([], bookableItem)
        await setStep(Step.ChooseLocation)
    }

    const onSelectClick = async () => {
        if (flowType === FlowType.SelectLocationFirst) {
            await onSelectClickLocationFirst()
        } else {
            await onSelectClickServiceFirst()
        }
    }

    const btnName = hasOptions
        ? 'Select options'
        : isCartAvailableBookableItem(bookableItem)
        ? 'Select specialist'
        : 'Select'

    return (
        <SelectableListItem
            captionComponent={
                <ServiceAvailableBookableItem bookableItem={bookableItem} />
            }
            priceComponent={
                <ServicePrice
                    bookableItem={bookableItem}
                    classesCardItemPrice={classes.cardItemPrice}
                />
            }
            onSelectClick={onSelectClick}
            btnName={btnName}
            btnWidth={155}
            description={bookableItem.description}
        />
    )
}
</file>

<file path="components/molecules/Services/SelectService/ServiceSearch.tsx">
import React from 'react'
import { useMobile } from 'lib/utils/useMobile'
import { Box, InputBase, Paper } from '@mui/material'
import { StyledButton } from 'components/molecules/DefineLocation/theme'
import { Search } from 'components/icons/Search'
import { useServiceSearchStyles } from 'components/molecules/Services/SelectService/useStyles'
import { SearchClear } from 'components/icons/SearchClear'
import { colors } from 'constants/colors'

export const ServiceSearch = ({ onChange, searchString, clear, isAnyServiceExist }) => {
    const { isMobile } = useMobile()
    const classes = useServiceSearchStyles({ isMobile })
    return (
        <Box>
            <Paper component="form" className={classes.paper}>
                <Box className={classes.inputWrapper}>
                    <InputBase
                        onChange={onChange}
                        className={classes.inputSearch}
                        placeholder={isAnyServiceExist ? 'Search for a service' : 'Search for a item'}
                        value={searchString}
                    />
                    {searchString &&
                        <Box
                        sx={{
                            position: 'relative',
                            right: '10px',
                            margin: 'auto',
                        }}
                    >
                        <Box
                            sx={{
                                cursor: 'pointer',
                                textDecoration: 'underline',
                                color: colors.text.grey,
                                fontSize: '14px',
                            }}
                            onClick={clear}
                        >
                            {isMobile ? <SearchClear /> : 'Clear'}
                        </Box>
                    </Box>
                   }
                </Box>
                <StyledButton>
                    <Search />
                </StyledButton>
            </Paper>
        </Box>
    )
}
</file>

<file path="components/molecules/Services/SelectService/ServicesList.tsx">
import { useSelectedCartAvailableCategory } from 'lib/state/services'
import { CartAvailableBookableItem } from '@boulevard/blvd-book-sdk/lib/cart'
import { Service } from 'components/molecules/Services/SelectService/Service'
import { Box } from '@mui/material'
import { useServicesListStyles } from 'components/molecules/Services/SelectService/useStyles'
import { BackHeader } from 'components/atoms/layout/mobile/BackHeader'
import { useMobile } from 'lib/utils/useMobile'
import { useContext } from 'react'
import { LayoutContext } from 'components/atoms/layout/LayoutContext'

interface Props {
    searchString: string
}

export const ServicesList = ({ searchString }: Props) => {
    const classes = useServicesListStyles()
    const { isMobile } = useMobile()
    const layout = useContext(LayoutContext)
    const selectedCartAvailableCategory = useSelectedCartAvailableCategory()
    const cartAvailableBookableItemList =
        selectedCartAvailableCategory?.availableItems
            ?.filter(
                (x) =>
                    x.name.toLowerCase().indexOf(searchString.toLowerCase()) !==
                    -1
            )
            ?.map((x) => x as CartAvailableBookableItem)
    const onBackHeaderClick = () => {
        layout.setHideLeftPanel(false)
        layout.setHideRightPanel(true)
    }

    return (
        <>
            {isMobile && (
                <BackHeader
                    caption={selectedCartAvailableCategory?.name}
                    onClick={onBackHeaderClick}
                />
            )}
            <Box className={classes.root}>
                {cartAvailableBookableItemList?.map(
                    (cartAvailableBookableItem) => (
                        <Service
                            key={cartAvailableBookableItem.id}
                            bookableItem={cartAvailableBookableItem}
                        />
                    )
                )}
            </Box>
        </>
    )
}
</file>

<file path="components/molecules/Services/SelectService/useStyles.ts">
import { makeStyles } from '@mui/styles'
import { colors } from 'constants/colors'

export const useServicesListStyles = makeStyles(() => ({
    root: {
        overflowY: 'scroll',
        position: 'sticky',
        height: '100%',
        '&::-webkit-scrollbar': {
            display: 'none',
        },
    },
}))

export const useCategoriesListStyles = makeStyles(() => ({
    root: {
        overflowY: 'scroll',
        position: 'sticky',
        height: 'calc(100% - 113px)',
        '&::-webkit-scrollbar': {
            display: 'none',
        },
    },
}))

export const useSelectServiceScreenStyles = makeStyles(() => ({
    screenWrapper: {
        display: 'flex',
        alignItems: 'flex-start',
        flexDirection: 'row',
        justifyContent: 'space-between',
        width: '100%',
    },
    listWrapper: {
        height: 'calc(100% - 55px)',
    },
    topWrapper: {
        display: 'flex',
        alignItems: 'flex-start',
        flexDirection: 'row',
        paddingBottom: '9px',
    },
    rightColumn: {
        paddingTop: '84.3px',
        paddingRight: '48px',
        width: '350px',
    },
    summaryWrapper: {
        position: 'fixed',
        top: '155px',
        right: '14px',
    },
}))

export const useServiceStyles = makeStyles(() => ({
    cardItemPrice: {
        display: 'inline-block',
        textTransform: 'lowercase',
        fontSize: '14px',
        fontWeight: 'bold',
        '&:first-letter': {
            textTransform: 'uppercase',
        },
    },

    cardItemDescBlock: {
        paddingTop: '14px',
        marginBottom: '20px',
    },

    row: {
        display: 'flex',
        flexDirection: 'row',
    },
}))

export const useCategoryStyles = makeStyles(() => ({
    cardItemName: {
        textTransform: 'uppercase',
    },

    cardItemNameSelected: {
        fontWeight: 'bold',
    },
}))

export const useServiceSearchStyles = makeStyles(() => ({
    paper: {
        display: 'flex',
        alignItems: 'center',
        width: '100%',
        boxShadow: 'none',
        border: 'none',
    },
    inputWrapper: {
        width: 'calc(100% - 56px)',
        boxShadow: 'none',
        border: `1px solid ${colors.custom.lightGray}`,
        display: 'flex',
        justifyContent: 'space-between',
    },
    inputSearch: {
        padding: '2px 4px',
        boxShadow: 'none',
        height: 38,
        marginLeft: 16,
        flex: '1 0 1px',
        marginRight: 16,
    },
}))
</file>

<file path="components/molecules/Services/SelectService/WorkshopPanel.tsx">
import { useMobile } from 'lib/utils/useMobile'
import { useContext, useEffect } from 'react'
import { LayoutContext } from 'components/atoms/layout/LayoutContext'

export const WorkshopPanel = () => {
    const { isMobile } = useMobile()
    const layout = useContext(LayoutContext)

    useEffect(() => {
        layout.setHideLeftPanel(false)
        layout.setHideRightPanel(isMobile)
        // eslint-disable-next-line
    }, [isMobile])
    return <></>
}
</file>

<file path="components/molecules/FlowRouting.tsx">
import { useFlowRouting } from 'lib/state/flow-routing'

export const FlowRouting = () => {
    useFlowRouting()
    return <></>
}
</file>

<file path="components/molecules/GeoLocation.tsx">
import { useEffect, useState } from 'react'
import {
    useSetCurrentPositionName,
    useSetIsLocationAccessAllowed,
    useSetIsLocationAccessAnsweredByUser,
} from 'lib/state/currentPosition'
import { PositionCoordinates } from 'lib/state/currentPosition/types'
import MapboxClient from '@mapbox/mapbox-sdk'
import MapboxGeocoding from '@mapbox/mapbox-sdk/services/geocoding'
import { useConfig } from 'lib/sdk/hooks/useConfig'
import { useCartStoreState } from 'lib/state/store'
import { MapType, useAppConfig } from 'lib/state/config'

interface Props {
    onUserLocationChange: (positionCoordinates: PositionCoordinates) => void
}
export const GetLocation = ({ onUserLocationChange }: Props) => {
    const { mapboxApiAccessToken } = useConfig()
    const { getMapType } = useAppConfig()
    const mapType = getMapType()
    const setIsLocationAccessAllowed = useSetIsLocationAccessAllowed()
    const setIsLocationAccessAnsweredByUser =
        useSetIsLocationAccessAnsweredByUser()
    const setCurrentPositionName = useSetCurrentPositionName()
    const [geocodingClient] = useState(
        !!mapboxApiAccessToken && mapType === MapType.MapBox ? new MapboxGeocoding(
            new MapboxClient({ accessToken: mapboxApiAccessToken })
        ) : undefined
    )
    const selectedStore = useCartStoreState()

    useEffect(() => {
        if (selectedStore) {
            setIsLocationAccessAllowed(true)
            setIsLocationAccessAnsweredByUser(true)
            return
        }
        navigator.geolocation.getCurrentPosition(
            async (position: GeolocationPosition) => {
                onUserLocationChange({
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                })
                setIsLocationAccessAllowed(true)
                setIsLocationAccessAnsweredByUser(true)
                const params = {
                    query: [
                        position.coords.longitude,
                        position.coords.latitude,
                    ],
                    types: ['place'],
                }
                if (!geocodingClient) {
                    return
                }
                geocodingClient
                    .reverseGeocode(params)
                    .send()
                    .then((res) => {
                        const features = res?.body?.features
                        if (features && features.length > 0) {
                            setCurrentPositionName(features[0]?.place_name)
                        }
                    })
            },
            () => {
                setIsLocationAccessAnsweredByUser(true)
                setIsLocationAccessAllowed(false)
            },
            {
                enableHighAccuracy: false,
                timeout: 5000,
                maximumAge: Infinity,
            }
        )
        // eslint-disable-next-line
    }, [])

    return <></>
}
</file>

<file path="components/molecules/ServerError.tsx">
import { Typography, Box, Button } from '@mui/material'
import { theme } from 'styles/theme'
import { useErrorMessageType } from 'lib/state/error'
import { ErrorType } from 'lib/state/error/enums'
import { useResetStaffDatesStore } from 'lib/state/staffDate'
import { useResetStaffTimesState, useStaffTimes } from 'lib/state/staffTime'
import { Step } from 'lib/state/booking-flow/types'
import { useFlowStep } from 'lib/state/booking-flow'
import { useCartState } from 'lib/state/cart'
import { useCartStoreState } from 'lib/state/store'
import { useMobile } from 'lib/utils/useMobile'

export default function ServerError() {
    const { isMobile } = useMobile()
    const [errorMessageType, setErrorMessageType] = useErrorMessageType()
    const resetStaffDatesStore = useResetStaffDatesStore()
    const resetStaffTimesState = useResetStaffTimesState()
    const { loadDatesAndTimes } = useStaffTimes()
    const { setStep } = useFlowStep()
    const cart = useCartState()
    const store = useCartStoreState()

    const selectNewTime = async () => {
        resetStaffDatesStore()
        resetStaffTimesState()
        setTimeout(async () => {
            await loadDatesAndTimes(cart!, store?.location!, new Date())
            setErrorMessageType(ErrorType.NoError)
            await setStep(Step.ChooseDate)
        }, 400)
    }

    const onContinue = async () => {
        if (errorMessageType === ErrorType.TimeIsNoLongerAvailable) {
            selectNewTime()
        } else {
            setErrorMessageType(ErrorType.NoError)
        }
    }

    return (
        <Box
            sx={{
                position: 'fixed',
                width: '100%',
                top: !isMobile ? '46%' : '40%',
                textAlign: 'center',
                padding: theme.spacing(0, 2),
            }}
        >
            <Typography variant="h2" sx={{ pb: 2 }}>
                {errorMessageType === ErrorType.TimeIsNoLongerAvailable &&
                    'Sorry, that time has already been booked'}
                {errorMessageType === ErrorType.SomethingWentWrong &&
                    'Our apologies, but something went wrong booking that appointment'}
            </Typography>
            <Typography sx={{ pb: 5, fontSize: 16 }}>
                {errorMessageType === ErrorType.TimeIsNoLongerAvailable &&
                    'Please try again by selecting a new date and/or time.'}
                {errorMessageType === ErrorType.SomethingWentWrong &&
                    'Please try again.'}
            </Typography>
            <Button
                onClick={onContinue}
                sx={{
                    width: 178,
                    height: 38,
                    borderColor: '#C3C7CF',
                    color: '#33343C',
                    textTransform: 'capitalize',
                    fontSize: '14px',
                    fontWeight: 'normal',
                    border: '1px solid #C3C7CF',
                    backgroundColor: '#FFFFFF',
                    '&:hover': {
                        backgroundColor: '#F9F9FB',
                    },
                }}
            >
                {errorMessageType === ErrorType.TimeIsNoLongerAvailable
                    ? 'Select a new date/time'
                    : 'Try again'}
            </Button>
        </Box>
    )
}
</file>

<file path="config/brand.json">
{
    "name": "Create-Booking-Flow",
    "description": "Create-Booking-Flow",
    "icon": "/images/icon.png"
}
</file>

<file path="config/colors.json">
{
    "primary": {
        "main": "#FF7D65",
        "dark": "#FF5536",
        "light": "#FF9987",
        "contrastText": "#FFFFFF"
    },
    "secondary": {
        "main": "#FFFFFF"
    },
    "text": {
        "primary": "#333F48",
        "secondary": "#333F48CC",
        "disabled": "#C2C6C9",
        "hint": "#C6A992"
    },
    "custom": {
        "lightGray": "#D9DDE5"
    }
}
</file>

<file path="config/fonts.json">
{
    "headings_family": "Cabin, sans-serif",
    "headings_url": "https://fonts.googleapis.com/css2?family=Playfair+Display:ital@0;1&display=swap",

    "body_family": "Roboto",
    "body_url": null,

    "mono_family": "monospace",
    "mono_url": null
}
</file>

<file path="constants/colors.ts">
import { Colors } from 'enums/colors'

export const colors = {
    primary: {
        main: '#FF7D65',
        dark: '#FF5536',
        light: '#FF9987',
        contrastText: '#FFFFFF',
    },
    secondary: {
        main: '#CCCCCC',
    },
    text: {
        primary: '#333F48',
        secondary: '#333F48CC',
        disabled: '#C2C6C9',
        hint: '#C6A992',
        grey: '#6E717D',
    },
    custom: {
        [Colors.lightGray]: '#D9DDE5',
    },
    dropDown: {
        borderColor: '#33343C',
    },
    stepScreen: {
        backgroundColor: '#F9F9F9',
    },
    piercingLocation: {
        color: '#33343C',
    },
    map: {
        backgroundColor: '#f1f1f1ed',
    },
}
</file>

<file path="constants/regexps.ts">
export const phoneMask = [
    '(',
    /[1-9]/,
    /\d/,
    /\d/,
    ')',
    ' ',
    /\d/,
    /\d/,
    /\d/,
    '-',
    /\d/,
    /\d/,
    /\d/,
    /\d/,
]
export const phoneRegExp =
    /^((\[1-9]{1,4}[ -]?)|(\([0-9]{2,3}\)[ -]?)|([0-9]{2,4})[ -]?)*?[0-9]{3,4}[ -]?[0-9]{3,4}$/

export const cardNumberMask = [
    /[0-9]/,
    /[0-9]/,
    /[0-9]/,
    /[0-9]/,
    ' ',
    /[0-9]/,
    /[0-9]/,
    /[0-9]/,
    /[0-9]/,
    ' ',
    /[0-9]/,
    /[0-9]/,
    /[0-9]/,
    /[0-9]/,
    ' ',
    /[0-9]/,
    /[0-9]/,
    /[0-9]/,
    /[0-9]/,
]

export const cardExpirationDateMask = [/[0-9]/, /[0-9]/, '/', /[0-9]/, /[0-9]/]

export const cvcMask = [/[0-9]/, /[0-9]/, /[0-9]/]
</file>

<file path="constants/styles.ts">
import { colors } from './colors'
import { Theme } from '@mui/material'

export const stepScreen = (theme: Theme) => {
    return {
        root: (isMobile: boolean) => {
            return {
                minHeight: '100%',
                padding: theme.spacing(
                    !isMobile ? 6 : 17,
                    !isMobile ? 10 : 2,
                    !isMobile ? 6 : 2
                ),
            }
        },
        blurScreen: {
            '-webkit-filter': 'blur(20px)',
            '-moz-filter': 'blur(20px)',
            ' -o-filter': 'blur(20px)',
            '-ms-filter': 'blur(20px)',
            filter: 'blur(20px)',
            opacity: '0.6',
            'pointer-events': 'none',
        },
        loader: {
            'z-index': '1',
            top: '50%',
            left: 'calc(50% - 30px)',
            '-webkit-filter': 'blur(1px)',
            '-moz-filter': 'blur(1px)',
            '-o-filter': 'blur(1px)',
            '-ms-filter': 'blur(1px)',
            filter: 'blur(1px)',
            opacity: '1',
        },
    }
}
</file>

<file path="enums/colors.ts">
export enum Colors {
    lightGray = 'lightGray',
}
</file>

<file path="lib/analytics-api/analyticsService.ts">
import {
    AppointmentBookingConfirmed,
    AppointmentLocationSelected,
    AppointmentTimeSelected,
} from 'lib/analytics-api/types'
import { useGoogleAnalytics } from 'lib/analytics-api/googleAnalyticsUtils'

export const useAnalyticsService = () => {
    const ga = useGoogleAnalytics()
    const gaAppointmentLocationSelected = ga.appointmentLocationSelected
    const gaAppointmentTimeSelected = ga.appointmentTimeSelected
    const gaAppointmentBookingConfirmed = ga.appointmentBookingConfirmed

    const appointmentLocationSelected = async (
        appointmentLocationSelected: AppointmentLocationSelected
    ): Promise<void> => {
        Promise.all([
            gaAppointmentLocationSelected(
                appointmentLocationSelected.location?.name as string
            ),
        ]).catch()
    }

    const appointmentTimeSelected = async (
        appointmentTimeSelected: AppointmentTimeSelected
    ): Promise<void> => {
        Promise.all([
            gaAppointmentTimeSelected(
                appointmentTimeSelected.location?.name as string
            ),
        ]).catch()
    }

    const appointmentBookingConfirmed = async (
        appointmentBookingConfirmed: AppointmentBookingConfirmed
    ): Promise<void> => {
        Promise.all([
            gaAppointmentBookingConfirmed(
                appointmentBookingConfirmed.serviceName
            ),
        ]).catch()
    }

    return {
        appointmentLocationSelected: appointmentLocationSelected,
        appointmentTimeSelected: appointmentTimeSelected,
        appointmentBookingConfirmed: appointmentBookingConfirmed,
    }
}
</file>

<file path="lib/analytics-api/googleAnalyticsUtils.ts">
export const useGoogleAnalytics = () => {
    const googleAnalyticsKey = process.env.GOOGLE_ANALYTICS_KEY
    const pageView = (url: URL): void => {
        if (!googleAnalyticsKey) {
            return
        }
        window.gtag('config', googleAnalyticsKey, {
            page_path: url,
        })
    }

    const event = async (action: string, label: any): Promise<void> => {
        if (!googleAnalyticsKey) {
            return
        }
        window.gtag('event', action, {
            event_category: 'BLVD',
            event_label: label,
        })
    }

    const appointmentLocationSelected = (storeName: string): Promise<void> => {
        return event('Store Selected ', `Store: ${storeName}`)
    }

    const appointmentTimeSelected = (storeName: string): Promise<void> => {
        return event('Time Selected ', `Store: ${storeName}`)
    }

    const appointmentBookingConfirmed = (
        serviceName: string
    ): Promise<void> => {
        return event('Appointment Confirmed ', `Service: ${serviceName}`)
    }

    return {
        pageView: pageView,
        googleAnalyticsKey: googleAnalyticsKey,
        appointmentLocationSelected: appointmentLocationSelected,
        appointmentTimeSelected: appointmentTimeSelected,
        appointmentBookingConfirmed: appointmentBookingConfirmed,
    }
}
</file>

<file path="lib/analytics-api/types.ts">
import { Location } from '@boulevard/blvd-book-sdk/lib/locations'

export interface AppointmentBase {
    location: Location | undefined
}

export interface AppointmentLocationSelected extends AppointmentBase {}

export interface AppointmentTimeSelected extends AppointmentBase {}

export interface AppointmentBookingConfirmed extends AppointmentBase {
    serviceName: string
}
</file>

<file path="lib/geojson/GeoJSON.ts">
// noinspection DuplicatedCode
export class GeoJSON {
    private geomAttrs: any[] = []
    private geoms = [
        'Point',
        'MultiPoint',
        'LineString',
        'MultiLineString',
        'Polygon',
        'MultiPolygon',
        'GeoJSON',
    ]

    // Allow user to specify default parameters
    default: object = {
        doThrows: {
            invalidGeometry: false,
        },
    }

    constructor() {}

    InvalidGeometryError(...arguments_arr: any[]): Error {
        const args =
            1 <= arguments_arr.length ? [].slice.call(arguments_arr, 0) : []
        const item = args.shift()
        const params = args.shift()

        throw Error(
            'Invalid Geometry: ' +
                'item: ' +
                JSON.stringify(item) +
                ', params: ' +
                JSON.stringify(params)
        )
    }

    errors: object = {
        InvalidGeometryError: this.InvalidGeometryError,
    }

    public isGeometryValid = function (geometry: any): boolean {
        return !(!geometry || !Object.keys(geometry).length)
    }

    public parse(
        objects: [] | object,
        params: object,
        callback?: Function
    ): any {
        let geojson,
            settings = this.applyDefaults(params, this.default),
            propFunc

        this.geomAttrs.length = 0 // Reset the list of geometry fields
        this.setGeom(settings)
        propFunc = this.getPropFunction(settings)

        if (Array.isArray(objects)) {
            geojson = { type: 'FeatureCollection', features: [] }
            for (let item of objects) {
                geojson.features.push(
                    this.getFeature({
                        item: item,
                        params: settings,
                        propFunc: propFunc,
                    })
                )
            }
            this.addOptionals(geojson, settings)
        } else {
            geojson = this.getFeature({
                item: objects,
                params: settings,
                propFunc: propFunc,
            })
            this.addOptionals(geojson, settings)
        }

        if (callback && typeof callback === 'function') {
            callback(geojson)
        } else {
            return geojson
        }
    }

    // Adds default settings to user-specified params
    // Does not overwrite any settings--only adds defaults
    // the the user did not specify
    private applyDefaults(params: object, defaults: object): object {
        let settings = params || {}

        for (let setting in settings) {
            if (defaults.hasOwnProperty(setting) && !settings[setting]) {
                settings[setting] = defaults[setting]
            }
        }

        return settings
    }

    // Adds the optional GeoJSON properties crs and bbox
    // if they have been specified
    private addOptionals(geojson, settings) {
        if (settings.crs && this.checkCRS(settings.crs)) {
            if (settings.isPostgres) {
                geojson.geometry.crs = settings.crs
            } else {
                geojson.crs = settings.crs
            }
        }
        if (settings.bbox) {
            geojson.bbox = settings.bbox
        }
        if (settings.extraGlobal) {
            geojson.properties = {}
            for (let key in settings.extraGlobal) {
                geojson.properties[key] = settings.extraGlobal[key]
            }
        }
    }

    // Verify that the structure of CRS object is valid
    private checkCRS(crs): boolean {
        if (crs.type === 'name') {
            if (crs.properties && crs.properties.name) {
                return true
            } else {
                throw new Error(
                    'Invalid CRS. Properties must contain "name" key'
                )
            }
        } else if (crs.type === 'link') {
            if (crs.properties && crs.properties.href && crs.properties.type) {
                return true
            } else {
                throw new Error(
                    'Invalid CRS. Properties must contain "href" and "type" key'
                )
            }
        } else {
            throw new Error(
                'Invald CRS. Type attribute must be "name" or "link"'
            )
        }
    }

    // Moves the user-specified geometry parameters
    // under the `geom` key in param for easier access
    private setGeom(params: any): void {
        params.geom = {}

        for (let param in params) {
            if (
                params.hasOwnProperty(param) &&
                this.geoms.indexOf(param) !== -1
            ) {
                params.geom[param] = params[param]
                delete params[param]
            }
        }

        this.setGeomAttrList(params.geom)
    }

    // Adds fields which contain geometry data
    // to geomAttrs. This list is used when adding
    // properties to the features so that no geometry
    // fields are added the properties key
    private setGeomAttrList(params: any): void {
        for (let param in params) {
            if (params.hasOwnProperty(param)) {
                if (typeof params[param] === 'string') {
                    this.geomAttrs.push(params[param])
                } else if (typeof params[param] === 'object') {
                    // Array of coordinates for Point
                    this.geomAttrs.push(params[param][0])
                    this.geomAttrs.push(params[param][1])
                }
            }
        }

        if (this.geomAttrs.length === 0) {
            throw new Error('No geometry attributes specified')
        }
    }

    // Creates a feature object to be added
    // to the GeoJSON features array
    private getFeature(args): object {
        let item = args.item,
            params = args.params,
            propFunc = args.propFunc

        let feature = { type: 'Feature' }

        let that = this

        feature['geometry'] = this.buildGeom(item, params)
        feature['properties'] = propFunc.call(item, that)

        return feature
    }

    private isNested(val) {
        return /^.+\..+$/.test(val)
    }

    // Assembles the `geometry` property
    // for the feature output
    private buildGeom(item, params): any {
        let geom = {}
        //   attr;

        for (let gtype in params.geom) {
            let val = params.geom[gtype]

            // Geometry parameter specified as: {Point: 'coords'}
            if (typeof val === 'string' && item.hasOwnProperty(val)) {
                if (gtype === 'GeoJSON') {
                    geom = item[val]
                } else {
                    geom['type'] = gtype
                    geom['coordinates'] = item[val]
                }
            } else if (typeof val === 'object' && !Array.isArray(val)) {
                /* Handle things like:
                  Polygon: {
                    northeast: ['lat', 'lng'],
                    southwest: ['lat', 'lng']
                  }
                  */
                /*jshint loopfunc: true */
                let points = Object.keys(val).map(function (key) {
                    let order = val[key]
                    let newItem = item[key]
                    return this.buildGeom(newItem, { geom: { Point: order } })
                })
                geom['type'] = gtype
                /*jshint loopfunc: true */
                geom['coordinates'] = []
                geom['coordinates'] = geom['coordinates'].concat(
                    points.map((p) => {
                        return p.coordinates
                    })
                )
            } else if (
                // Geometry parameter specified as: {Point: ['lat', 'lng', 'alt']}
                Array.isArray(val) &&
                item.hasOwnProperty(val[0]) &&
                item.hasOwnProperty(val[1]) &&
                item.hasOwnProperty(val[2])
            ) {
                geom['type'] = gtype
                geom['coordinates'] = [
                    Number(item[val[1]]),
                    Number(item[val[0]]),
                    Number(item[val[2]]),
                ]
            } else if (
                // Geometry parameter specified as: {Point: ['lat', 'lng']}
                Array.isArray(val) &&
                item.hasOwnProperty(val[0]) &&
                item.hasOwnProperty(val[1])
            ) {
                geom['type'] = gtype
                geom['coordinates'] = [
                    Number(item[val[1]]),
                    Number(item[val[0]]),
                ]
            } else if (
                // Geometry parameter specified as: {Point: ['container.lat', 'container.lng', 'container.alt']}
                Array.isArray(val) &&
                this.isNested(val[0]) &&
                this.isNested(val[1]) &&
                this.isNested(val[2])
            ) {
                let coordinates: any[] = []
                for (let i = 0; i < val.length; i++) {
                    // i.e. 0 and 1
                    const paths = val[i].split('.')
                    let itemClone = item
                    for (let j = 0; j < paths.length; j++) {
                        if (!itemClone.hasOwnProperty(paths[j])) {
                            return false
                        }
                        itemClone = itemClone[paths[j]] // Iterate deeper into the object
                    }
                    coordinates[i] = itemClone
                }
                geom['type'] = gtype
                geom['coordinates'] = [
                    Number(coordinates[1]),
                    Number(coordinates[0]),
                    Number(coordinates[2]),
                ]
            }

            // Geometry parameter specified as: {Point: ['container.lat', 'container.lng']}
            else if (
                Array.isArray(val) &&
                this.isNested(val[0]) &&
                this.isNested(val[1])
            ) {
                const coordinates: any[] = []
                for (let i = 0; i < val.length; i++) {
                    // i.e. 0 and 1
                    const paths = val[i].split('.')
                    let itemClone = item
                    for (let j = 0; j < paths.length; j++) {
                        if (!itemClone.hasOwnProperty(paths[j])) {
                            return false
                        }
                        itemClone = itemClone[paths[j]] // Iterate deeper into the object
                    }
                    coordinates[i] = itemClone
                }
                geom['type'] = gtype
                geom['coordinates'] = [
                    Number(coordinates[1]),
                    Number(coordinates[0]),
                ]
            } else if (
                // Geometry parameter specified as: {Point: [{coordinates: [lat, lng]}]}
                Array.isArray(val) &&
                val[0].constructor.name === 'Object' &&
                Object.keys(val[0])[0] === 'coordinates'
            ) {
                geom['type'] = gtype
                geom['coordinates'] = [
                    Number(item.coordinates[val[0].coordinates.indexOf('lng')]),
                    Number(item.coordinates[val[0].coordinates.indexOf('lat')]),
                ]
            }
        }

        if (
            params.doThrows &&
            params.doThrows.invalidGeometry &&
            !this.isGeometryValid(geom)
        ) {
            throw this.InvalidGeometryError(item, params)
        }

        return geom
    }

    // Returns the function to be used to
    // build the properties object for each feature
    private getPropFunction(params) {
        let func

        if (!params.exclude && !params.include) {
            func = function (properties, that) {
                for (const attr in this) {
                    if (
                        this.hasOwnProperty(attr) &&
                        that.geomAttrs.indexOf(attr) === -1
                    ) {
                        properties[attr] = this[attr]
                    }
                }
            }
        } else if (params.include) {
            func = function (properties) {
                params.include.forEach(function (attr) {
                    properties[attr] = this[attr]
                }, this)
            }
        } else if (params.exclude) {
            func = function (properties, that) {
                for (const attr in this) {
                    if (
                        this.hasOwnProperty(attr) &&
                        that.geomAttrs.indexOf(attr) === -1 &&
                        params.exclude.indexOf(attr) === -1
                    ) {
                        properties[attr] = this[attr]
                    }
                }
            }
        }

        return function (that) {
            const properties = {}

            func.call(this, properties, that)

            if (params.extra) {
                this.addExtra(properties, params.extra)
            }
            return properties
        }
    }

    // Adds data contained in the `extra`
    // parameter if it has been specified
    private addExtra(properties, extra) {
        for (const key in extra) {
            if (extra.hasOwnProperty(key)) {
                properties[key] = extra[key]
            }
        }

        return properties
    }
}
</file>

<file path="lib/sdk/hooks/useConfig.ts">
import { DateTimeType, DisplayAppSettingsPopup, FlowType, MapType } from 'lib/state/config'

export const useConfig = () => {
    const mapboxApiAccessToken = process.env.NEXT_PUBLIC_MAPBOX_TOKEN
    const googleMapsApiAccessToken =
        process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY ?? ''
    const mapType =
        process.env.NEXT_PUBLIC_MAP_TYPE === 'Google' ? MapType.Google : (process.env.NEXT_PUBLIC_MAP_TYPE === 'None' ? MapType.None : MapType.MapBox)
    const flowType =
        process.env.NEXT_PUBLIC_FLOW_TYPE === 'SelectServiceFirst' ?
            FlowType.SelectServiceFirst : FlowType.SelectLocationFirst
    const dateTimeType =
        process.env.NEXT_PUBLIC_DATE_TIME_TYPE === 'ShowTimeForManyDays' ?
            DateTimeType.ShowTimeForManyDays : DateTimeType.ShowTimeForOneDay
    const displayAppSettings =
        process.env.NEXT_PUBLIC_DISPLAY_APP_SETTINGS === 'Yes' ?
            DisplayAppSettingsPopup.Yes : DisplayAppSettingsPopup.No
    return {
        mapboxApiAccessToken: mapboxApiAccessToken,
        googleMapsApiAccessToken: googleMapsApiAccessToken,
        mapType: mapType,
        flowType: flowType,
        dateTimeType: dateTimeType,
        displayAppSettings: displayAppSettings,
    }
}
</file>

<file path="lib/sdk/hooks/useStores.ts">
import { Location } from '@boulevard/blvd-book-sdk/lib/locations'
import { useSetStoresState, useStoresState } from 'lib/state/store'
import haversine from 'haversine'
import { roundNumber } from 'lib/utils/numberUtils'
import { Store } from 'lib/state/store/types'
import { useCurrentPosition } from 'lib/state/currentPosition'
import { PositionCoordinates } from 'lib/state/currentPosition/types'

export const useStores = () => {
    const currentPosition = useCurrentPosition()
    const stores = useStoresState()
    const setStores = useSetStoresState()

    //const round
    const getDistanceByPosition = (
        userPosition: PositionCoordinates,
        storePosition: haversine.CoordinateLongitudeLatitude
    ): number => {
        const distance = haversine(userPosition, storePosition, {
            unit: 'mile',
        })
        return roundNumber(distance, 1)
    }

    const getDistance = (
        storePosition: haversine.CoordinateLongitudeLatitude
    ): number => {
        return getDistanceByPosition(currentPosition, storePosition)
    }

    const getStoreFromLocation = (location: Location): Store => {
        let lat: number = 0
        let lng: number = 0

        if (location.coordinates?.latitude && location.coordinates?.longitude) {
            lat = location.coordinates?.latitude
            lng = location.coordinates?.longitude
        }
        const distance = getDistance({
            latitude: lat,
            longitude: lng,
        })
        return {
            distance: distance,
            lng: lng,
            lat: lat,
            location: location,
        } as Store
    }

    const setLocations = (locations: Location[]) => {
        const result = locations.map((l) => getStoreFromLocation(l))
        //sort stores by distance asc
        result.sort((a, b) =>
            a.distance > b.distance ? 1 : b.distance > a.distance ? -1 : 0
        )
        setStores(result)
    }

    return {
        stores: stores,
        getStoreFromLocation: getStoreFromLocation,
        setLocations: setLocations,
        getDistanceByPosition: getDistanceByPosition,
    }
}
</file>

<file path="lib/sdk/hooks/useUrlParams.ts">
import queryString from 'query-string'
import { useRouter } from 'next/router'

export interface UrlParams {
    ref: string
    storeId: string
    shopperId: string
}

export const useUrlParams = () => {
    const router = useRouter()

    const getUrlParams = (): UrlParams => {
        const parsedUrl = queryString.parseUrl(
            `https://anydomain.com${router.asPath}`,
            { parseFragmentIdentifier: true }
        )
        const { ref, storeId, shopperId } = parsedUrl.query
        return { ref, storeId, shopperId } as UrlParams
    }

    return {
        getUrlParams: getUrlParams,
    }
}
</file>

<file path="lib/sdk/blvd.ts">
import { Blvd, PlatformTarget } from '@boulevard/blvd-book-sdk'

const businessId = process.env.NEXT_PUBLIC_BLVD_BUSINESS_ID
const apiKey = process.env.NEXT_PUBLIC_BLVD_API_KEY
export const live = 'live'
export const defaultLocationExternalId =
    process.env.NEXT_PUBLIC_BLVD_DEFAULT_LOCATION_EXTERNAL_ID

// safety net for misconfiguration
if (!businessId || !apiKey) {
    throw new Error(
        'Either NEXT_PUBLIC_BLVD_BUSINESS_ID or NEXT_PUBLIC_BLVD_API_KEY are undefined'
    )
}

const client =
    process.env.NEXT_PUBLIC_BLVD_PLATFORM === live
        ? new Blvd(apiKey, businessId, PlatformTarget.Live)
        : new Blvd(apiKey, businessId)

export { client as Blvd }
</file>

<file path="lib/state/booking-answers/index.ts">
import { atom, useRecoilState, useRecoilValue, useSetRecoilState } from 'recoil'
import { BookingAnswer } from './types'

const bookingAnswersState = atom<Array<BookingAnswer>>({
    key: 'bookingAnswersState',
    default: [],
})

export const useBookingAnswersState = () => useRecoilState(bookingAnswersState)
export const useBookingAnswers = () => useRecoilValue(bookingAnswersState)
export const useSetBookingAnswersState = () =>
    useSetRecoilState(bookingAnswersState)
</file>

<file path="lib/state/booking-answers/types.ts">
export interface BookingAnswer {
    questionId: string
    answer: any
}
</file>

<file path="lib/state/booking-flow/index.ts">
import {
    atom,
    useRecoilCallback,
    useRecoilValue,
    useSetRecoilState,
} from 'recoil'
import { Types, Step, initialStep } from 'lib/state/booking-flow/types'
import { useRouter } from 'next/router'

const defaultFlowStep: Types = {
    step: Step.LoadingStep,
}

const flowStepState = atom<Types>({
    key: 'flowStep',
    default: defaultFlowStep,
})

export default flowStepState

export const useFlowStepState = () => useRecoilValue(flowStepState)
export const useSetFlowStepState = () => useSetRecoilState(flowStepState)

export const useFlowStep = () => {
    const router = useRouter()
    const currentFlowStep = useRecoilValue(flowStepState)
    const setRecoilStep = useRecoilCallback(
        ({ set }) =>
            (step: Step) => {
                set(flowStepState, (oldValue: Types) => {
                    return { ...oldValue, step: step }
                })
            },
        []
    )

    const setStepForce = async (step: Step) => {
        if (step === initialStep) {
            await router.push(`#`)
        } else {
            await router.push(`#${Step[step]}`)
        }
    }

    const setStep = async (step: Step) => {
        if (currentFlowStep.step === step) {
            return
        }
        await setStepForce(step)
    }

    return {
        currentFlowStep,
        setStep: setStep,
        setRecoilStep,
        setStepForce: setStepForce,
    }
}
</file>

<file path="lib/state/booking-flow/types.ts">
export enum Step {
    LoadingStep,
    ChooseLocation,
    SelectService,
    SelectOptions,
    SelectedServices,
    ChooseDate,
    PersonalInfo,
    PayAndConfirm,
    BookingSuccess,
}

export interface Types {
    step: Step
}

export const initialStep: Step = Step.LoadingStep
</file>

<file path="lib/state/cart/index.ts">
// @ts-nocheck - FIXME - Types in this file are broken, and this needs a heavy refactor
import {
    atom,
    useRecoilCallback,
    useRecoilValue,
    useSetRecoilState,
} from 'recoil'
import { getPersistedState, makePersistedSetRecoilState } from '../persistence'
import { SuccessBookingCartInfo } from './types'
import { Location } from '@boulevard/blvd-book-sdk/lib/locations'
import {
    Cart,
    CartAvailableBookableItem,
    CartAvailableCategory,
    CartBookableItem,
    CartBookableTime,
} from '@boulevard/blvd-book-sdk/lib/cart'
import { Blvd } from 'lib/sdk/blvd'
import { useSetBookingAnswersState } from 'lib/state/booking-answers'
import { useSetPersonalInformationState } from 'lib/state/personal-info'
import { useStores } from 'lib/sdk/hooks/useStores'
import {
    useAvailableBookableItemStoresState,
    useResetCartStoreState,
    useSetAvailableBookableItemStoresState,
    useSetCartStoreState,
} from 'lib/state/store'
import { PersonalInformation } from 'lib/state/personal-info/types'
import { cartTimeToDate } from 'lib/utils/formatDateFns'
import { useAnalyticsService } from 'lib/analytics-api/analyticsService'
import { AvailableBookableItemStores, Store } from 'lib/state/store/types'
import { useResetStaffDatesStore } from 'lib/state/staffDate'
import {
    useResetSelectedStaffTimeState,
    useResetStaffTimesState,
} from 'lib/state/staffTime'
import {
    useMapView,
    useResetLocationSelectedStoreState,
    useSetLocationSelectedStoreState,
    useSetMapViewportState,
} from 'lib/state/location'
import {
    defaultZoom,
    mapBoxFlyToInterpolator,
    mapBoxTransitionDuration,
} from 'lib/utils/locationUtils'
import {
    useResetSelectedCartAvailableCategory,
    useSelectedServices,
    useSetActiveSelectedService,
    useSetAvailableCategories,
    useSetSelectedCartAvailableCategory,
} from 'lib/state/services'
import {
    CartAvailableBookableItemLocationVariant,
    CartAvailableBookableItemOption,
    CartAvailableItem,
    CartAvailablePurchasableItem,
} from '@boulevard/blvd-book-sdk/lib/carts/items'
import { CartBookableItemStaff, Staff } from 'lib/state/staff/types'
import {
    cartAvailableBookableItemStaffVariantToStaff,
    useSetAllowChooseStaffError,
    useSetBookableStaffVariants,
    useSetCartBookableItemListStaff,
} from 'lib/state/staff'
import { CartBookingQuestion } from '@boulevard/blvd-book-sdk/lib/carts/bookingQuestions'

const CART_ID_KEY = 'CART_ID'

const cartState = atom<Cart | undefined>({
    key: 'cartState',
    default: undefined,
})

const successBookingCartInfoState = atom<SuccessBookingCartInfo | undefined>({
    key: 'successBookingCartInfoState',
    default: undefined,
})

export const cartIdState = atom<string | undefined>({
    key: 'cartIdState',
    default: getPersistedState(CART_ID_KEY) ?? undefined,
})

export const defaultBlvdLocationState = atom<Location | undefined>({
    key: 'defaultBlvdLocationState',
    default: undefined,
})

export const cartDataLoaded = atom<boolean>({
    key: 'cartDataLoaded',
    default: false,
})

export const useCartState = () => useRecoilValue(cartState)
export const useSetCartState = () => useSetRecoilState(cartState)

export const useCartIdState = () => useRecoilValue(cartIdState)
export const useSetCartIdState = makePersistedSetRecoilState(
    CART_ID_KEY,
    cartIdState
)

export const useDefaultBlvdLocationState = () =>
    useRecoilValue(defaultBlvdLocationState)
export const useSetDefaultBlvdLocationState = () =>
    useSetRecoilState(defaultBlvdLocationState)

export const useSuccessBookingCartInfoState = () =>
    useRecoilValue(successBookingCartInfoState)
export const useSetSuccessBookingCartInfoState = () =>
    useSetRecoilState(successBookingCartInfoState)

export interface CartServices {
    cart: Cart
    services: CartBookableItem[]
}

export const useCartMethods = () => {
    const setCart = useSetCartState()
    const setCartIdState = useSetCartIdState()
    const setBookingAnswers = useSetBookingAnswersState()
    const setPersonalInformationState = useSetPersonalInformationState()
    const { getStoreFromLocation, setLocations } = useStores()
    const setCartStoreState = useSetCartStoreState()
    const resetCartStoreState = useResetCartStoreState()
    const setLocationSelectedStoreState = useSetLocationSelectedStoreState()
    const resetLocationSelectedStoreState = useResetLocationSelectedStoreState()
    const { appointmentTimeSelected } = useAnalyticsService()
    const resetStaffDatesStore = useResetStaffDatesStore()
    const resetStaffTimesState = useResetStaffTimesState()
    const resetSelectedStaffTimeState = useResetSelectedStaffTimeState()
    const { getMapViewportState } = useMapView()
    const setViewport = useSetMapViewportState()
    const setAvailableCategories = useSetAvailableCategories()
    const {
        loadSelectedServicesFromCart,
        reverseSelectedServices,
        selectedCartAvailableItemsStateValue,
        setSelectedCartAvailableItemsState,
    } = useSelectedServices()
    const setActiveSelectedService = useSetActiveSelectedService()
    const setBookableStaffVariants = useSetBookableStaffVariants()
    const setAllowChooseStaffError = useSetAllowChooseStaffError()
    const setCartBookableItemListStaff = useSetCartBookableItemListStaff()
    const availableBookableItemStores = useAvailableBookableItemStoresState()
    const setAvailableBookableItemStores =
        useSetAvailableBookableItemStoresState()
    const setSelectedCartAvailableCategory =
        useSetSelectedCartAvailableCategory()
    const resetSelectedCartAvailableCategory =
        useResetSelectedCartAvailableCategory()

    const isCartAvailableBookableItem = (
        availableItem: CartAvailableItem | undefined
    ) => {
        return (
            availableItem &&
            availableItem['__typename'] === 'CartAvailableBookableItem'
        )
    }

    const isCartAvailablePurchasableItem = (
        availableItem: CartAvailableItem | undefined
    ) => {
        return (
            availableItem &&
            availableItem['__typename'] === 'CartAvailablePurchasableItem'
        )
    }

    const addRemoveServiceCommon = async (
        cart: Cart,
        selectedCartAvailableItems: CartAvailableItem[]
    ): Promise<CartServices> => {
        setCart(cart)
        const services = await loadSelectedServicesFromCart(
            cart,
            selectedCartAvailableItems
        )
        resetStaffDatesStore()
        resetStaffTimesState()
        resetSelectedStaffTimeState()
        return { cart, services }
    }

    const addService = async (
        cart: Cart,
        availableItem: CartAvailableItem
    ): Promise<CartServices> => {
        if (isCartAvailablePurchasableItem(availableItem)) {
            cart = await cart.addPurchasableItem(
                availableItem as CartAvailablePurchasableItem
            )
        } else {
            cart = await cart.addBookableItem(
                availableItem as CartAvailableBookableItem
            )
        }
        const selectedCartAvailableItems =
            selectedCartAvailableItemsStateValue.concat(availableItem)
        setSelectedCartAvailableItemsState(selectedCartAvailableItems)
        return await addRemoveServiceCommon(cart, selectedCartAvailableItems)
    }

    const removeService = async (
        cart: Cart,
        bookableItem: CartBookableItem
    ): Promise<CartServices> => {
        cart = await cart.removeSelectedItem(bookableItem)
        const selectedCartAvailableItems: CartAvailableItem[] = []
        let wasFound = false
        for (let item of selectedCartAvailableItemsStateValue) {
            if (!wasFound && item.id === bookableItem.id) {
                wasFound = true
                continue
            }

            selectedCartAvailableItems.push(item)
        }
        setSelectedCartAvailableItemsState(selectedCartAvailableItems)
        return await addRemoveServiceCommon(cart, selectedCartAvailableItems)
    }

    const addAddon = async (
        cart: Cart,
        bookableItem: CartBookableItem,
        option: CartAvailableBookableItemOption
    ) => {
        const options = bookableItem.selectedOptions
        cart = await bookableItem.update({
            options: [...options, option],
            staffVariant: bookableItem.selectedStaffVariant,
        })
        return await addRemoveServiceCommon(
            cart,
            selectedCartAvailableItemsStateValue
        )
    }

    const removeAddon = async (
        cart: Cart,
        bookableItem: CartBookableItem,
        option: CartAvailableBookableItemOption
    ) => {
        const options = bookableItem.selectedOptions
        cart = await bookableItem.update({
            options: [...options.filter((opt) => opt.id !== option.id)],
        })
        return await addRemoveServiceCommon(
            cart,
            selectedCartAvailableItemsStateValue
        )
    }

    const selectStaff = async (
        cart: Cart,
        bookableItem: CartBookableItem,
        staff: Staff | undefined
    ) => {
        cart = await bookableItem.update({
            options: bookableItem.selectedOptions,
            staffVariant: staff?.staffVariant ?? { id: null },
        })
        return await addRemoveServiceCommon(
            cart,
            selectedCartAvailableItemsStateValue
        )
    }

    const setLocationBasedElements = async (
        location: Location | undefined,
        store: Store | undefined
    ) => {
        if (location === undefined) {
            resetCartStoreState()
            resetLocationSelectedStoreState()
            return
        }
        let locationStore = store
        if (locationStore === undefined) {
            locationStore = await getStoreFromLocation(location)
        }
        setCartStoreState(locationStore)
        setLocationSelectedStoreState(locationStore)
        const viewport = getMapViewportState()
        const updatedViewPort = {
            ...viewport,
            ...{
                longitude: locationStore.location.coordinates?.longitude ?? 0,
                latitude: locationStore.location.coordinates?.latitude ?? 0,
                zoom: defaultZoom,
                transitionDuration: mapBoxTransitionDuration,
                transitionInterpolator: mapBoxFlyToInterpolator,
            },
        }
        setViewport(updatedViewPort)
    }

    const setCartCommonState = async (
        cart: Cart,
        location: Location | undefined,
        store: Store | undefined
    ): Promise<CartAvailableCategory[]> => {
        setCart(cart)
        const cartCategories = (await cart.getAvailableCategories()).filter(
            (x) => x.name !== 'Gift Cards'
        )
        setAvailableCategories(cartCategories)
        await setLocationBasedElements(location, store)
        if (cartCategories?.length) {
            setSelectedCartAvailableCategory(cartCategories[0])
        }
        return cartCategories
    }

    const createCart = async (
        location?: Location | undefined,
        store?: Store | undefined
    ): Promise<Cart> => {
        const cart = await Blvd.carts.create(location)
        setCartIdState(cart.id)
        setBookingAnswers([])
        setPersonalInformationState({
            firstName: '',
            email: '',
            lastName: '',
            phone: '',
        })
        resetStaffDatesStore()
        resetStaffTimesState()
        await setCartCommonState(cart, location, store)
        return cart
    }

    const getCartDataLoadedState = useRecoilCallback(
        ({ snapshot }) =>
            () => {
                let loadable = snapshot.getLoadable(cartDataLoaded)
                return loadable.valueMaybe()
            },
        []
    )

    const reserveBookableTime = async (
        cart: Cart | undefined,
        cartBookableTime: CartBookableTime | undefined,
        cartStoreState: Store | undefined
    ) => {
        if (!cart || !cartBookableTime) {
            return
        }
        const updatedCart = await cart?.reserveBookableItems(cartBookableTime)
        setCart(updatedCart)
        appointmentTimeSelected({
            location: cartStoreState?.location,
        }).then() //don't wait for op to be completed
    }

    const getAnswer = (bookingQuestion: CartBookingQuestion): any => {
        let answer = bookingQuestion.answer
        if (bookingQuestion.valueType === 'SELECT') {
            answer = bookingQuestion.answer?.option
        }
        if (bookingQuestion.valueType === 'BOOLEAN') {
            answer = bookingQuestion.answer?.booleanValue
        }
        if (bookingQuestion.valueType === 'DATETIME') {
            answer = cartTimeToDate(bookingQuestion.answer?.datetimeValue)
        }
        if (bookingQuestion.valueType === 'TEXT') {
            answer = bookingQuestion.answer?.textValue
        }
        return answer === null ? undefined : answer
    }

    const loadBookingAnswers = (cart: Cart) => {
        for (let question of cart.bookingQuestions) {
            if (!question.answer) {
                continue
            }
            setBookingAnswers((bookingAnswers) => [
                ...bookingAnswers.filter((q) => q.questionId !== question.id),
                {
                    questionId: question.id,
                    answer: getAnswer(question),
                },
            ])
        }
    }

    const getPersonalInformation = (cart: Cart): PersonalInformation => {
        return {
            email: cart.clientInformation?.email ?? '',
            phone: cart.clientInformation?.phoneNumber.substring(2) ?? '',
            firstName: cart.clientInformation?.firstName ?? '',
            lastName: cart.clientInformation?.lastName ?? '',
        }
    }

    const resetCategories = async () => {
        resetSelectedCartAvailableCategory()
    }

    const loadSelectedServices = async (
        cart: Cart,
        servicesFromCart: CartBookableItem[],
        selectedCartAvailableCategory?: CartAvailableCategory | undefined
    ) => {
        const services = reverseSelectedServices(servicesFromCart)
        if (services.length === 0) {
            return
        }
        const activeService = services[0]
        setActiveSelectedService(activeService)

        if (isCartAvailableBookableItem(activeService.item)) {
            const staffs = await activeService.item.getStaffVariants()
            setBookableStaffVariants(
                staffs.flatMap((z) =>
                    cartAvailableBookableItemStaffVariantToStaff(z)
                )
            )
        } else {
            setBookableStaffVariants([])
        }
        setAllowChooseStaffError(false)
        if (selectedCartAvailableCategory) {
            setSelectedCartAvailableCategory(selectedCartAvailableCategory)
        }
    }

    const getSelectedCartAvailableCategoryFromSelectedServices = (
        servicesFromCart: CartBookableItem[],
        availableCategories: CartAvailableCategory[]
    ) => {
        let selectedCartAvailableCategory: CartAvailableCategory | undefined =
            undefined

        if (servicesFromCart.length === 0) {
            return {
                selectedCartAvailableCategory: selectedCartAvailableCategory,
            }
        }

        selectedCartAvailableCategory = availableCategories.find((pc) =>
            pc.availableItems.some((i) => i.id === servicesFromCart[0].item.id)
        )
        return {
            selectedCartAvailableCategory: selectedCartAvailableCategory,
        }
    }

    const forceLoadSelectedServices = async (
        cart: Cart,
        availableCategories: CartAvailableCategory[]
    ) => {
        const servicesFromCart = await loadSelectedServicesFromCart(cart, [])
        const { selectedCartAvailableCategory } =
            getSelectedCartAvailableCategoryFromSelectedServices(
                servicesFromCart,
                availableCategories
            )
        await loadSelectedServices(
            cart,
            servicesFromCart,
            selectedCartAvailableCategory
        )
        return servicesFromCart
    }

    const loadSelectedStaff = async (servicesFromCart: CartBookableItem[]) => {
        const staffs: CartBookableItemStaff[] = []
        for (let selectedItem of servicesFromCart) {
            if (selectedItem.selectedStaffVariant) {
                staffs.push({
                    cartBookableItemId: selectedItem.id,
                    staff: cartAvailableBookableItemStaffVariantToStaff(
                        selectedItem.selectedStaffVariant
                    ),
                })
            }
        }
        setCartBookableItemListStaff(staffs)
    }

    const loadStoresForCartBookableItems = async (
        selectedBookableItems: CartBookableItem[],
        lastSelectedItem: CartAvailableBookableItem
    ) => {
        let locations: CartAvailableBookableItemLocationVariant[] | undefined =
            undefined
        const cartAvailableBookableItems = selectedBookableItems.map(
            (i) => i.item as CartAvailableBookableItem
        )
        if (lastSelectedItem) cartAvailableBookableItems.push(lastSelectedItem)
        const localAvailableBookableItemStores =
            availableBookableItemStores.concat()
        for (let availableBookableItem of cartAvailableBookableItems) {
            const filteredAvailableBookableItemStores =
                localAvailableBookableItemStores.filter(
                    (x) => x.availableBookableItemId == availableBookableItem.id
                )
            let itemLocationVariants =
                filteredAvailableBookableItemStores.flatMap(
                    (x) => x.cartAvailableBookableItemLocationVariant
                )
            if (itemLocationVariants.length == 0) {
                itemLocationVariants =
                    await availableBookableItem.getLocationVariants()
                localAvailableBookableItemStores.push({
                    availableBookableItemId: availableBookableItem.id,
                    cartAvailableBookableItemLocationVariant:
                        itemLocationVariants,
                } as AvailableBookableItemStores)
            }
            if (locations === undefined) {
                locations = itemLocationVariants
            } else {
                locations = locations.filter((l) =>
                    itemLocationVariants.some(
                        (v) => v.location.id === l.location.id
                    )
                )
            }
        }
        setAvailableBookableItemStores(localAvailableBookableItemStores)
        if (locations) {
            setLocations(locations.map((l) => l.location))
        } else {
            setLocations([])
        }
    }

    const setCartLocation = async (
        cart: Cart,
        selectedStore: Store,
        cartStore: Store | undefined,
        lastSelectedItem: CartAvailableBookableItem | undefined,
        selectedBookableItems: CartBookableItem[]
    ) => {
        if (!cart) {
            return selectedBookableItems
        }
        let newCart = cart

        // if new location distinguish from previous selected location, replace cart with new one
        if (!cartStore || cartStore.location.id !== selectedStore.location.id) {
            newCart = await createCart(selectedStore.location, selectedStore)

            for (let item of selectedBookableItems) {
                const cartBookableItem = item as CartBookableItem
                const cartAvailableBookableItem =
                    cartBookableItem.item as CartAvailableBookableItem
                if (cartAvailableBookableItem) {
                    newCart = await newCart.addBookableItem(
                        cartAvailableBookableItem
                    )
                }
            }
        }

        if (!cartStore) {
            newCart = await newCart.setLocation(selectedStore.location)
        }

        let selectedCartAvailableItems = selectedCartAvailableItemsStateValue
        if (lastSelectedItem) {
            newCart = await newCart.addBookableItem(lastSelectedItem)
            selectedCartAvailableItems =
                selectedCartAvailableItems.concat(lastSelectedItem)
            setSelectedCartAvailableItemsState(selectedCartAvailableItems)
        }
        return await loadSelectedServicesFromCart(
            newCart,
            selectedCartAvailableItems
        )
    }

    return {
        createCart: createCart,
        setCartCommonState: setCartCommonState,
        getCartDataLoadedState: getCartDataLoadedState,
        reserveBookableTime: reserveBookableTime,
        getPersonalInformation: getPersonalInformation,
        loadBookingAnswers: loadBookingAnswers,
        resetCategories: resetCategories,
        addService: addService,
        removeService: removeService,
        addAddon: addAddon,
        removeAddon: removeAddon,
        selectStaff: selectStaff,
        loadSelectedServices: loadSelectedServices,
        forceLoadSelectedServices: forceLoadSelectedServices,
        loadSelectedStaff: loadSelectedStaff,
        loadStoresForCartBookableItems: loadStoresForCartBookableItems,
        setCartLocation: setCartLocation,
        isCartAvailableBookableItem: isCartAvailableBookableItem,
        isCartAvailablePurchasableItem: isCartAvailablePurchasableItem,
    }
}

export const useCartDataLoadedState = () => useRecoilValue(cartDataLoaded)
export const useSetCartDataLoadedState = () => useSetRecoilState(cartDataLoaded)
</file>

<file path="lib/state/cart/types.ts">
import { Store } from 'lib/state/store/types'

export interface SuccessBookingCartInfo {
    total: number
    startTime: string
    endTime: string
    store: Store
    icsLink: string
}
</file>

<file path="lib/state/config/index.ts">
import { atom, useRecoilValue } from 'recoil'
import {
    getPersistedState,
    makePersistedSetRecoilState,
} from 'lib/state/persistence'
import { useConfig } from 'lib/sdk/hooks/useConfig'

const MAP_TYPE = 'MAP_TYPE'
const DATETIME_TYPE = 'DATETIME_TYPE'
const FLOW_TYPE = 'FLOW_TYPE'

export const mapTypeState = atom<string | undefined>({
    key: 'mapTypeState',
    default: getPersistedState(MAP_TYPE) ?? undefined,
})

export const dateTimeTypeState = atom<string | undefined>({
    key: 'dateTimeTypeState',
    default: getPersistedState(DATETIME_TYPE) ?? undefined,
})

export const flowTypeState = atom<string | undefined>({
    key: 'flowTypeState',
    default: getPersistedState(FLOW_TYPE) ?? undefined,
})

export const useMapTypeState = () => useRecoilValue(mapTypeState)
export const useSetMapTypeState = makePersistedSetRecoilState(
    MAP_TYPE,
    mapTypeState
)

export const useDateTimeTypeState = () => useRecoilValue(dateTimeTypeState)
export const useSetDateTimeTypeState = makePersistedSetRecoilState(
    DATETIME_TYPE,
    dateTimeTypeState
)

export const useFlowTypeState = () => useRecoilValue(flowTypeState)
export const useSetFlowTypeState = makePersistedSetRecoilState(
    FLOW_TYPE,
    flowTypeState
)

export enum MapType {
    MapBox = 0,
    Google = 1,
    None = 2,
}

export enum DateTimeType {
    ShowTimeForOneDay,
    ShowTimeForManyDays,
}

export enum FlowType {
    SelectLocationFirst,
    SelectServiceFirst,
}

export enum DisplayAppSettingsPopup {
    No,
    Yes,
}

export const useAppConfig = () => {
    const {mapType, flowType, dateTimeType, mapboxApiAccessToken, googleMapsApiAccessToken} = useConfig()
    const mapTypeString = useMapTypeState()
    const dateTimeTypeString = useDateTimeTypeState()
    const flowTypeState = useFlowTypeState()

    function getValue<T extends number, TEnumValue extends string>(
        value: string | undefined,
        defaultValue: T,
        enumVariable: { [key in number]: TEnumValue }
    ) {
        let result: T | undefined
        if (value) {
            result = enumVariable[value] as T
        }
        return result ?? defaultValue
    }

    const getMapType = (): MapType => {
        return getValue(mapTypeString, mapType, MapType)
    }

    const isMapAvailable = (): boolean => {
        const mapType = getMapType()
        if (mapType === MapType.MapBox) {
            return !!mapboxApiAccessToken
        } else if (mapType === MapType.Google) {
            return !!googleMapsApiAccessToken
        }
        return false
    }

    const getDateTimeType = (): DateTimeType => {
        return getValue(
            dateTimeTypeString,
            dateTimeType,
            DateTimeType
        )
    }

    const getFlowType = (): FlowType => {
        return getValue(flowTypeState, flowType, FlowType)
    }

    return {
        getMapType: getMapType,
        getDateTimeType: getDateTimeType,
        getFlowType: getFlowType,
        isMapAvailable: isMapAvailable,
    }
}
</file>

<file path="lib/state/currentPosition/index.ts">
import { atom, useRecoilValue, useSetRecoilState } from 'recoil'
import { PositionCoordinates } from './types'
import { defaultLatitude, defaultLongitude } from 'lib/utils/locationUtils'

const defaultPosition: PositionCoordinates = {
    latitude: defaultLatitude,
    longitude: defaultLongitude,
}

const currentPositionState = atom<PositionCoordinates>({
    key: 'currentPositionState',
    default: defaultPosition,
})

const currentPositionNameState = atom<string>({
    key: 'currentPositionNameState',
    default: '',
})

const isLocationAccessAllowed = atom<boolean>({
    key: 'isLocationAccessAllowed',
    default: false,
})

const isLocationAccessAnsweredByUser = atom<boolean>({
    key: 'isLocationAccessAnsweredByUser',
    default: false,
})

export const useCurrentPosition = () => useRecoilValue(currentPositionState)

export const useSetCurrentPosition = () =>
    useSetRecoilState(currentPositionState)

export const useIsLocationAccessAllowed = () =>
    useRecoilValue(isLocationAccessAllowed)
export const useSetIsLocationAccessAllowed = () =>
    useSetRecoilState(isLocationAccessAllowed)

export const useCurrentPositionName = () =>
    useRecoilValue(currentPositionNameState)
export const useSetCurrentPositionName = () =>
    useSetRecoilState(currentPositionNameState)

export const useIsLocationAccessAnsweredByUser = () =>
    useRecoilValue(isLocationAccessAnsweredByUser)
export const useSetIsLocationAccessAnsweredByUser = () =>
    useSetRecoilState(isLocationAccessAnsweredByUser)
</file>

<file path="lib/state/currentPosition/types.ts">
export interface PositionCoordinates {
    latitude: number
    longitude: number
}
</file>

<file path="lib/state/error/enums.ts">
export enum ErrorType {
    NoError,
    TimeIsNoLongerAvailable,
    SomethingWentWrong,
}
</file>

<file path="lib/state/error/index.ts">
import { atom, useRecoilState, useRecoilValue } from 'recoil'
import { ErrorType } from './enums'

export const errorMessageType = atom<ErrorType>({
    key: 'errorMessageType',
    default: ErrorType.NoError,
})

export const useErrorMessage = () => useRecoilValue(errorMessageType)
export const useErrorMessageType = () => useRecoilState(errorMessageType)
</file>

<file path="lib/state/flow-routing/index.ts">
import { useRecoilValue } from 'recoil'
import { initialStep } from 'lib/state/booking-flow/types'
import { useEffect } from 'react'
import { useRouter } from 'next/router'
import flowStepState, { useFlowStep } from 'lib/state/booking-flow'
import { getStepFromPath } from 'lib/utils/stepUtils'
import { useCartDataLoadedState, useCartMethods } from 'lib/state/cart'

export const useFlowRouting = () => {
    const router = useRouter()
    const { setRecoilStep } = useFlowStep()
    const currentFlowStep = useRecoilValue(flowStepState)
    const { getCartDataLoadedState } = useCartMethods()

    const handleHash = (pathname: string) => {
        if (!getCartDataLoadedState()) {
            return
        }
        let step = getStepFromPath(pathname, initialStep)
        if (step !== undefined) {
            if (currentFlowStep.step !== step) {
                setRecoilStep(step)
            }
        }
    }

    const handlePath = (pathname: string) => {
        if (!getCartDataLoadedState()) {
            return
        }
        if (pathname === '/' || pathname === '' || pathname === '/#') {
            if (currentFlowStep.step !== initialStep) {
                setRecoilStep(initialStep)
            }
        } else {
            handleHash(pathname)
        }
    }

    useEffect(() => {
        let cancel = false
        const onRouteChange = async (pathname: string) => {
            handlePath(pathname)
        }
        router.events.on('routeChangeComplete', onRouteChange)
        return () => {
            cancel = true
            router.events.off('routeChangeComplete', onRouteChange)
        }
        // eslint-disable-next-line
    }, [currentFlowStep])

    useEffect(() => {
        let cancel = false
        const onRouteChange = async (pathname: string) => {
            handleHash(pathname)
        }
        router.events.on('hashChangeComplete', onRouteChange)
        return () => {
            cancel = true
            router.events.off('hashChangeComplete', onRouteChange)
        }
        // eslint-disable-next-line
    }, [currentFlowStep])
}
</file>

<file path="lib/state/location/index.ts">
import {
    atom,
    useRecoilCallback,
    useRecoilState,
    useRecoilValue,
    useResetRecoilState,
    useSetRecoilState,
} from 'recoil'
import { ViewPortInterface } from 'lib/state/location/types'
import { Store } from 'lib/state/store/types'

export const locationSelectedStoreState = atom<Store | undefined>({
    key: 'locationSelectedStoreState',
    default: undefined,
})

export const mapViewportState = atom<ViewPortInterface>({
    key: 'mapViewportState',
    default: {
        latitude: 37.7577,
        longitude: -102.4376,
        zoom: 3,
    },
})

export const updateStoresViewportState = atom<any>({
    key: 'updateStoresViewportState',
    default: undefined,
})

export const defineLocationMapViewportState = atom<any>({
    key: 'defineLocationMapViewportState',
    default: {},
})

export const isShowMapState = atom<boolean>({
    key: 'isShowMapState',
    default: false,
})

export const useUpdateStoresViewportState = () =>
    useRecoilValue(updateStoresViewportState)
export const useSetUpdateStoresViewportState = () =>
    useSetRecoilState(updateStoresViewportState)

export const useLocationSelectedStoreState = () =>
    useRecoilState(locationSelectedStoreState)
export const useSetLocationSelectedStoreState = () =>
    useSetRecoilState(locationSelectedStoreState)
export const useResetLocationSelectedStoreState = () =>
    useResetRecoilState(locationSelectedStoreState)

export const useMapViewportState = () => useRecoilState(mapViewportState)
export const useSetMapViewportState = () => useSetRecoilState(mapViewportState)

export const useIsShowMap = () => useRecoilState(isShowMapState)
export const useSetIsShowMap = () => useSetRecoilState(isShowMapState)

export const useMapView = () => {
    const getMapViewportState = useRecoilCallback(
        ({ snapshot }) =>
            () => {
                let loadable = snapshot.getLoadable(
                    defineLocationMapViewportState
                )
                return loadable.valueMaybe()
            },
        []
    )
    return {
        getMapViewportState: getMapViewportState,
    }
}

export const useSetDefineLocationMapViewportState = () =>
    useSetRecoilState(defineLocationMapViewportState)
</file>

<file path="lib/state/location/types.ts">
export interface ViewPortInterface {
    latitude: number
    longitude: number
    zoom: number
}
</file>

<file path="lib/state/payment-info/index.ts">
import {
    atom,
    useRecoilState,
    useResetRecoilState,
    useSetRecoilState,
} from 'recoil'
import { PaymentInformation } from './types'

const paymentInformationState = atom<PaymentInformation>({
    key: 'paymentInformationState',
    default: {
        cardHoldersName: '',
        cardNumber: '',
        expirationDate: '',
    },
})

export const usePaymentInformationState = () =>
    useRecoilState(paymentInformationState)
export const useSetPaymentInformationState = () =>
    useSetRecoilState(paymentInformationState)
export const useResetPaymentInformationState = () =>
    useResetRecoilState(paymentInformationState)
</file>

<file path="lib/state/payment-info/types.ts">
export interface PaymentInformation {
    cardHoldersName: string
    cardNumber: string
    expirationDate: string
}
</file>

<file path="lib/state/personal-info/index.ts">
import {
    atom,
    useRecoilState,
    useResetRecoilState,
    useSetRecoilState,
} from 'recoil'
import { PersonalInformation } from './types'

const personalInformationState = atom<PersonalInformation>({
    key: 'personalInformationState',
    default: {
        firstName: '',
        email: '',
        lastName: '',
        phone: '',
    },
})

export const usePersonalInformationState = () =>
    useRecoilState(personalInformationState)
export const useSetPersonalInformationState = () =>
    useSetRecoilState(personalInformationState)
export const useResetPersonalInformationState = () =>
    useResetRecoilState(personalInformationState)
</file>

<file path="lib/state/personal-info/types.ts">
export interface PersonalInformation {
    firstName: string
    lastName: string
    email: string
    phone: string
}
</file>

<file path="lib/state/services/index.ts">
import {
    Cart,
    CartAvailableBookableItem,
    CartAvailableCategory,
    CartBookableItem,
} from '@boulevard/blvd-book-sdk/lib/cart'
import {
    atom,
    useRecoilValue,
    useResetRecoilState,
    useSetRecoilState,
} from 'recoil'
import { useCartMethods, useCartState } from 'lib/state/cart'
import { useFlowStep } from 'lib/state/booking-flow'
import { FlowType, useAppConfig } from 'lib/state/config'
import { Step } from 'lib/state/booking-flow/types'
import { CartAvailableItem } from '@boulevard/blvd-book-sdk/lib/carts/items'

export const availableCategoriesState = atom<CartAvailableCategory[]>({
    key: 'availableCategories',
    default: [],
})

export const selectedCartAvailableCategoryState = atom<
    CartAvailableCategory | undefined
    >({
    key: 'selectedCartAvailableCategoryState',
    default: undefined,
})

export const selectedServicesState = atom<CartBookableItem[]>({
    key: 'selectedServicesState',
    default: [],
})

export const selectedCartAvailableItemsState = atom<CartAvailableItem[]>({
    key: 'selectedCartAvailableItemsState',
    default: [],
})

export const activeSelectedServiceState = atom<CartBookableItem | undefined>({
    key: 'activeSelectedServiceState',
    default: undefined,
})

export const lastSelectedBookableItem = atom<
    CartAvailableBookableItem | undefined
    >({
    key: 'lastSelectedBookableItem',
    default: undefined,
})

export const useAvailableCategories = () =>
    useRecoilValue(availableCategoriesState)
export const useSetAvailableCategories = () =>
    useSetRecoilState(availableCategoriesState)

export const useSelectedCartAvailableCategory = () =>
    useRecoilValue(selectedCartAvailableCategoryState)
export const useSetSelectedCartAvailableCategory = () =>
    useSetRecoilState(selectedCartAvailableCategoryState)
export const useResetSelectedCartAvailableCategory = () =>
    useResetRecoilState(selectedCartAvailableCategoryState)

export const useActiveSelectedService = () =>
    useRecoilValue(activeSelectedServiceState)
export const useSetActiveSelectedService = () =>
    useSetRecoilState(activeSelectedServiceState)

export const useLastSelectedBookableItem = () =>
    useRecoilValue(lastSelectedBookableItem)
export const useSetLastSelectedBookableItem = () =>
    useSetRecoilState(lastSelectedBookableItem)
export const useResetLastSelectedBookableItem = () =>
    useResetRecoilState(lastSelectedBookableItem)

export const useSelectedServices = () => {
    const selectedServicesStateValue = useRecoilValue(selectedServicesState)
    const setSelectedServicesStateValue = useSetRecoilState(
        selectedServicesState
    )
    const selectedCartAvailableItemsStateValue = useRecoilValue(selectedCartAvailableItemsState)
    const setSelectedCartAvailableItemsState = useSetRecoilState(selectedCartAvailableItemsState)

    const reverseSelectedServices = (selectedServies: CartBookableItem[]) => {
        return selectedServies.concat().reverse()
    }

    const loadSelectedServicesFromCart = async (
        cart: Cart,
        selectedCartAvailableItems : CartAvailableItem[]
    ): Promise<CartBookableItem[]> => {
        const selectedItems = await cart.getSelectedItems()
        const cartBookableItems = selectedItems.map((x) => {
            return x as CartBookableItem
        })

        // We shouldn’t rely on the ordering of the items
        // returned by getSelectedItems - that ordering is not guaranteed and can change at any point in the future.
        // Sort items based on selectedCartAvailableItems.

        const usedIndexes : number[] = []
        const sortedCartBookableItems : CartBookableItem[] = []
        for (let availableItem of selectedCartAvailableItems) {
            for (let i = 0; i < cartBookableItems.length; i++) {
                const selectedItem = cartBookableItems[i]
                if (selectedItem.item.id === availableItem.id && usedIndexes.find(x=>x === i) === undefined) {
                    sortedCartBookableItems.push(selectedItem)
                    usedIndexes.push(i)
                    break
                }
            }
        }

        // We don't want to miss any element returned by server even it's available item is not in the selectedCartAvailableItems for some reason.
        for (let cartBookableItem of cartBookableItems) {
            if (sortedCartBookableItems.find(x=>x.id === cartBookableItem.id) === undefined) {
                sortedCartBookableItems.push(cartBookableItem)
            }
        }

        setSelectedServicesStateValue(sortedCartBookableItems)
        if (sortedCartBookableItems.length === 0) {
            setSelectedCartAvailableItemsState([])
        } else if (selectedCartAvailableItemsStateValue.length === 0) {
            setSelectedCartAvailableItemsState(sortedCartBookableItems.map(x=>x.item))
        }
        return sortedCartBookableItems
    }

    return {
        selectedServicesStateValue: selectedServicesStateValue,
        loadSelectedServicesFromCart: loadSelectedServicesFromCart,
        reverseSelectedServices: reverseSelectedServices,
        selectedCartAvailableItemsStateValue: selectedCartAvailableItemsStateValue,
        setSelectedCartAvailableItemsState: setSelectedCartAvailableItemsState,
    }
}

export const useServiceActions = (
    bookableItem: CartBookableItem | undefined
) => {
    const cart = useCartState()
    const setActiveSelectedService = useSetActiveSelectedService()
    const { removeService, createCart } = useCartMethods()
    const { setStep } = useFlowStep()
    const { reverseSelectedServices } = useSelectedServices()
    const { getFlowType } = useAppConfig()
    const flowType = getFlowType()

    const removeAllItemsSelectLocationFirstNextStep = async () => {
        await setStep(Step.SelectService)
    }

    const removeAllItemsSelectServiceFirstNextStep = async () => {
        await createCart()
        await setStep(Step.SelectService)
    }

    const removeAllItemsNextStep = async () => {
        if (flowType === FlowType.SelectLocationFirst) {
            await removeAllItemsSelectLocationFirstNextStep()
        } else {
            await removeAllItemsSelectServiceFirstNextStep()
        }
    }

    const onRemoveClick = async () => {
        if (cart === undefined || bookableItem === undefined) {
            return
        }
        const cartServices = await removeService(cart, bookableItem)
        if (cartServices.services.length === 0) {
            await removeAllItemsNextStep()
        } else {
            const services = reverseSelectedServices(cartServices.services)
            const activeItem = services[0]
            setActiveSelectedService(activeItem)
            return { activeItem, selectedServices: cartServices.services}
        }
    }

    const onEditAddonClick = async () => {
        setActiveSelectedService(bookableItem)
        await setStep(Step.SelectOptions)
    }

    return {
        onRemoveClick: onRemoveClick,
        onEditAddonClick: onEditAddonClick,
    }
}
</file>

<file path="lib/state/staff/index.ts">
import { atom, useRecoilValue, useSetRecoilState } from 'recoil'
import { CartBookableItemStaff, Staff } from 'lib/state/staff/types'
import { CartAvailableBookableItemStaffVariant } from '@boulevard/blvd-book-sdk/lib/carts/items'

export const bookableStaffVariantsState = atom<Staff[]>({
    key: 'bookableStaffVariantsState',
    default: [],
})

export const cartBookableItemStaffListState = atom<
    CartBookableItemStaff[] | undefined
>({
    key: 'cartBookableItemStaffState',
    default: undefined,
})

export const allowChooseStaffErrorState = atom<boolean>({
    key: 'allowChooseStaffErrorState',
    default: false,
})

export const cartAvailableBookableItemStaffVariantToStaff = (
    z: CartAvailableBookableItemStaffVariant
): Staff => {
    return {
        id: z.staff.id,
        name: `${z.staff.firstName} ${z.staff.lastName}`,
        description: z.staff.bio,
        avatar: z.staff.avatar,
        staffVariant: z,
    } as Staff
}

export const useBookableStaffVariants = () =>
    useRecoilValue(bookableStaffVariantsState)
export const useSetBookableStaffVariants = () =>
    useSetRecoilState(bookableStaffVariantsState)

export const useCartBookableItemListStaff = () =>
    useRecoilValue(cartBookableItemStaffListState)
export const useSetCartBookableItemListStaff = () =>
    useSetRecoilState(cartBookableItemStaffListState)

export const useAllowChooseStaffError = () =>
    useRecoilValue(allowChooseStaffErrorState)
export const useSetAllowChooseStaffError = () =>
    useSetRecoilState(allowChooseStaffErrorState)
</file>

<file path="lib/state/staff/types.ts">
import { CartAvailableBookableItemStaffVariant } from '@boulevard/blvd-book-sdk/lib/carts/items'

export interface Staff {
    id: string | null
    name: string
    description?: string
    avatar?: string
    staffVariant?: CartAvailableBookableItemStaffVariant
}

export interface CartBookableItemStaff {
    cartBookableItemId: string
    staff: Staff
}
</file>

<file path="lib/state/staffDate/index.ts">
import {
    atom,
    useRecoilCallback,
    useRecoilValue,
    useResetRecoilState,
    useSetRecoilState,
} from 'recoil'
import {
    SelectedStaffDate,
    StaffDate,
    StaffDates,
} from 'lib/state/staffDate/types'
import { Cart, CartBookableDate } from '@boulevard/blvd-book-sdk/lib/cart'
import formatDateFns from 'lib/utils/formatDateFns'
import { utcToZonedTime } from 'date-fns-tz'
import { addHours, isAfter } from 'date-fns'

export const staffDatesState = atom<StaffDates[]>({
    key: 'staffDatesState',
    default: [],
})

export const selectedStaffDateState = atom<SelectedStaffDate | undefined>({
    key: 'selectedStaffDateState',
    default: undefined,
})

export const useResetStaffDatesStore = () =>
    useResetRecoilState(staffDatesState)

export const useStaffDates = () => {
    const cartBookableDateToStaffDate = (
        cartBookableDate: CartBookableDate
    ): StaffDate => {
        return {
            date: new Date(cartBookableDate.date),
            cartBookableDate: cartBookableDate,
        } as StaffDate
    }

    const addStaffDates = useRecoilCallback(
        ({ set }) =>
            (cartBookableDates: CartBookableDate[]) => {
                const dates = cartBookableDates.map((x) =>
                    cartBookableDateToStaffDate(x)
                )

                const yearArrays = dates.map((x) => x.date.getFullYear())
                const years = [...new Set(yearArrays)]

                years.forEach((year) => {
                    const monthArrays = dates
                        .filter((x) => x.date.getUTCFullYear() === year)
                        .map((x) => x.date.getUTCMonth())
                    const months = [...new Set(monthArrays)]
                    months.forEach((month) => {
                        const monthDates = dates.filter(
                            (x) =>
                                x.date.getUTCMonth() === month &&
                                x.date.getUTCFullYear() === year
                        )
                        set(staffDatesState, (prevItems) => {
                            const prevMonthDates =
                                prevItems.find(
                                    (x) => x.year === year && x.month === month
                                )?.dates ?? []
                            const items = prevItems.filter(
                                (x) => !(x.year === year && x.month === month)
                            )
                            //remove possible duplicates
                            const dates = [
                                ...new Map(
                                    monthDates
                                        .concat(prevMonthDates)
                                        .map((item) => [
                                            item.date.getDate(),
                                            item,
                                        ])
                                ).values(),
                            ]
                            return items.concat([
                                {
                                    month: month,
                                    dates: dates,
                                    year: year,
                                },
                            ])
                        })
                    })
                })
            },
        []
    )

    const getRangeDate = (date: Date, locationTz: string) => {
        return formatDateFns(date, locationTz, 'yyyy-MM-dd')
    }

    const loadStaffDatesForMonth = async (
        year: number,
        month: number,
        cart: Cart,
        locationTz: string
    ): Promise<CartBookableDate[]> => {
        const staffDatesStore = getStaffDateState()
        //check do we need to get passed month or not
        if (
            staffDatesStore &&
            staffDatesStore?.filter((x) => x.year === year && x.month === month)
                .length > 0
        ) {
            return []
        }

        try {
            const minimumDate = getMinimumDate(locationTz)
            const monthStart = new Date(year, month, 1)
            const lowerRangeDate = isAfter(minimumDate, monthStart)
                ? minimumDate
                : monthStart
            const dates = await cart.getBookableDates({
                searchRangeLower: getRangeDate(lowerRangeDate, locationTz),
                searchRangeUpper: getRangeDate(
                    new Date(year, month + 1, 0),
                    locationTz
                ),
                timezone: locationTz,
            })
            if (dates === undefined) {
                return []
            }
            addStaffDates(dates)
            return dates
        } catch (e) {
            console.error(e)
        }
        return []
    }

    const loadStaffDates = async (
        year: number,
        month: number,
        cart: Cart | undefined,
        locationTz: string
    ): Promise<CartBookableDate[]> => {
        if (!cart) {
            return []
        }
        let date1 = new Date(year, month, 1)
        let date2 = new Date(date1.getFullYear(), date1.getMonth() + 1, 1)
        return (
            await Promise.all([
                loadStaffDatesForMonth(
                    date1.getFullYear(),
                    date1.getMonth(),
                    cart,
                    locationTz
                ),
                loadStaffDatesForMonth(
                    date2.getFullYear(),
                    date2.getMonth(),
                    cart,
                    locationTz
                ),
            ])
        ).flatMap((x) => x)
    }

    const getMinimumDate = (locationTz: string) => {
        const availabilityExcludedHours = 0
        return utcToZonedTime(
            addHours(new Date(), availabilityExcludedHours),
            locationTz
        )
    }

    const getFirstAvailableDayAfterTheDate = async (
        cart: Cart | undefined,
        locationTz: string,
        minimumDate: Date
    ): Promise<CartBookableDate | undefined> => {
        if (!cart) {
            return undefined
        }
        try {
            const dates = await cart.getBookableDates({
                searchRangeLower: getRangeDate(minimumDate, locationTz),
                timezone: locationTz,
                limit: 1,
            })
            if (dates === undefined || dates.length === 0) {
                return undefined
            }
            return dates[0]
        } catch (e) {
            return undefined
        }
    }

    const getFirstAvailableDay = async (
        cart: Cart | undefined,
        locationTz: string
    ): Promise<CartBookableDate | undefined> => {
        return getFirstAvailableDayAfterTheDate(
            cart,
            locationTz,
            getMinimumDate(locationTz)
        )
    }

    const getStaffDateState = useRecoilCallback(
        ({ snapshot }) =>
            () => {
                let loadable = snapshot.getLoadable(staffDatesState)
                return loadable.valueMaybe()
            },
        []
    )

    return {
        getFirstAvailableDay: getFirstAvailableDay,
        getFirstAvailableDayAfterTheDate: getFirstAvailableDayAfterTheDate,
        loadStaffDates: loadStaffDates,
        getStaffDateState: getStaffDateState,
        getMinimumDate: getMinimumDate,
        cartBookableDateToStaffDate: cartBookableDateToStaffDate,
    }
}

export const useSelectedStaffDateState = () =>
    useRecoilValue(selectedStaffDateState)
export const useSetSelectedStaffDateState = () =>
    useSetRecoilState(selectedStaffDateState)
</file>

<file path="lib/state/staffDate/types.ts">
import { CartBookableDate } from '@boulevard/blvd-book-sdk/lib/cart'

export type StaffDates = {
    year: number
    month: number
    dates: StaffDate[]
}

export type StaffDate = {
    date: Date
    cartBookableDate: CartBookableDate
}

export type SelectedStaffDate = {
    date: Date
    cartBookableDate?: CartBookableDate
}
</file>

<file path="lib/state/staffTime/index.ts">
import {
    atom,
    useRecoilCallback,
    useRecoilState,
    useRecoilValue,
    useResetRecoilState,
    useSetRecoilState,
} from 'recoil'
import { StaffTime, StaffTimes } from 'lib/state/staffTime/types'
import { Cart, CartBookableTime } from '@boulevard/blvd-book-sdk/lib/cart'
import { StaffDate } from 'lib/state/staffDate/types'
import { utcToZonedTime, zonedTimeToUtc } from 'date-fns-tz'
import { useResetStaffDatesStore, useStaffDates } from 'lib/state/staffDate'
import { isAfter } from 'date-fns'
import { Location } from '@boulevard/blvd-book-sdk/lib/locations'
import { sortByDate } from 'lib/utils/sortUtils'
import { DateTimeType, useAppConfig } from 'lib/state/config'

export const staffTimesState = atom<StaffTimes[]>({
    key: 'staffTimesState',
    default: [],
})

export const timesAreLoadingState = atom<boolean>({
    key: 'timesAreLoadingState',
    default: true,
})

export const loadingStaffTimeState = atom<boolean>({
    key: 'loadingStaffTimeState',
    default: false,
})

export const selectedStaffTimeState = atom<StaffTime | undefined>({
    key: 'selectedStaffTimeState',
    default: undefined,
})

export const useStaffTimesState = () => useRecoilValue(staffTimesState)
export const useResetStaffTimesState = () =>
    useResetRecoilState(staffTimesState)

export const useSelectedStaffTimeState = () =>
    useRecoilValue(selectedStaffTimeState)
export const useSetSelectedStaffTimeState = () =>
    useSetRecoilState(selectedStaffTimeState)
export const useResetSelectedStaffTimeState = () =>
    useResetRecoilState(selectedStaffTimeState)

export const cartBookableTimeToStaffTime = (
    startTime: any,
    locationTz: string,
    cartBookableTime?: CartBookableTime
) => {
    return {
        startTime: new Date(startTime),
        localTime: utcToZonedTime(
            startTime,
            Intl.DateTimeFormat().resolvedOptions().timeZone
        ),
        locationTime: utcToZonedTime(startTime, locationTz),
        cartBookableTime: cartBookableTime,
    } as StaffTime
}

export const useStaffTimes = () => {
    const { getMinimumDate } = useStaffDates()
    const {
        loadStaffDates,
        cartBookableDateToStaffDate,
        getFirstAvailableDayAfterTheDate,
        getStaffDateState,
    } = useStaffDates()
    const staffDatesStore = getStaffDateState()
    const staffTimes = useStaffTimesState()
    const setTimesAreLoadingState = useSetTimesAreLoadingState()
    const resetStaffDatesStore = useResetStaffDatesStore()
    const resetStaffTimesState = useResetStaffTimesState()
    const resetSelectedStaffTimeState = useResetSelectedStaffTimeState()
    const { getDateTimeType } = useAppConfig()
    const addStaffTimes = useRecoilCallback(
        ({ set }) =>
            (
                cartBookableTimes: CartBookableTime[],
                locationTz: string,
                minimumDate: Date
            ) => {
                const times = cartBookableTimes
                    .map((x) =>
                        cartBookableTimeToStaffTime(x.startTime, locationTz, x)
                    )
                    .filter((x) => isAfter(x.locationTime, minimumDate))

                const yearArrays = times.map((x) =>
                    x.locationTime.getFullYear()
                )
                const years = [...new Set(yearArrays)]

                years.forEach((year) => {
                    const monthArrays = times
                        .filter((x) => x.locationTime.getFullYear() === year)
                        .map((x) => x.locationTime.getMonth())
                    const months = [...new Set(monthArrays)]
                    months.forEach((month) => {
                        const dayArrays = times
                            .filter(
                                (x) =>
                                    x.locationTime.getMonth() === month &&
                                    x.locationTime.getFullYear() === year
                            )
                            .map((x) => x.locationTime.getDate())
                        const days = [...new Set(dayArrays)]
                        days.forEach((day) => {
                            //suppose we get the whole day from the server
                            const dayTimes = times.filter(
                                (x) =>
                                    x.locationTime.getMonth() === month &&
                                    x.locationTime.getFullYear() === year &&
                                    x.locationTime.getDate() === day
                            )
                            set(staffTimesState, (prevItems) =>
                                prevItems
                                    .filter(
                                        (x) =>
                                            !(
                                                x.year === year &&
                                                x.month === month &&
                                                x.day === day
                                            )
                                    )
                                    .concat({
                                        month: month,
                                        times: dayTimes,
                                        year: year,
                                        day: day,
                                        date: new Date(year, month, day),
                                    })
                            )
                        })
                    })
                })
            },
        []
    )

    const clearStaffTimes = useRecoilCallback(
        ({ reset }) =>
            () => {
                reset(staffTimesState)
            },
        []
    )

    const loadStaffTimes = async (
        cart: Cart | undefined,
        staffDate: StaffDate | undefined,
        locationTz: string
    ): Promise<CartBookableTime[] | undefined> => {
        if (!cart || !staffDate || !staffDate.cartBookableDate) {
            return
        }
        try {
            const times = await cart.getBookableTimes(
                staffDate.cartBookableDate,
                {
                    timezone: locationTz,
                }
            )
            if (times === undefined) {
                return
            }
            const minimumDate = getMinimumDate(locationTz)
            addStaffTimes(times, locationTz, minimumDate)
            return times
        } catch (e) {
            console.error(e)
        }
    }

    const timePageSize = 10
    const loadStaffTimesByStaffDates = (
        cart: Cart | undefined,
        locationTz: string,
        staffDates: StaffDate[]
    ) => {
        setTimesAreLoadingState(true)
        staffDates
            .reduce(
                (p, staffDate) =>
                    p.then((_) => loadStaffTimes(cart, staffDate, locationTz)),
                Promise.resolve()
            )
            .finally(() => {
                setTimesAreLoadingState(false)
            })
    }

    const forceLoadDatesAndTimes = async (
        cart: Cart,
        location: Location,
        date: Date
    ) => {
        resetStaffDatesStore()
        resetStaffTimesState()
        resetSelectedStaffTimeState()
        await loadDatesAndTimes(cart, location, date)
    }

    const loadDatesAndTimes = async (
        cart: Cart,
        location: Location,
        date: Date
    ) => {
        const cartBookableDates = await loadStaffDates(
            date.getFullYear(),
            date.getMonth(),
            cart,
            location.tz
        )
        const staffDates = cartBookableDates
            .map((x) => cartBookableDateToStaffDate(x))
            .sort(sortByDate)
            .slice(0, timePageSize)

        const dateTimeType = getDateTimeType()
        if (dateTimeType === DateTimeType.ShowTimeForOneDay) {
            if (staffDates.length > 0) {
                const staffDate = staffDates[0]
                await loadStaffTimes(cart, staffDate, location.tz)
            }
            return
        }

        loadStaffTimesByStaffDates(cart, location.tz, staffDates)
    }

    const loadNextTimesPage = async (
        cart: Cart | undefined,
        locationTz: string
    ): Promise<boolean> => {
        if (
            cart === undefined ||
            staffTimes.length === 0 ||
            staffDatesStore === undefined ||
            staffDatesStore.length === 0
        ) {
            return false
        }

        // get the list of dates
        // sortedStaffDatesStore contains list of available dates.
        const lastLoadedDate = staffTimes[staffTimes.length - 1].date
        lastLoadedDate.setHours(staffDatesStore[0].dates[0].date.getHours())
        const sortedStaffDatesStore = staffDatesStore
            .flatMap((x) => x.dates)
            .sort(sortByDate)
        let staffDates = sortedStaffDatesStore
            .filter((x) => isAfter(x.date, lastLoadedDate))
            .slice(0, timePageSize)

        if (staffDates.length < timePageSize) {
            // if number of available dates is less than page size then we should get more available days from the server

            // to get next available dates we need to determine the next month to load data
            const lastStaffDate =
                sortedStaffDatesStore[sortedStaffDatesStore.length - 1].date
            const nextMonthDate = new Date(
                lastStaffDate.getFullYear(),
                lastStaffDate.getMonth() + 1,
                1
            )
            let cartBookableDates = await loadStaffDates(
                nextMonthDate.getFullYear(),
                nextMonthDate.getMonth(),
                cart,
                locationTz
            )
            if (cartBookableDates.length === 0) {
                //if next month doesn't have available days - get first available day after next month
                const firstAvailableDay =
                    await getFirstAvailableDayAfterTheDate(
                        cart,
                        locationTz,
                        nextMonthDate
                    )
                if (firstAvailableDay !== undefined) {
                    // if available day exists then load days for the month of the available day
                    const dateToLoad = zonedTimeToUtc(
                        firstAvailableDay.date,
                        locationTz
                    )
                    cartBookableDates = await loadStaffDates(
                        dateToLoad.getFullYear(),
                        dateToLoad.getMonth(),
                        cart,
                        locationTz
                    )
                }
            }

            staffDates = staffDates
                .concat(
                    cartBookableDates.map((x) => cartBookableDateToStaffDate(x))
                )
                .sort(sortByDate)
                .slice(0, timePageSize)
        }

        loadStaffTimesByStaffDates(cart, locationTz, staffDates)
        // return true if we were able to get number of days equals to page size. Otherwise return false - meaning there is no more days
        return staffDates.length >= timePageSize
    }

    return {
        clearStaffTimes,
        loadStaffTimes: loadStaffTimes,
        loadDatesAndTimes: loadDatesAndTimes,
        timePageSize: timePageSize,
        loadNextTimesPage: loadNextTimesPage,
        forceLoadDatesAndTimes: forceLoadDatesAndTimes,
    }
}

export const useTimesAreLoadingState = () =>
    useRecoilValue(timesAreLoadingState)
export const useSetTimesAreLoadingState = () =>
    useSetRecoilState(timesAreLoadingState)

export const useLoadingStaffTimeState = () =>
    useRecoilValue(loadingStaffTimeState)
export const useSetLoadingStaffTimeState = () =>
    useSetRecoilState(loadingStaffTimeState)
</file>

<file path="lib/state/staffTime/types.ts">
import { CartBookableTime } from '@boulevard/blvd-book-sdk/lib/cart'

export type StaffTimes = {
    year: number
    month: number
    day: number
    date: Date
    times: StaffTime[]
}

export interface StaffTime {
    startTime: Date //date received from the server
    localTime: Date //local time
    locationTime: Date //time of the location
    cartBookableTime?: CartBookableTime
}

export type SelectedStaffTime = {
    staffTime: StaffTime
}
</file>

<file path="lib/state/store/index.ts">
import {
    atom,
    useRecoilValue,
    useResetRecoilState,
    useSetRecoilState,
} from 'recoil'
import { AvailableBookableItemStores, Store } from 'lib/state/store/types'

export const cartStoreState = atom<Store | undefined>({
    key: 'cartStoreState',
    default: undefined,
})

export const storesState = atom<Store[]>({
    key: 'storesState',
    default: [],
})

export const availableBookableItemStoresState = atom<
    AvailableBookableItemStores[]
>({
    key: 'availableBookableItemStoresState',
    default: [],
})

export const useCartStoreState = () => useRecoilValue(cartStoreState)
export const useSetCartStoreState = () => useSetRecoilState(cartStoreState)
export const useResetCartStoreState = () => useResetRecoilState(cartStoreState)

export const useStoresState = () => useRecoilValue(storesState)
export const useSetStoresState = () => useSetRecoilState(storesState)

export const useAvailableBookableItemStoresState = () =>
    useRecoilValue(availableBookableItemStoresState)
export const useSetAvailableBookableItemStoresState = () =>
    useSetRecoilState(availableBookableItemStoresState)
</file>

<file path="lib/state/store/types.ts">
import { Location } from '@boulevard/blvd-book-sdk/lib/locations'
import { CartAvailableBookableItemLocationVariant } from '@boulevard/blvd-book-sdk/lib/carts/items'

export interface Store {
    distance: number
    lng: number
    lat: number
    location: Location
}

export interface AvailableBookableItemStores {
    availableBookableItemId: string
    cartAvailableBookableItemLocationVariant: CartAvailableBookableItemLocationVariant[]
}
</file>

<file path="lib/state/summary/index.ts">
import { atom, useRecoilState, useSetRecoilState } from 'recoil'

const isSummaryBlockOpen = atom<boolean>({
    key: 'isSummaryBlockOpen',
    default: false,
})

export const useIsSummaryBlockOpenState = () =>
    useRecoilState(isSummaryBlockOpen)
export const useSetIsSummaryBlockOpenState = () =>
    useSetRecoilState(isSummaryBlockOpen)
</file>

<file path="lib/state/persistence.ts">
/**
 * Local Storage Persistence for recoil states
 */

import isNode from 'detect-node'
import { RecoilState, useSetRecoilState } from 'recoil'

export function getPersistedState<T>(key: string): T | null {
    if (isNode) return null
    const state = localStorage.getItem(key)
    return !!state ? (JSON.parse(state) as T) : null
}

export function setPersistedState<T>(key: string, state: T) {
    localStorage.setItem(key, JSON.stringify(state))
}

export function deletePersistedState(key: string) {
    localStorage.removeItem(key)
}

export function makePersistedSetRecoilState<T>(
    key: string,
    atom: RecoilState<T>
) {
    return () => {
        const setRecoilState = useSetRecoilState(atom)
        return (newVal: T) => {
            setRecoilState(newVal)
            if (newVal === undefined) {
                deletePersistedState(key)
            } else {
                setPersistedState<T>(key, newVal)
            }
        }
    }
}
</file>

<file path="lib/styles/fonts.scss">
@font-face {
    font-family: 'Cabin';
    src: local('Cabin Medium'), local('Cabin-Medium'),
        url('../../public/assets/Cabin-Medium.ttf') format('truetype');
    font-weight: 500;
    font-style: normal;
}

@font-face {
    font-family: 'Roboto';
    src: local('Roboto Regular'), local('Roboto-Regular'),
        url('../../public/assets/Roboto-Regular.ttf') format('truetype');
    font-weight: 400;
    font-style: normal;
}

@font-face {
    font-family: 'Roboto';
    src: local('Roboto Medium'), local('Roboto-Medium'),
        url('../../public/assets/Roboto-Medium.ttf') format('truetype');
    font-weight: 500;
    font-style: normal;
}

@font-face {
    font-family: 'Roboto';
    src: local('Roboto Bold'), local('Roboto-Bold'),
        url('../../public/assets/Roboto-Bold.ttf') format('truetype');
    font-weight: bold;
    font-style: normal;
}
</file>

<file path="lib/styles/styles.daypicker.scss">
.DayPicker *:focus {
    outline: none;
}

.DayPicker-Month {
    width: 100%;
    margin: 0px !important;
    height: 100%;
    display: flex !important;
    flex-direction: column;
}

.DayPicker-Weekday {
    width: 14%;
    min-width: 41px;
}

.DayPicker-Day.DayPicker-Day--selected {
    background-color: transparent !important;
}

.DayPicker-NavButton--interactionDisabled {
    display: inline-block !important;
    background-color: #c3c7cf !important;
}

.DayPicker:not(.DayPicker--interactionDisabled)
    .DayPicker-Day:not(.DayPicker-Day--disabled):not(.DayPicker-Day--selected):not(.DayPicker-Day--outside):hover {
    background-color: transparent !important;
}

.DayPicker-Weekdays {
    height: 30px;
    margin-top: 0 !important;
}

.DayPicker-Week {
    display: flex !important;
    flex: 1;
}

.DayPicker-Caption {
    text-align: left !important;
    height: 30px;
    padding: 0 15px !important;
}

.DayPicker-Body {
    height: calc(100% - 60px);
    display: flex !important;
    flex-direction: column;
}

.DayPicker-Caption > div {
    font-size: 16px !important;
    line-height: 24px;
    font-weight: normal !important;
}

.DayPicker-NavBar {
    height: 30px;
    position: absolute;
    left: 75%;
    top: 3px;
}

.DayPicker-WeekdaysRow {
    display: flex !important;
}

.DayPicker-NavButton {
    position: static !important;
    width: 1em !important;
    height: 1em !important;
    margin-top: 4px;
    -webkit-mask-repeat: no-repeat;
}

.DayPicker-NavButton--next {
    float: right;
    mask-image: url('/images/arr-r.svg') !important;
    background-color: #33343c;
    background-image: none !important;
}

.DayPicker-NavButton--prev {
    float: left;
    mask-image: url('/images/arr-l.svg') !important;
    background-color: #33343c;
    background-image: none !important;
}

.DayPicker-Day {
    padding: 0px !important;
    border-radius: 0px !important;
    flex: 1;
    display: flex !important;
}

.DayPicker-wrapper {
    height: 100%;
    display: flex;
    flex-direction: column !important;
    justify-content: space-between;
    padding-bottom: 0px !important;
}

.DayPicker-Months {
    height: 100%;
    display: flex;
}
</file>

<file path="lib/styles/styles.scss">
@import './fonts.scss';

*,
*:before,
*:after {
    box-sizing: border-box;
}

html,
body,
#__next {
    display: flex;
    flex-direction: column;
    height: 100%;
    min-width: 320px; /* sry Apple Watch */
    background-color: #ffffff;
}

a {
    text-decoration: inherit;
    color: inherit;
}

* {
    font-family: 'Roboto';
    font-weight: normal;
    font-size: 15px;
}

body.modal-open .background-container {
    -webkit-filter: blur(5px);
    -moz-filter: blur(5px);
    -o-filter: blur(5px);
    -ms-filter: blur(5px);
    filter: blur(5px);
    opacity: 0.4;
}

@media (min-width: 770px) {
    .background-container {
        height: 100%;
    }
}

@media (max-width: 770px) {
    input:not([type]),
    input[type=''],
    input[type='color'],
    input[type='date'],
    input[type='datetime'],
    input[type='datetime-local'],
    input[type='email'],
    input[type='month'],
    input[type='number'],
    input[type='password'],
    input[type='search'],
    input[type='tel'],
    input[type='text'],
    input[type='time'],
    input[type='url'],
    input[type='week'],
    select,
    textarea {
        font-size: 16px !important;
    }
}

body.modal-open {
    overflow: hidden;
}

@media (prefers-reduced-motion: reduce) {
    *,
    *:before,
    *:after {
        /* Very short durations means JavaScript that relies on events still works */
        animation-duration: 0.001ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.001ms !important;
    }
}

.e-ddl.e-popup {
    min-width: 200px;
}

.e-ddl.e-popup.e-lib.e-control.e-ddl-device.e-popup-open {
    top: 160px !important;
}

.e-input-group:not(.e-float-icon-left):not(.e-float-input)::before,
.e-input-group:not(.e-float-icon-left):not(.e-float-input)::after,
.e-input-group.e-float-icon-left:not(.e-float-input) .e-input-in-wrap::before,
.e-input-group.e-float-icon-left:not(.e-float-input) .e-input-in-wrap::after,
.e-input-group.e-control-wrapper:not(.e-float-icon-left):not(.e-float-input)::before,
.e-input-group.e-control-wrapper:not(.e-float-icon-left):not(.e-float-input)::after,
.e-input-group.e-control-wrapper.e-float-icon-left:not(.e-float-input)
    .e-input-in-wrap::before,
.e-input-group.e-control-wrapper.e-float-icon-left:not(.e-float-input)
    .e-input-in-wrap::after {
    background: #ccc !important;
}

.e-float-input.e-input-group:not(.e-float-icon-left) .e-float-line::before,
.e-float-input.e-input-group:not(.e-float-icon-left) .e-float-line::after,
.e-float-input.e-input-group.e-float-icon-left
    .e-input-in-wrap
    .e-float-line::before,
.e-float-input.e-input-group.e-float-icon-left
    .e-input-in-wrap
    .e-float-line::after,
.e-float-input.e-control-wrapper.e-input-group:not(.e-float-icon-left)
    .e-float-line::before,
.e-float-input.e-control-wrapper.e-input-group:not(.e-float-icon-left)
    .e-float-line::after,
.e-float-input.e-control-wrapper.e-input-group.e-float-icon-left
    .e-input-in-wrap
    .e-float-line::before,
.e-float-input.e-control-wrapper.e-input-group.e-float-icon-left
    .e-input-in-wrap
    .e-float-line::after {
    background: #ccc !important;
}

.e-dropdownbase .e-list-item.e-active,
.e-dropdownbase .e-list-item.e-active.e-hover {
    background-color: #eee;
    border-color: #fff;
    color: black !important;
}
</file>

<file path="lib/styles/theme.tsx">
import {
    createTheme,
    ThemeProvider as MuiThemeProvider,
} from '@mui/material/styles'
import Color from 'config/colors.json'
import Font from 'config/fonts.json'

export const theme = createTheme({
    components: {
        MuiAppBar: {
            styleOverrides: {
                root: {
                    height: '70px',
                    borderBottom: `1px solid #0000000a`,
                    flexDirection: 'column',
                    justifyContent: 'space-between',
                    alignItems: 'flex-start',
                },
                colorPrimary: {
                    backgroundColor: '#FFFFFF',
                },
            },
        },
        MuiLinearProgress: {
            styleOverrides: {
                root: {
                    height: '3px',
                },
                barColorPrimary: {
                    backgroundColor: Color.primary.main,
                },
                colorPrimary: {
                    backgroundColor: '#FFFFFF',
                },
            },
        },
        MuiFormControl: {
            defaultProps: {
                variant: 'filled',
                size: 'small',
                margin: 'none',
            },
        },
        MuiInputLabel: {
            styleOverrides: {
                root: {
                    textTransform: 'capitalize',
                    color: 'rgba(0, 0, 0, 0.6)',
                    fontSize: '16px',
                    fontFamily: Font.body_family,
                    left: -12,
                    transform: 'translate(12px, 40px) scale(1)',
                    transformOrigin: 'bottom left',
                    '&.Mui-focused': {
                        transform: 'translate(12px, 18px) scale(0.75)',
                        color: 'rgba(0, 0, 0, 0.6)',
                    },
                    position: 'relative',
                    whiteSpace: 'normal',
                    paddingRight: '6px',
                },
                shrink: {
                    transform: 'translate(12px, 18px) scale(0.75)',
                },
            },
        },
        MuiFormHelperText: {
            styleOverrides: {
                root: {
                    marginLeft: 0,
                },
            },
        },
        MuiInputBase: {
            styleOverrides: {
                root: {
                    borderRadius: '2px',
                    fontSize: 16,
                    '&.Mui-focused .MuiOutlinedInput-notchedOutline': {
                        borderColor: '#33343C !important',
                        borderWidth: '1px !important',
                    },
                },
            },
        },
        MuiSelect: {
            defaultProps: {
                size: 'small',
                variant: 'filled',
            },
        },
        MuiMenuItem: {
            styleOverrides: {
                root: {
                    whiteSpace: 'normal',
                },
            },
        },
        MuiTextField: {
            styleOverrides: {
                root: {
                    '&:hover .MuiOutlinedInput-root .MuiOutlinedInput-notchedOutline':
                        {
                            borderColor: Color.custom.lightGray,
                        },
                    '& .MuiOutlinedInput-root.Mui-focused .MuiOutlinedInput-notchedOutline':
                        {
                            borderColor: '#33343C',
                            borderWidth: '1px',
                        },
                },
            },
            defaultProps: {
                variant: 'filled',
                fullWidth: true,
                size: 'small',
            },
        },
        MuiFilledInput: {
            styleOverrides: {
                root: {
                    backgroundColor: '#FFFFFF',
                    minHeight: '48px',
                    ':after': {
                        borderBottomColor: Color.primary.main,
                    },
                },
                input: {
                    paddingLeft: 0,
                    backgroundColor: '#FFFFFF',
                    boxSizing: 'border-box',
                    height: '48px',
                    '&:-webkit-autofill': {
                        WebkitBoxShadow: '0 0 0 100px #ffffff inset',
                    },
                },
            },
        },
        MuiButton: {
            styleOverrides: {
                root: {
                    width: '140px',
                    height: '38px',
                    fontFamily: Font.body_family,
                    textTransform: 'capitalize',
                    fontWeight: 500,
                    fontSize: '16px',
                    boxShadow: 'none',
                    borderRadius: '4px',
                },
                outlinedPrimary: {
                    borderColor: Color.primary.main,
                    color: Color.primary.main,
                    '&:hover': {
                        border: `1px solid ${Color.primary.main}`,
                    },
                },
                containedPrimary: {
                    '&:hover': {
                        backgroundColor: Color.primary.dark,
                        border: `none`,
                        color: Color.primary.contrastText,
                        boxShadow: 'none',
                    },
                    '&.Mui-disabled': {
                        color: '#C3C7CF',
                        backgroundColor: '#EEF2F7',
                    },
                },
                textSecondary: {
                    backgroundColor: Color.secondary.main,
                    border: `2px solid #FFFFFF`,
                    borderColor: Color.primary.main,
                    color: Color.primary.main,
                    boxShadow: 'none',
                    '&:hover': {
                        backgroundColor: Color.secondary.main,
                        border: `2px solid ${Color.primary.main}`,
                        borderColor: Color.primary.dark,
                        color: Color.primary.main,
                        boxShadow: 'none',
                    },
                },
            },
        },
    },

    typography: {
        fontFamily: Font.body_family,
        fontSize: 16,
        h1: {
            fontFamily: Font.headings_family,
            color: 'rgba(0, 0, 0, 0.9)',
            fontSize: '32px',
            fontWeight: 500,
        },
        h2: {
            fontFamily: Font.headings_family,
            color: 'rgba(0, 0, 0, 0.9)',
            fontSize: '20px',
            fontWeight: 500,
        },
        h3: {
            fontFamily: Font.body_family,
            color: '#33343C',
            fontSize: '16px',
            fontWeight: 'bold',
        },
        h4: {
            fontFamily: Font.body_family,
            color: '#33343C',
            fontSize: '14px',
            fontWeight: 'bold',
            lineHeight: 2,
        },
        h5: { fontFamily: Font.body_family },
        h6: {
            fontFamily: Font.body_family,
            fontSize: '20px',
        },
        subtitle1: {
            fontFamily: Font.body_family,
            color: Color.primary.main,
            fontSize: 16,
            textTransform: 'uppercase',
        },
        subtitle2: {
            fontFamily: Font.body_family,
            color: Color.primary.main,
            fontSize: 14,
            fontWeight: 'bold',
        },
        body1: {
            fontFamily: Font.body_family,
            color: '#33343C',
            fontSize: '14px',
        },
        body2: {
            fontFamily: Font.body_family,
            color: '#6E717D',
            fontSize: '14px',
        },
        button: {
            textTransform: 'none',
        },
    },
    palette: {
        ...Color,
    },
    shape: {
        borderRadius: 0,
    },
})

export const ThemeProvider: React.FC = ({ children }) => {
    return <MuiThemeProvider theme={theme}>{children}</MuiThemeProvider>
}
</file>

<file path="lib/utils/durationUtils.ts">
import {
    CartAvailableBookableItem,
    CartBookableItem,
} from '@boulevard/blvd-book-sdk/lib/cart'

export const getDurationTextFromNumber = (
    durationInMinutes: number | undefined
): string => {
    if (durationInMinutes == undefined) {
        return ''
    }

    if (durationInMinutes < 60) {
        return `${durationInMinutes}min`
    }

    const minutesInHour = 60
    const hours = Math.floor(durationInMinutes / minutesInHour)
    const minutes = durationInMinutes % minutesInHour
    const plural = hours > 1 ? 's' : ''
    let result = `${hours}hour${plural}`
    if (minutes > 0) {
        result = `${result} ${minutes}min`
    }
    return result
}

export const getDurationText = (
    bookableItem: CartAvailableBookableItem
): string => {
    const durationInMinutes = bookableItem?.listDurationRange?.min
    return getDurationTextFromNumber(durationInMinutes)
}

export const getItemAndOptionsDurationText = (
    bookableItem: CartBookableItem
): string => {
    let durationInMinutes = bookableItem.item?.listDurationRange?.min ?? 0
    if (bookableItem.selectedOptions) {
        for (let option of bookableItem.selectedOptions) {
            durationInMinutes += option.durationDelta ?? 0
        }
    }
    return getDurationTextFromNumber(durationInMinutes)
}

export const getDurationInMinutes = (
    startTimeStr: string | undefined,
    endTimeStr: string | undefined
) => {
    if (!startTimeStr || !endTimeStr) {
        return undefined
    }
    const startTime: any = new Date(startTimeStr)
    const endTime: any = new Date(endTimeStr)
    const durationDiffInMs = Math.abs(endTime - startTime)
    return durationDiffInMs / (1000 * 60)
}
</file>

<file path="lib/utils/formatCurrency.ts">
import { CartBookableItem, CartPriceRange } from '@boulevard/blvd-book-sdk/lib/cart'

export function IsNumber(value: any) {
    return !isNaN(parseFloat(value))
}

export function FormatCurrency(number: any) {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
    }).format(number)
}

export function PriceLabelByBookableItem(bookableItem: CartBookableItem) {
    return IsNumber(bookableItem.price)
        ? PriceLabel(bookableItem.price)
        : bookableItem.price
}

export function PriceLabelByRange(priceRange: CartPriceRange) {
    return IsNumber(priceRange.min)
        ? PriceLabel(priceRange.min)
        : priceRange.min
}

export const FreePrice = 'Free'

export function PriceLabel(price: number, freeIsNumber?: boolean) {
    return price === 0 ? (freeIsNumber ? FormatCurrency(0) : FreePrice) : FormatCurrency(price / 100)
}
</file>

<file path="lib/utils/formatDateFns.ts">
import { format as formatFn, toDate } from 'date-fns-tz'

export const TimeFormat = 'h:mma'

export const cartTimeToDate = (
    dateTime: any,
    defaultDate?: Date | undefined
) => {
    if (dateTime === undefined || dateTime === null) {
        return defaultDate
    }
    return toDate(dateTime)
}

export default function formatDateFns(
    date: Date | string | undefined,
    timeZone: string,
    format: string
) {
    if (!date) {
        return ''
    }
    return formatFn(toDate(date, { timeZone: timeZone }), format, {
        timeZone: timeZone,
    })
}
</file>

<file path="lib/utils/getMobileOperatingSystem.ts">
export const getMobileOperatingSystem = () => {
    const userAgent = navigator.userAgent || navigator.vendor

    // Windows Phone must come first because its UA also contains "Android"
    if (/windows phone/i.test(userAgent)) {
        return 'Windows Phone'
    }

    if (/android/i.test(userAgent)) {
        return 'Android'
    }

    // iOS detection from: http://stackoverflow.com/a/9039885/177710
    if (/iPad|iPhone|iPod/.test(userAgent)) {
        return 'iOS'
    }

    return 'unknown'
}
</file>

<file path="lib/utils/getTimeZoneAbbr.ts">
import { format as formatFn } from 'date-fns-tz'

export default function getTimeZoneAbbr(locationTz: string) {
    const currentLocationTimeZone = formatFn(new Date(), 'zzz')
    const storeLocationTimeZone = formatFn(new Date(), 'zzz', {
        timeZone: locationTz,
    })

    if (currentLocationTimeZone !== storeLocationTimeZone) {
        return storeLocationTimeZone
    } else {
        return null
    }
}
</file>

<file path="lib/utils/locationUtils.ts">
import { Location } from '@boulevard/blvd-book-sdk/lib/locations'
import { Store as StoreType } from 'lib/state/store/types'
import { getMobileOperatingSystem } from 'lib/utils/getMobileOperatingSystem'
import { FlyToInterpolator, LinearInterpolator } from 'react-map-gl'

export const mapStyleTheme = 'mapbox://styles/mapbox/streets-v11'
export const defaultLatitude = 40.6976637
export const defaultLongitude = -74.119764
export const countryCanadaShort = 'CA'
export const NebraskaState = 'NE'
export const defaultZoom = 16
export const mapBoxTransitionDuration = 500
export const mapBoxLongTransitionDuration = 2000
export const mapBoxFlyToInterpolator = new FlyToInterpolator()
export const limitedMapBoxFlyToInterpolator = new FlyToInterpolator({
    maxDuration: 1500,
})
export const mapBoxLinearInterpolator = new LinearInterpolator()

export const appExternalUrl = 'https://google.com/'
export const scrollMapToTop = () => {
    window.scrollTo(0, 0)
}

export const getStateOrProvince = (
    location: Location | undefined
): string | undefined => {
    if (location?.address.country === countryCanadaShort) {
        return location.address.province
    }

    return location?.address.state
}

export const getAddress = (store: StoreType | undefined) => {
    if (store === undefined || store.location.isRemote) {
        return ''
    }
    return `${store.location.address.line1}, ${
        store.location.address.city
    }, ${getStateOrProvince(store.location)} ${store.location.address.zip}`
}

export const getLocationName = (store: StoreType | undefined) => {
    if (store === undefined) {
        return ''
    }
    return store.location.name
}

export const getNavigationUrl = (location: Location | undefined) => {
    let address = `${location?.address.line1}, ${location?.address.city}, ${location?.address.country}`
    if (location?.coordinates?.latitude && location?.coordinates?.longitude) {
        address = `${location?.coordinates?.latitude}, ${location?.coordinates?.longitude}`
    }

    switch (getMobileOperatingSystem()) {
        case 'iOS':
            return `maps://maps.google.com/?q=${address}`
        case 'unknown': //probably desktop
            return `https://maps.google.com/?q=${address}`
        case 'Android':
            return `geo://maps.google.com/?q=${address}`
        default:
            return `https://maps.google.com/?q=${address}`
    }
}
</file>

<file path="lib/utils/numberUtils.ts">
export function roundNumber(num: number, decimalPlaces: number = 0) {
    const p = Math.pow(10, decimalPlaces)
    return Math.round((num + Number.EPSILON) * p) / p
}
</file>

<file path="lib/utils/sortUtils.ts">
export const sortByDate = (a, b) =>
    a.date > b.date ? 1 : b.date > a.date ? -1 : 0
export const sortByDistance = (a, b, selectedStore) =>
    a.location.id === selectedStore?.location?.id ? -1 : a.distance - b.distance
</file>

<file path="lib/utils/stepUtils.ts">
import { Step } from 'lib/state/booking-flow/types'

export const getStepFromPath = (pathname: string, initialStep: Step) => {
    const parts = pathname.split('#')
    let step = initialStep
    if (parts.length > 1) {
        const hash = parts.pop()
        step = Step[hash!]
    }
    return step ? step : initialStep
}
</file>

<file path="lib/utils/stringUtils.ts">
export const getFieldValueOrUndefined = (value: string | undefined) => {
    let result: string | undefined
    if (value?.length && value.length > 0) {
        result = value
    }
    return result
}
</file>

<file path="lib/utils/useMobile.ts">
import { useMediaQuery } from '@mui/material'
import { isMobile as isMobileNative } from 'react-device-detect'

export const useMobile = (mediaQuery: string | undefined = undefined) => {
    const isMobile = !useMediaQuery(mediaQuery ?? '(min-width:930px)', {
        defaultMatches: !isMobileNative,
    })
    return {
        isMobile: isMobile,
    }
}
</file>

<file path="lib/wrappers/ip-wrapper.ts">
import Axios, { AxiosInstance, AxiosRequestConfig } from 'axios'
import { Logger } from 'lib/wrappers/logger'

export class IpWrapper {
    private readonly client: AxiosInstance
    private readonly baseUrl: string

    constructor(logger: Logger, baseUrl: string) {
        this.client = Axios.create()
        this.baseUrl = baseUrl
        this.client.interceptors.request.use((request) => {
            logger.log({
                data: request.data,
                url: request.url,
            })

            return request
        })
        this.client.interceptors.response.use(
            (response) => {
                // For unhandled promise rejection
                logger.log({
                    data: response,
                })

                return response
            },
            (error) => {
                // For unhandled promise rejection
                logger.error({
                    err: error,
                })

                return error
            }
        )
    }

    private getIpInternal() {
        return this.get(this.baseUrl, {})
    }

    async getIp() {
        try {
            const data = await this.get(this.baseUrl, {})
            return data.ip
        } catch {}

        return ''
    }

    private async get(url: string, data: any): Promise<any> {
        return (await this.client.post(url, data, IpWrapper.getConfig()))?.data
    }

    private static getConfig(accept = 'application/json'): AxiosRequestConfig {
        return {
            headers: {
                Accept: accept,
            },
        }
    }
}

const apiUrl = 'https://ipapi.co/json/'
export const ipWrapper = new IpWrapper(new Logger(false), apiUrl ?? '')
</file>

<file path="lib/wrappers/logger.ts">
export class Logger {
    private readonly enabled: boolean
    constructor(enabled: boolean) {
        this.enabled = enabled
    }

    log(message?: any) {
        if (!this.enabled) {
            return
        }

        console.log(message)
    }

    error(message?: any) {
        if (!this.enabled) {
            return
        }

        console.error(message)
    }
}
</file>

<file path="pages/_app.tsx">
import { RecoilRoot } from 'recoil'
import LocalizationProvider from '@mui/lab/LocalizationProvider'
import CssBaseline from '@mui/material/CssBaseline'
import AdapterDateFns from '@mui/lab/AdapterDateFns'
import { Header } from 'components/molecules/Header'
import { ThemeProvider } from 'styles/theme'
import 'lib/styles/styles.scss'
import 'lib/styles/styles.daypicker.scss'
import 'bootstrap/dist/css/bootstrap.css'
import { FlowRouting } from 'components/molecules/FlowRouting'
import { CartDefinition } from 'components/molecules/CartInitializer/CartDefinition'
import { AppHead } from 'components/atoms/AppHead'

/**
 * A custom App in Next.js gives us the ability to customize global
 * elements like Nav, global context providers, and meta tagging +more.
 * @see https://nextjs.org/docs/advanced-features/custom-app
 */
export default function App({ Component, pageProps }) {
    // MUI<->Next compatibility: Clears out MUI server-side generated CSS
    // https://github.com/mui-org/material-ui/blob/master/examples/nextjs/pages/_app.js

    return (
        <RecoilRoot>
            <AppHead/>
            <ThemeProvider>
                <LocalizationProvider dateAdapter={AdapterDateFns}>
                    <CssBaseline />
                        <FlowRouting />
                        <CartDefinition />
                        <div
                            className="background-container"
                            style={{ flex: 1 }}
                        >
                            <Header />
                            {/* <MobileSummary /> */}
                            <Component {...pageProps} />
                        </div>
                </LocalizationProvider>
            </ThemeProvider>
        </RecoilRoot>
    )
}
</file>

<file path="pages/_document.tsx">
import Document, { DocumentContext } from 'next/document'
import { ServerStyleSheet as SCServerStyleSheet } from 'styled-components'
import { ServerStyleSheets as MuiServerStyleSheet } from '@mui/styles'

/**
 * Adds Server-side Rendering support for stylesheets
 * generated by both Styled-Components & MaterialUI.
 *
 * Next.js' _document page allows us to customize the
 * final HTML output produced by the framework.
 * @see https://nextjs.org/docs/advanced-features/custom-document
 */
export default class MyDocument extends Document {
    static async getInitialProps(ctx: DocumentContext) {
        const scSheet = new SCServerStyleSheet()
        const muiSheet = new MuiServerStyleSheet()
        const originalRenderPage = ctx.renderPage

        try {
            ctx.renderPage = () =>
                originalRenderPage({
                    enhanceApp: (App) => (props) =>
                        scSheet.collectStyles(
                            muiSheet.collect(<App {...props} />)
                        ),
                })

            const initialProps = await Document.getInitialProps(ctx)
            return {
                ...initialProps,
                styles: (
                    <>
                        {initialProps.styles}
                        {muiSheet.getStyleElement()}
                        {scSheet.getStyleElement()}
                    </>
                ),
            }
        } finally {
            scSheet.seal()
        }
    }
}
</file>

<file path="pages/index.tsx">
import type { NextPage } from 'next'
import { Container } from 'components/Container'
import { BlockContainer } from 'components/blocks/BlockContainer'

const HomePage: NextPage = () => {
    return (
        <Container>
            <BlockContainer />
        </Container>
    )
}

export default HomePage
</file>

<file path="public/images/arr-l.svg">
<svg width="8" height="12" viewBox="0 0 8 12" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M7.41 1.41L6 0L0 6L6 12L7.41 10.59L2.83 6L7.41 1.41Z" fill="black" fill-opacity="0.54"/>
</svg>
</file>

<file path="public/images/arr-r.svg">
<svg width="8" height="12" viewBox="0 0 8 12" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.99984 0L0.589844 1.41L5.16984 6L0.589844 10.59L1.99984 12L7.99984 6L1.99984 0Z" fill="black" fill-opacity="0.54"/>
</svg>
</file>

<file path="public/images/image 1.svg">
<svg width="34" height="32" viewBox="0 0 34 32" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <rect y="0.200195" width="34" height="31.24" fill="url(#pattern0)"/>
    <defs>
        <pattern id="pattern0" patternContentUnits="objectBoundingBox" width="1" height="1">
            <use xlink:href="#image0_1116:23784" transform="translate(-0.225 -0.4) scale(0.025 0.03)"/>
        </pattern>
        <image id="image0_1116:23784" width="58" height="80" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAABQCAYAAABI1GYUAAATX0lEQVR4Ac1be3Bc1XlXO5PH5K9Mp6STfzuTmYR0Mpkx1u7du1e7emIbaCi1du9rH/KDYCilhBJIGEITUtNQQuoEDGQKgQLTkoKnFFoIBgzFGCzZkmW937uS9n31lixpvatf5zvn3t3VYyXZWo2lmTu7unvvud/vfK/f951zy8q24S96y66vJDz2mrjX/lBSEV5KKsKZlCyEUrIwllKERXbQd1kIGbJwxvAKLxle+0OGx15D926DSKUbsk2p/jNDdvxtShY/MbzOdEIRkFDsSCnCuochC1h2eIV0SnZ8QmPRmKWTcIsjNfnq/qJLrz4RU6SM4XXA8DphyE6kFHFdgNYELAO5AnRElTIdeu0JesYWxbz62y+q1X+eksWXDdmR5QAJpAmUgRWZpixAxT7XA2rINAZNnJg1ZPFleubVS3yFd7b66r7W6XM/M6pKadIaE4aA5Q4LsPkpX6HprtBqbhIVO0Y1R7oz4H7mU1/d165Q7Cu7PO4V7SlFiBg53zOBslm3wBLA5X5XTJt0fn2NCtxKCDw9U+U+n1CESFyz2a9M+k1eHdZch+OKuJhQHKCD+6DIvlv/c+06mPAJtRwJrXzDgLQpoOQSTNMiUuT/soSE6lwc0VyHNyn+xpd1XH/9FxOy4zkO0ImEQkchUIqu/GDCmEIRyFgpgbJxuc8SUEPlx5jueK6j/vovboxknSvO7dr1hYjiPEkAuPlRJOXR1NJEoVla59j1ZGamqRWe3/p3y124HDHZhpAqnjx3+64vrANl/Z8MzfH81gXbhB+uDECb/J8mOakJSKh2JP2O59dHU+TXsM/9YMzLNbmTwRoaxQw7Iko5Rg64HywCZ+3TSU3aH1fEJUOXmMnuaKCqAynZxjQbUe1LJPvaqFacbdb2Xp+SnZeSqgg6NpUCNmlq2zNhdhiynWk1oZIpi5cIwwpYy/9FWdkfdQeqTlOaIJA8um6fj5UGOAdKCqHoT8Gp3V95mrAsR1fwX7vmOjyqVpihW0SSou2K5F8a4Uo5eTwKW0CTqgMjuoT2YJEc23f33i8lFGGUEjLLUbKIVC535UN6HijNJAUrEXHFiYgqYlSVENYlhLUKhMyD/h/WJMRMC+H3cy2QyVkpaJmLWCxIpevEPDta5SJ5ueh+a6yE146kYh/t27v3SwV65F/PH7rxrrhiK+CuFkGXYHjNg1E9omV0nY19xhQJYV8legKVaPFVoilYi8aDe3D24D581rAHZ4O1aG2oQX+gEiO6E4ZG9++GUX8DDJnYkw0xjfsYCUrgaeykthsJlZ5D1JKez9mRBSY/AQSWU0SiiYbqyB0tgdq7lgEle24NVg7kgVqUi0yMl11mFYH4fhsLUOQLQ6qI4ftUTP7LQ5j9w0uYP/sWFrs+QnroLNKhJiz2nMZ84/9g7uQrmHr2EXTfJ+Oivwr9WgWGvXZEPTbEFTsoiJB/ca0WAi03Jz4PlFsRtyReVJhuQCBXAO3y1Qws89U2vcY9KAuIs9nkM0Szybgq0TiVHkgCCIxrRjQJnYqI2bd/i0xqENmpJDITMWQnI8hMDCM7GUZ2agCZiSFkJuLITKSQnYohOzWKxd5GxJ9/AucP7UeftgcJ2Q3DU2gx/Pkpej7xZfq0QBSYLk1OTLMmp8Dncxql351o093unFYTXsfv4rJF1rmtc1K+GzHtBhMomSrNvBNhRUKnrwLzLW8hMz6IzFgY82c/xNT//h4jLx5D39M/Q+/xRzDy4i8x+d+/x/y5z3A5HkJ2LskmIzsdx0JnM6aefQKd+j6ElVrE5Eok5Iocl7Y6FMysyaQJLAVGMzgSyI2AGqqASP2u3zGgpFpDdyWSVE+ygEEBwgaD/FWx5Ryc+YGXk/moIiKsi+j2Swj9fT0uHrkFrYEadAVqMRCow1CgDv3+WnQHatB36GY0++vQccetGP6HOzH7h//A5VgvslMJZKcTWOxuxOd/50ebXI1wvYi45kSS2I4qIa5IiMpO9p3XpXnNWYXEsiBWoHEmL/2vOhLMfMeV6u/E6k1f1KgyMYFSsGEHmRIFBKuQ5vmVzajuQNwnspllZk9mo7COAL9e4fmYrCXicWBQcaHZvwctPzyIufffQHY6guzkKNIjHYg/+RM0Bm/GuUAdWoJ1uNCwFxcP3oToA36M/7gBUapYWMfBAmvFDjMYrQXSzArjivSdMsNbfjdFQaJRNDu5oEB+qZabAcIqqjkIVrKpAih4JbzlSJoUjAILCy4UWMjMvXaWwDljkRDTXBhS3WhTXDjfUIPhx+9Feugi9+PxGGbP/B8uffoxFtrO4XK0B9npYWTG+rHQ+gH6fLVmYCQXIjOWYHgqctE4p8GVgFUnkvvtd5cZqv0ZwzJVCv0W7bNMl3UBCmeP00LSPAsSqgDDLyHlc2LUa0NUoaDmQNL0+bgusRwbVxwwfG4kNRdGPQ6MKE60+arw2f0HsNDWhKVLc1hayCI7m0Z2dhZLC+NYmo8gY/Rg4tUn0R/cg6SHsoGV2iiAVazQsqXtgk9q96jSM2WGIpxijm6FZmtGlkU6Mo/lJsLymRkkKNUQoFEqyuUKMH/XK5HQ3AjpVRhUJCQ1bnoprxMprwT6DClunA/uxdBTR5GdmsHSIpCdvoTMxDiyUyO4HGvBzGuPo6WhkpGQfDqx2qh80hlZKNJWZXlVEU6VpTRhMKd28jEL6EafZt8oqYkY0CS0HdiLwXs86PfVYMRXhT7FjTa9GslH/wZTzzyMUX+lmRNFGPVOGB4norIL3f4bMfXCk8hOT2NpPoP5C+fQ8dTj6D/+c3x8jxdng9Xo0p0sVRgaBUxLRgK5OaApVRgsS6mOVA5cbpAC1a8DmMyRSEPoAR3pcCsyRj9m/vMYTgeqcfrQTZh9k/JsJ9IDZ9DTUAdD4YmfqGVcdiIsV6I7cBNmTryC7NwUsnOTmPvoTXzw/VvxzuG/QviJH6Lnfh/a/TUIeR1Ieqy8SZPl5gfrIfPza2mWJoYwlhmauLgVoKTN6VefQHYqwghBevBTfPz9vWj5p3uQnaHcOYzFrk/REdwDo97BghQVC3FZZIHpYsNNmPvgBJbmp5CdjWPmxK9x9vYbMfvuq7gc68HlaBuiD9/OrIQmiNNEIQ+UXKGI2dJ5kxIuEtCZqwVK0ZcI+8RPjyA93MUi5dzJl9B4+82YfYe0FMfSvIG5U2+hP3ATjHozkKkUyAQM6k6cu70WCxfeQXYuxdLN6NFDOH9kD9JDF5AZiyCTGsD0y79CH7mBV+TEgfFsk4tT8bEx0JkyQ3X0XC1Q8pGI7EBvQx0uPngHuo8+gLOHvocPD9+KS40nkZ2OITtrYOa//g1Dvj2syc0SvUb0zoaw7kDbkVqkB04hY/Rh7LXjaD3gRotfwsyJF3A5PoD0YBPCj96FPr2KAzVJf05mlivXN11DcfQQ0I9yN12hj9JMxmUb00zTwb9E472HMfirf0TzU/+MyfZzWFocR3ZmBInnH0NIr2FA6R4CmVJ3I6LZ0NvgwuSx+zHxsyO4oFdh2OdE1CehV69G5O569B+qRX/QxYORSqkiH4woE/CAVFyrpul+VDamic9aqs8PUlD2rBOMSDvDugPtATdmXvsN0qEuZAwi8NNYWpwFspPIzo2g4zc/QZtei6TmZlyWnkdkhAAPyw5E/ZWslk35KjhBodxM6Ux1wghQs9okHiwYWaku/7le9CVMY4rwbFncU66w5K+aEY1RPS5IitgR5dMiYKnQbvdXY/rVJ5GdHcXS/CSWFpewNJ/GUnoayIxjKT2Gxb7zaPlBAL16HUbVStZpZ0D8bhOQWUNSNWKRF5OwJPbfgIRnN2vtUFeSJpfJY1FSs04tJiMnQE6lLHTbrq8Tb6VUQcElR56J/m0S6GLvJyy1UPBJj4ax2HMR883vY+rzt5CdjSE7HUU61IHhn9+HJr2O5dph1YUkddtpEhlZ4RybgFoHLyzodxExLyf6DChdbwEtooQccEovt0lfZxVMRBW7qR3C2igb3VjwO01MWHVg/McyUj/S0X3nrbjgq2O+1hp0o+lQHaLHHkY63IXMeASZsWHMnXoD538UQLOvCiEfMSYBhmaDYXYZWLBinJtXSgkP5VwRCd3FPpnZU0AqKNlyoApky7mjJnTn6tFR1fEo1Zm5KoXdYPlAcfJgEXfitrzZbQYLhXo2u2mZD22yG+33H8RC+xmmXVaMJzow9/4riBy9Ey0HatDeUEmdO3T6q9Dpr0anv4Ydbf46VuK1HrgZ8QcPYuDwzRilgETybaBRBpQoqmp/NAc06rN/i/gqmYi1Ys0qFDM/rTVj/Bw10Ii3EuOh72aDivyMmb6dkfg+WUL3Hfsw9fxPsdjfhIwxiOxMAkvzKWSMAVz6/D1MvvkKBp79JYaOP46Bpx7D8Au/QvyNf8V844fIGCPIpEax0PopunzV3PLomazNYwIv0CbJltOo1/6tHFD6ElYdzSzqstVqvjRPZsRNpZhWRSQ9eaC8+qduAE0aBTI6BKTqy1mbJtRQjcbD30PqxWNY6GhCdjqJpfkxVoAz056I43IihIwRRmY8zNsyc1FGPLJTccy++zrTNFkfW1HbAOiIKjUvA0n/dPpq7uUmYdWeVr4qBpJPAqtBzbKMmZOHzIrAmkDJUjw2GPsFJD0iwloleny1aA3uQ9d9AUz99jHMvffvmG96F4tdnyA90syOxd4zWGh5F3MnX8Dkcw+i/wcetOuVCGku1l5lUXuDiNvuq7x3FdCW4K1fTXnEWb5ET9E3358pZrqkbSq+o6qNN9bowRZQVjfuhuEtNwtligES60BQgElQm8RfhZ5gLS427EHTgTo0Ht6L0wfr2EGt0s+DNbjQ4EJvUEJEFxH1Cqw/TIEzlx1WmGxOVq8weyro/uoqoHTCqJeOcx9d2+5zgxQMbvnCKhPP1bNmHjabWsw9WDFMbRbqOlSwzvqwT0JId+Ua39QA581vERGVJsbyO86G8rLwoGnVxzl55PLja4KkkxeVum/GZGkpT62Km23+Qdf4GtN8C4GOqs6lnqD7m0WB0g9devU7zP5ZR2Hzmr1mwCkeWD1ns+fV5at8Z12Q9GOTVityoIV9omustQJXWTWhJlAyWZ4SHWgK1IobAqULDK/jfZ6jCOxO1ypvbjPiT01t1fn+pkDSRR16tRSh5cMdD5LzZPJPAhrSRbTqN0qbBsrA+qo+LAZ0VYRdz7S2+TcGkiinJqAt4P7wikDSxeeDNXay+bVAsRDONjZdW9PmfkmFvIC47gDJfMVA6YZRVXw9rvMtLly7RNp5wympuJFUqq644lkVTLagcdZko9UBTSQi8fpVgaSbWtSKb4R08XJSI4fnidmgioDt7XEhobqvPVCZGnSuy51q7TeuGijd2B50Pc3AFQKlDUyaANovsJZpl1Jr641F1RItfXQFqp/aEki6ublBus5QbBMGdR+YmbEaj+o8bsZbML31QGzmN+rzJr3iRHPD3uu2DJQGMFTpCGMfbO9CQdG7QfWwGWG3cg01xQy16khJQNIgKCv747hXPGdRLV45mBXENdToiOo6R7KVDCgNNOi/sdxQaMs355YWid6KRrZ4b7ZDrSovKUhrsIRXeI4X1VbLpHgrdIsgzHhAHNssw1Z0OxKy7TlLrpJ/TtULf5Ly2lPUHyIgFPVKB2itseg5vDtp9bDYbjbNkSJZSg6wcMARWTxIi0WGRlx4LeFKeY6adRLrD1FXIaY62NaBEZ94sFCmbflOOzySmvsMrWxFbtu9zWDNrqSX71ChbXYxTTizbJPUtqA0B+0I7vvusOrKUO+nGPEvrbZpJ4xEjbFMS9D93e3Etmrs3oZ9v+AtR+6vpQVmmr+5VEENtoRHwAWt8herBNnuE6fc7i8bekUPS9rb5asEVBeQ8NxAy4U9Q0H3l7cb15rjjwcqxZQiZLdFmwWTR89IeKTNtUfWlLQEJ8Oa+OurJ/Y8ffC2zfJozWpeyp1eByJqxbESiLq1Id66ZddX4rKtNyeY+b4L1/JG/ks00m0e1DQ3lwNp9Yxt2KJWibP33E55p7TZ7xJGVTFD4HJrmwWmV9y0LaC01c1cyjBf5iOgYV3MdCnVwtZUUeK7u7TKo8SDLQ7MPq3V6fVAM4BktmZ/tgBoa8B1tMRibn04ej9szGu7QCacXz5Y7ndrapaZa74JTXmZInlcsV/Y8jtnW4e19ghjivjthCLMU7OKr55vonlGNa2pRQJJ90ZU+3z4r8Vvr/2UHXI2pDnvIgKef+FgvYBkUTzyVb4mG1EFDPqE5Zv+dwi2VWKMeZxvs720m9hPa5m6tTMmqjneXjXgTj3RVy9dF/e6IsU3Dlv5k9IIf1uQOu1hzRGhHtVOxbWmXF3BPW5DlThrYgtBPDCxzU9s6zrPn3wDZDmSHlu2K1iTf6NhzVF36MmI7H6EVTcssnKgvIDO50+2ScRfgYin4pEdCmNjsahxFZVd73HGw9suHKjZOlXsiMrlGFKc75W8ybWxeKW9okdx/6nhdQxb29n5O+JOtluMWFTcJw7TNaV96jUaLVYvlCeU8gXa5MjTDn+jMaGKCyOqtD2dvGuEtWxQF/yFQOkFnkG9wn+t5NnW5yYV4TFO72hhyLbzeGwp0Se9jqcjmv3pUo65mbH+H+Dtgl0xwuLJAAAAAElFTkSuQmCC"/>
    </defs>
</svg>
</file>

<file path="public/images/logo.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="88px" height="88px" viewBox="0 0 88 88" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>logo</title>
    <g id="logo" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M78.785,76 L78.785,74.2 C76.985,74.08 75.635,73.84 74.735,73.48 C73.835,73.12 73.22,72.4 72.89,71.32 C72.56,70.24 72.395,68.62 72.395,66.46 L72.395,66.46 L72.395,21.82 C72.395,19.6 72.545,17.965 72.845,16.915 C73.145,15.865 73.76,15.145 74.69,14.755 C75.62,14.365 76.985,14.14 78.785,14.08 L78.785,14.08 L78.785,12.28 C77.165,12.34 75.005,12.4 72.305,12.46 C69.605,12.52 66.725,12.55 63.665,12.55 C60.725,12.55 57.8,12.52 54.89,12.46 C51.98,12.4 49.595,12.34 47.735,12.28 L47.735,12.28 L47.735,14.08 C49.535,14.14 50.9,14.365 51.83,14.755 C52.76,15.145 53.375,15.865 53.675,16.915 C53.975,17.965 54.125,19.6 54.125,21.82 L54.125,21.82 L54.125,43.061 L33.875,43.061 L33.875,21.82 C33.875,19.73875 34.0068359,18.1716602 34.2705078,17.1187305 L34.325,16.915 C34.625,15.865 35.24,15.145 36.17,14.755 C37.1,14.365 38.465,14.14 40.265,14.08 L40.265,14.08 L40.265,12.28 C38.525,12.34 36.29,12.4 33.56,12.46 C30.83,12.52 28.055,12.55 25.235,12.55 C21.995,12.55 18.95,12.52 16.1,12.46 C13.25,12.4 10.955,12.34 9.215,12.28 L9.215,12.28 L9.215,14.08 C11.015,14.14 12.38,14.365 13.31,14.755 C14.24,15.145 14.855,15.865 15.155,16.915 C15.455,17.965 15.605,19.6 15.605,21.82 L15.605,21.82 L15.605,66.46 C15.605,68.62 15.455,70.24 15.155,71.32 C14.855,72.4 14.255,73.12 13.355,73.48 C12.455,73.84 11.075,74.08 9.215,74.2 L9.215,74.2 L9.215,76 C10.955,75.88 13.25,75.805 16.1,75.775 C18.95,75.745 21.995,75.73 25.235,75.73 C28.055,75.73 30.83,75.745 33.56,75.775 C36.29,75.805 38.525,75.88 40.265,76 L40.265,76 L40.265,74.2 C38.465,74.08 37.115,73.84 36.215,73.48 C35.315,73.12 34.7,72.4 34.37,71.32 C34.04,70.24 33.875,68.62 33.875,66.46 L33.875,66.46 L33.875,44.86 L54.125,44.86 L54.125,66.46 C54.125,68.485 53.9931641,70.0353906 53.7294922,71.1111719 L53.675,71.32 C53.375,72.4 52.775,73.12 51.875,73.48 C50.975,73.84 49.595,74.08 47.735,74.2 L47.735,74.2 L47.735,76 C49.595,75.88 51.98,75.805 54.89,75.775 C57.8,75.745 60.725,75.73 63.665,75.73 C66.725,75.73 69.605,75.745 72.305,75.775 C75.005,75.805 77.165,75.88 78.785,76 L78.785,76 Z" id="H" fill="#333F48" fill-rule="nonzero"></path>
        <g id="logotype" transform="translate(0.250000, 31.975155)">
            <rect id="Rectangle" fill="#333F48" x="1.36645963" y="1.0931677" width="85.2670807" height="22.136646" rx="3"></rect>
            <path d="M18.310559,17.4906832 L18.310559,17.1895989 C17.984448,17.1695266 17.7398648,17.129382 17.5768093,17.0691652 C17.4137539,17.0089483 17.3042009,16.8885146 17.2481506,16.707864 C17.1921003,16.5272134 17.1640751,16.2562375 17.1640751,15.8949363 L17.1640751,15.8949363 L17.1640751,8.42804506 C17.1640751,8.05670772 17.1895526,7.7832228 17.2405074,7.60759027 C17.2914622,7.43195775 17.4010151,7.31152402 17.5691661,7.24628908 C17.7373171,7.18105415 17.984448,7.14341861 18.310559,7.13338246 L18.310559,7.13338246 L18.310559,6.83229814 C18.0557848,6.84233428 17.7220306,6.85237042 17.3092964,6.86240657 C16.8965622,6.87244271 16.4558029,6.87746079 15.9870184,6.87746079 C15.5488068,6.87746079 15.1080474,6.87244271 14.6647403,6.86240657 C14.2214332,6.85237042 13.8622016,6.84233428 13.5870455,6.83229814 L13.5870455,6.83229814 L13.5870455,7.13338246 C13.9029655,7.14341861 14.145001,7.18105415 14.3131519,7.24628908 C14.4813029,7.31152402 14.5934036,7.43195775 14.6494539,7.60759027 C14.7055042,7.7832228 14.7335294,8.05670772 14.7335294,8.42804506 L14.7335294,8.42804506 L14.7334984,11.9808401 L10.6825887,11.9808401 L10.6826197,8.42804506 C10.6826197,8.08527213 10.7043283,7.82587641 10.7477454,7.64985788 L10.759052,7.60759027 C10.8100068,7.43195775 10.9195597,7.31152402 11.0877107,7.24628908 C11.2558616,7.18105415 11.5029926,7.14341861 11.8291036,7.13338246 L11.8291036,7.13338246 L11.8291036,6.83229814 C11.5539474,6.84233428 11.2074545,6.85237042 10.7896249,6.86240657 C10.3717952,6.87244271 9.94887004,6.87746079 9.5208494,6.87746079 C9.02149198,6.87746079 8.5603507,6.87244271 8.13742554,6.86240657 C7.71450038,6.85237042 7.37055522,6.84233428 7.10559006,6.83229814 L7.10559006,6.83229814 L7.10559006,7.13338246 C7.42151006,7.14341861 7.66354554,7.18105415 7.83169651,7.24628908 C7.99984747,7.31152402 8.11194812,7.43195775 8.16799844,7.60759027 C8.22404876,7.7832228 8.25207392,8.05670772 8.25207392,8.42804506 L8.25207392,8.42804506 L8.25207392,15.8949363 C8.25207392,16.2562375 8.22404876,16.5272134 8.16799844,16.707864 C8.11194812,16.8885146 8.00239522,17.0089483 7.83933973,17.0691652 C7.67628425,17.129382 7.43170103,17.1695266 7.10559006,17.1895989 L7.10559006,17.1895989 L7.10559006,17.4906832 C7.37055522,17.4706109 7.71450038,17.4580658 8.13742554,17.4530477 C8.5603507,17.4480296 9.02149198,17.4455206 9.5208494,17.4455206 C9.94887004,17.4455206 10.3717952,17.4480296 10.7896249,17.4530477 C11.2074545,17.4580658 11.5539474,17.4706109 11.8291036,17.4906832 L11.8291036,17.4906832 L11.8291036,17.1895989 C11.5029926,17.1695266 11.2584094,17.129382 11.0953539,17.0691652 C10.9322984,17.0089483 10.8227455,16.8885146 10.7666952,16.707864 C10.7106449,16.5272134 10.6826197,16.2562375 10.6826197,15.8949363 L10.6826197,15.8949363 L10.6825887,12.2819244 L14.7334984,12.2819244 L14.7335294,15.8949363 C14.7335294,16.2284451 14.7096499,16.4849903 14.6618911,16.664572 L14.6494539,16.707864 C14.5934036,16.8885146 14.4838506,17.0089483 14.3207952,17.0691652 C14.1577397,17.129382 13.9131565,17.1695266 13.5870455,17.1895989 L13.5870455,17.1895989 L13.5870455,17.4906832 C13.8622016,17.4706109 14.2214332,17.4580658 14.6647403,17.4530477 C15.1080474,17.4480296 15.5488068,17.4455206 15.9870184,17.4455206 C16.4558029,17.4455206 16.8965622,17.4480296 17.3092964,17.4530477 C17.7220306,17.4580658 18.0557848,17.4706109 18.310559,17.4906832 L18.310559,17.4906832 Z M23.2490139,11.9808401 L23.249018,8.24739446 C23.249018,7.92623785 23.2744596,7.6928975 23.3253427,7.54737341 C23.3762259,7.40184932 23.4754481,7.30399691 23.6230093,7.25381619 C23.7705706,7.20363547 23.9970007,7.17854511 24.3022998,7.17854511 L24.3022998,7.17854511 L24.9281629,7.17854511 C25.3861116,7.17854511 25.7855446,7.26636137 26.1264619,7.44199389 C26.4673792,7.61762642 26.7446925,7.91871074 26.9584019,8.34524687 C27.1721112,8.77178299 27.3298491,9.35137032 27.4316155,10.0840088 L27.4316155,10.0840088 L27.7827094,10.0840088 C27.7725328,9.96357511 27.7623561,9.81303295 27.7521795,9.63238236 C27.7420029,9.45173176 27.7369146,9.26104502 27.7369146,9.06032214 C27.7369146,8.83952697 27.744547,8.52338843 27.759812,8.11190652 C27.7750769,7.70042461 27.8030627,7.27388848 27.8437692,6.83229814 C27.375644,6.85237042 26.8439147,6.86491561 26.2485815,6.86993368 C25.6532483,6.87495175 25.121519,6.87746079 24.6533938,6.87746079 L23.2795479,6.87746079 C22.7096562,6.87746079 22.1041464,6.87244271 21.4630183,6.86240657 C20.8218902,6.85237042 20.226557,6.84233428 19.6770186,6.83229814 L19.6770186,6.83229814 L19.6770186,7.13338246 C19.9924944,7.14341861 20.2341895,7.18105415 20.402104,7.24628908 C20.5700185,7.31152402 20.6819615,7.43195775 20.737933,7.60759027 C20.7939045,7.7832228 20.8218902,8.05670772 20.8218902,8.42804506 L20.8218902,8.42804506 L20.8218902,15.8949363 C20.8218902,16.2562375 20.7939045,16.5272134 20.737933,16.707864 C20.6819615,16.8885146 20.5725626,17.0089483 20.4097364,17.0691652 C20.2469103,17.129382 20.002671,17.1695266 19.6770186,17.1895989 L19.6770186,17.1895989 L19.6770186,17.4906832 C20.226557,17.4706109 20.8218902,17.4580658 21.4630183,17.4530477 C22.1041464,17.4480296 22.7096562,17.4455206 23.2795479,17.4455206 L23.2795479,17.4455206 L24.6533938,17.4455206 C25.1622256,17.4455206 25.7422938,17.4480296 26.3935986,17.4530477 C27.0449033,17.4580658 27.6300599,17.4706109 28.1490683,17.4906832 C28.0981851,17.0390567 28.0676552,16.6024845 28.0574786,16.1809664 C28.047302,15.7594484 28.0422136,15.4332737 28.0422136,15.2024424 C28.0422136,14.6805629 28.0574786,14.2590448 28.0880085,13.9378882 L28.0880085,13.9378882 L27.7369146,13.9378882 C27.6046183,14.7407797 27.4138064,15.3780749 27.1644788,15.8497737 C26.9151512,16.3214724 26.6149404,16.6551742 26.2638465,16.850879 C25.9127525,17.0465839 25.5082312,17.1444363 25.0502826,17.1444363 L25.0502826,17.1444363 L24.3022998,17.1444363 C23.9970007,17.1444363 23.7705706,17.1193459 23.6230093,17.0691652 C23.4754481,17.0189845 23.3762259,16.918623 23.3253427,16.7680809 C23.2744596,16.6175387 23.249018,16.3867074 23.249018,16.0755869 L23.249018,16.0755869 L23.2490139,12.2819244 L23.7374965,12.2819244 C24.1174243,12.2819244 24.4308647,12.3627934 24.6778177,12.5245315 L24.7297185,12.5604274 C24.9841344,12.7460961 25.1800347,12.9894726 25.3174193,13.2905569 C25.4548039,13.5916412 25.5489378,13.9178159 25.5998209,14.269081 L25.5998209,14.269081 L25.9509149,14.269081 C25.9482011,14.2309436 25.9455552,14.1934084 25.9429771,14.1564754 L25.9216062,13.8403369 C25.897725,13.4738169 25.882053,13.1801593 25.8745901,12.9593641 C25.8644135,12.6582798 25.8593252,12.3822859 25.8593252,12.1313823 C25.8593252,11.8804786 25.856781,11.6044847 25.8516927,11.3034004 C25.8466044,11.002316 25.8644135,10.5657438 25.90512,9.99368355 L25.90512,9.99368355 L25.5540261,9.99368355 C25.5031429,10.2646594 25.4115532,10.5531986 25.2792569,10.859301 C25.1469606,11.1654034 24.9586929,11.4288522 24.7144536,11.6496473 C24.4702143,11.8704425 24.144562,11.9808401 23.7374965,11.9808401 L23.7374965,11.9808401 L23.2490139,11.9808401 Z M36.403448,17.4906832 L36.403448,17.1900236 C36.076432,17.1699796 35.83117,17.1298916 35.667662,17.0697597 C35.5041541,17.0096278 35.3942971,16.8893639 35.3380913,16.7089681 C35.2818854,16.5285723 35.2537824,16.2579786 35.2537824,15.897187 L35.2537824,15.897187 L35.2535382,12.387236 L37.0625896,8.87678385 C37.3308449,8.36942067 37.5766458,7.98317283 37.7999923,7.71804033 L37.8443622,7.6666287 C38.0794049,7.401046 38.309338,7.2231557 38.5341615,7.1329578 L38.5341615,7.1329578 L38.5341615,6.83229814 C38.3808728,6.84232013 38.2045907,6.85234211 38.0053153,6.8623641 C37.80604,6.87238609 37.5939906,6.87739709 37.3691671,6.87739709 C37.0523703,6.87739709 36.7406832,6.87238609 36.4341057,6.8623641 C36.1275283,6.85234211 35.8005123,6.84232013 35.4530578,6.83229814 L35.4530578,6.83229814 L35.4530578,7.1329578 C35.872047,7.14297979 36.1965082,7.23568319 36.4264413,7.41106799 C36.6563744,7.58645279 36.7585669,7.87959597 36.7330188,8.29049751 C36.7074707,8.70139905 36.5056405,9.26764142 36.1275283,9.98922461 L36.1275283,9.98922461 L34.9367415,12.3358733 L32.6018872,7.92970591 C32.4880156,7.71566486 32.4622589,7.55563262 32.5246172,7.44960918 L32.5405717,7.42610097 C32.6223257,7.32087009 32.7653952,7.24821067 32.9697802,7.20812272 C33.1741652,7.16803476 33.4040983,7.14799078 33.6595796,7.14799078 L33.6595796,7.14799078 L33.6595796,6.83229814 C33.2303711,6.85234211 32.755176,6.86988059 32.2339943,6.88491358 C31.7128125,6.89994656 31.2273982,6.90746305 30.7777512,6.90746305 C30.4302968,6.90746305 30.1109452,6.90245206 29.8196966,6.89243007 C29.528448,6.88240808 29.2448638,6.8623641 28.9689441,6.83229814 L28.9689441,6.83229814 L28.9689441,7.14799078 C29.0813558,7.14799078 29.2116513,7.20311172 29.3598304,7.3133536 C29.5080095,7.42359548 29.6740723,7.64909022 29.8580188,7.98983784 L29.8580188,7.98983784 L32.8162472,13.3588678 L32.8164915,15.897187 C32.8164915,16.2302254 32.7925458,16.4864088 32.7446544,16.6657372 L32.7321827,16.7089681 C32.6759768,16.8893639 32.5661199,17.0096278 32.4026119,17.0697597 C32.2391039,17.1298916 31.9938419,17.1699796 31.6668259,17.1900236 L31.6668259,17.1900236 L31.6668259,17.4906832 C31.9120879,17.4706393 32.2493231,17.4581118 32.6785316,17.4531008 C33.1077401,17.4480898 33.5624967,17.4455843 34.0428014,17.4455843 C34.4720099,17.4455843 34.9037732,17.4480898 35.3380913,17.4531008 C35.7724094,17.4581118 36.1275283,17.4706393 36.403448,17.4906832 L36.403448,17.4906832 Z M46.0829408,17.4906832 L46.0829408,17.1895989 C45.6615955,17.1695266 45.3405705,17.124364 45.1198658,17.054111 C44.8991612,16.9838579 44.7511887,16.84837 44.6759485,16.6476471 C44.6007083,16.4469242 44.5630882,16.1458399 44.5630882,15.7443941 L44.5630882,15.7443941 L44.5630882,7.17854511 L45.3756826,7.17854511 C46.0077005,7.17854511 46.47419,7.26887041 46.7751509,7.449521 C47.0761118,7.6301716 47.2867844,7.92372881 47.4071688,8.33019265 C47.5275531,8.73665649 47.6228574,9.29115345 47.6930816,9.99368355 L47.6930816,9.99368355 L48.0391867,9.99368355 C48.0291547,9.83310524 48.0191226,9.64743657 48.0090906,9.43667755 C47.9990586,9.22591852 47.9940426,9.00010527 47.9940426,8.75923781 C47.9940426,8.56855108 48.0015666,8.29506615 48.0166146,7.93878303 C48.0316627,7.58249991 48.0592508,7.21367161 48.0993789,6.83229814 C47.6880656,6.84233428 47.2316083,6.85237042 46.7300067,6.86240657 C46.2284052,6.87244271 45.7293117,6.87746079 45.2327262,6.87746079 L45.2327262,6.87746079 L42.5015059,6.87746079 C41.9999044,6.87746079 41.5008109,6.87244271 41.0042254,6.86240657 C40.5076399,6.85237042 40.0486745,6.84233428 39.6273292,6.83229814 C39.6674573,7.21367161 39.6950454,7.58249991 39.7100934,7.93878303 C39.7251415,8.29506615 39.7326655,8.56855108 39.7326655,8.75923781 C39.7326655,9.00010527 39.7301575,9.22591852 39.7251415,9.43667755 C39.7201255,9.64743657 39.7075854,9.83310524 39.6875214,9.99368355 L39.6875214,9.99368355 L40.0336264,9.99368355 C40.1038506,9.29115345 40.1991549,8.73665649 40.3195393,8.33019265 C40.4399237,7.92372881 40.6531043,7.6301716 40.9590812,7.449521 C41.2650582,7.26887041 41.7290396,7.17854511 42.3510255,7.17854511 L42.3510255,7.17854511 L43.1636199,7.17854511 L43.1636199,15.7443941 C43.1636199,16.1458399 43.1259998,16.4469242 43.0507596,16.6476471 C42.9755193,16.84837 42.8275469,16.9838579 42.6068422,17.054111 C42.3861376,17.124364 42.0651126,17.1695266 41.6437673,17.1895989 L41.6437673,17.1895989 L41.6437673,17.4906832 C41.884536,17.4706109 42.203053,17.4580658 42.5993182,17.4530477 C42.9955834,17.4480296 43.4194367,17.4455206 43.8708781,17.4455206 C44.2821913,17.4455206 44.6884885,17.4480296 45.0897698,17.4530477 C45.491051,17.4580658 45.822108,17.4706109 46.0829408,17.4906832 L46.0829408,17.4906832 Z M59.5776398,17.4906832 L59.5776398,17.1895989 C59.2370739,17.1695266 58.9791453,17.129382 58.8038541,17.0691652 C58.6285628,17.0089483 58.5108673,16.8885146 58.4507674,16.707864 C58.3906675,16.5272134 58.3606176,16.2562375 58.3606176,15.8949363 L58.3606176,15.8949363 L58.3606176,8.42804506 C58.3606176,8.05670772 58.3906675,7.7832228 58.4507674,7.60759027 C58.5108673,7.43195775 58.6285628,7.31152402 58.8038541,7.24628908 C58.9791453,7.18105415 59.2370739,7.14341861 59.5776398,7.13338246 L59.5776398,7.13338246 L59.5776398,6.83229814 C59.3672902,6.84233428 59.0918326,6.85237042 58.7512667,6.86240657 C58.4107008,6.87244271 58.0450934,6.87746079 57.6544443,6.87746079 C57.3138784,6.87746079 56.9683042,6.87244271 56.6177217,6.86240657 C56.2671392,6.85237042 55.9766565,6.84233428 55.7462738,6.83229814 L55.7462738,6.83229814 L55.7462738,7.13338246 C56.0868396,7.14341861 56.3447682,7.18105415 56.5200594,7.24628908 C56.6953507,7.31152402 56.8130462,7.43195775 56.8731461,7.60759027 C56.933246,7.7832228 56.9632959,8.05670772 56.9632959,8.42804506 L56.9632959,8.42804506 L56.9630759,11.9808401 L52.0799624,11.9808401 L52.0801824,8.42804506 C52.0801824,8.08527213 52.105787,7.82587641 52.1569964,7.64985788 L52.1703322,7.60759027 C52.230432,7.43195775 52.3481276,7.31152402 52.5234188,7.24628908 C52.6987101,7.18105415 52.9566386,7.14341861 53.2972045,7.13338246 L53.2972045,7.13338246 L53.2972045,6.83229814 C53.0668217,6.84233428 52.7788432,6.85237042 52.433269,6.86240657 C52.0876948,6.87244271 51.7396165,6.87746079 51.389034,6.87746079 C50.9983849,6.87746079 50.6327774,6.87244271 50.2922116,6.86240657 C49.9516457,6.85237042 49.676188,6.84233428 49.4658385,6.83229814 L49.4658385,6.83229814 L49.4658385,7.13338246 C49.8064044,7.14341861 50.0643329,7.18105415 50.2396242,7.24628908 C50.4149154,7.31152402 50.532611,7.43195775 50.5927109,7.60759027 C50.6528107,7.7832228 50.6828606,8.05670772 50.6828606,8.42804506 L50.6828606,8.42804506 L50.6828606,15.8949363 C50.6828606,16.2562375 50.6528107,16.5272134 50.5927109,16.707864 C50.532611,16.8885146 50.4149154,17.0089483 50.2396242,17.0691652 C50.0643329,17.129382 49.8064044,17.1695266 49.4658385,17.1895989 L49.4658385,17.1895989 L49.4658385,17.4906832 C49.676188,17.4706109 49.9516457,17.4580658 50.2922116,17.4530477 C50.6327774,17.4480296 50.9983849,17.4455206 51.389034,17.4455206 C51.7396165,17.4455206 52.0876948,17.4480296 52.433269,17.4530477 C52.7788432,17.4580658 53.0668217,17.4706109 53.2972045,17.4906832 L53.2972045,17.4906832 L53.2972045,17.1895989 C52.9566386,17.1695266 52.6987101,17.129382 52.5234188,17.0691652 C52.3481276,17.0089483 52.230432,16.8885146 52.1703322,16.707864 C52.1102323,16.5272134 52.0801824,16.2562375 52.0801824,15.8949363 L52.0801824,15.8949363 L52.0799624,12.2819244 L56.9630759,12.2819244 L56.9632959,15.8949363 C56.9632959,16.2284451 56.9376912,16.4849903 56.8864819,16.664572 L56.8731461,16.707864 C56.8130462,16.8885146 56.6953507,17.0089483 56.5200594,17.0691652 C56.3447682,17.129382 56.0868396,17.1695266 55.7462738,17.1895989 L55.7462738,17.1895989 L55.7462738,17.4906832 C55.9766565,17.4706109 56.2671392,17.4580658 56.6177217,17.4530477 C56.9683042,17.4480296 57.3138784,17.4455206 57.6544443,17.4455206 C58.0450934,17.4455206 58.4107008,17.4480296 58.7512667,17.4530477 C59.0918326,17.4580658 59.3672902,17.4706109 59.5776398,17.4906832 L59.5776398,17.4906832 Z M70.5093168,17.7639752 L70.5093168,17.4573362 C70.3461067,17.447115 70.1675956,17.3781212 69.9737836,17.250355 C69.7799716,17.1225888 69.6065609,16.864501 69.4535514,16.4760917 L69.4535514,16.4760917 L65.7201202,6.83229814 L65.7201202,6.83229814 L65.475305,6.83229814 L61.8795823,16.123457 C61.7061716,16.5834154 61.5123596,16.9079415 61.2981463,17.0970355 C61.083933,17.2861295 60.8748201,17.4062298 60.6708075,17.4573362 L60.6708075,17.4573362 L60.6708075,17.7639752 C60.8238169,17.7435326 60.9895772,17.7307559 61.1680883,17.7256453 C61.3465993,17.7205346 61.5633627,17.7179793 61.8183785,17.7179793 C62.0835949,17.7179793 62.3717628,17.7205346 62.6828821,17.7256453 C62.9940013,17.7307559 63.2923698,17.7435326 63.5779875,17.7639752 L63.5779875,17.7639752 L63.5779875,17.4573362 C63.149561,17.447115 62.8231408,17.3755659 62.5987269,17.242689 C62.374313,17.1098122 62.2570057,16.8874989 62.2468051,16.5757494 C62.2366044,16.2639998 62.3386107,15.83215 62.552824,15.2802 L62.552824,15.2802 L63.1768787,13.6550138 L66.8769028,13.6550138 L67.81635,16.1694528 C68.0114925,16.6680744 68.0479757,17.0007013 67.9257995,17.1673335 L67.9081557,17.1890272 C67.7653468,17.3474573 67.4338263,17.4368937 66.9135941,17.4573362 L66.9135941,17.4573362 L66.9135941,17.7639752 C67.1278073,17.7435326 67.4083247,17.7307559 67.7551462,17.7256453 C68.1019677,17.7205346 68.4742907,17.7179793 68.8721154,17.7179793 C69.1679337,17.7179793 69.463752,17.7205346 69.7595703,17.7256453 C70.0553887,17.7307559 70.3053041,17.7435326 70.5093168,17.7639752 L70.5093168,17.7639752 Z M66.6832298,13.3913043 L63.1304348,13.3913043 L64.9319145,8.74534161 L66.6832298,13.3913043 Z M75.1004442,12.4646857 C75.5013903,12.4646857 75.8046058,12.5555307 76.0100907,12.7372206 C76.2155755,12.9189105 76.375954,13.1687342 76.491226,13.4866916 C76.606498,13.8046489 76.7092404,14.1806461 76.7994533,14.6146832 L76.7994533,14.6146832 L77.1302338,16.1287659 C77.2705649,16.7747745 77.4810616,17.2088115 77.7617239,17.430877 C78.0423861,17.6529424 78.3681548,17.7639752 78.7390299,17.7639752 C79.1499997,17.7639752 79.4682506,17.6807006 79.6937828,17.5141515 C79.919315,17.3476024 80.1373294,17.1078727 80.3478261,16.7949622 L80.3478261,16.7949622 L80.1222939,16.6284131 C79.9919864,16.8000092 79.8691967,16.9362766 79.7539247,17.0372155 C79.6386527,17.1381543 79.4958157,17.1936707 79.3254136,17.2037646 C79.1048932,17.2138584 78.9420089,17.12049 78.8367605,16.9236593 C78.7315122,16.7268285 78.6287698,16.4063477 78.5285332,15.9622168 L78.5285332,15.9622168 L78.1526463,14.4178524 C78.0123152,13.7920316 77.7943007,13.3302363 77.498603,13.0324668 C77.2029053,12.7346972 76.719264,12.530296 76.0476794,12.4192633 C76.0025729,12.4116928 75.9569966,12.4044379 75.9109505,12.3974983 L75.8823196,12.3935239 L75.9577786,12.3819351 C76.2207174,12.3390274 76.4607128,12.2794333 76.6777647,12.2031528 L76.7693823,12.1694396 C77.2805886,11.9726089 77.6840406,11.7227852 77.9797383,11.4199687 C78.275436,11.1171521 78.4834268,10.7941478 78.6037106,10.4509558 C78.7239945,10.1077637 78.7841364,9.78475938 78.7841364,9.48194284 C78.7841364,8.73499538 78.4834268,8.10917454 77.8820077,7.60448031 C77.2805886,7.09978608 76.373448,6.84743896 75.1605861,6.84743896 C74.9801604,6.84743896 74.674439,6.85248591 74.243422,6.86257979 C73.8124049,6.87267368 73.3613406,6.87772062 72.8902289,6.87772062 C72.5594484,6.87772062 72.2236561,6.87267368 71.8828519,6.86257979 C71.5420477,6.85248591 71.2663973,6.84239202 71.0559006,6.83229814 L71.0559006,6.83229814 L71.0559006,7.13511467 C71.3967048,7.14520856 71.6548138,7.18306063 71.8302277,7.24867088 C72.0056417,7.31428113 72.1234196,7.43540774 72.1835615,7.61205072 C72.2437034,7.7886937 72.2737743,8.06375206 72.2737743,8.43722579 L72.2737743,8.43722579 L72.2737743,15.9470759 C72.2737743,16.3104558 72.2437034,16.5829907 72.1835615,16.7646806 C72.1234196,16.9463705 72.0056417,17.0674971 71.8302277,17.1280604 C71.6548138,17.1886237 71.3967048,17.2289993 71.0559006,17.249187 L71.0559006,17.249187 L71.0559006,17.5520036 C71.2663973,17.5318158 71.5420477,17.5191985 71.8828519,17.5141515 C72.2236561,17.5091046 72.5895194,17.5065811 72.9804418,17.5065811 C73.3312696,17.5065811 73.6795915,17.5091046 74.0254075,17.5141515 C74.3712235,17.5191985 74.6594035,17.5318158 74.8899475,17.5520036 L74.8899475,17.5520036 L74.8899475,17.249187 C74.5491434,17.2289993 74.2910343,17.1886237 74.1156204,17.1280604 C73.9402065,17.0674971 73.8224286,16.9463705 73.7622867,16.7646806 C73.7021448,16.5829907 73.6720738,16.3104558 73.6720738,15.9470759 L73.6720738,15.9470759 L73.6718537,12.4646857 L74.8298056,12.4646857 L74.8298056,12.4646857 L75.1004442,12.4646857 Z M73.7890366,8.37985482 C73.7890366,7.86619771 73.8581145,7.52540597 73.9962703,7.35747961 C74.1344261,7.18955324 74.4304743,7.10559006 74.8844149,7.10559006 C75.7824278,7.10559006 76.4164643,7.32043703 76.7865245,7.75013096 C77.1565848,8.17982489 77.3416149,8.7848537 77.3416149,9.56521739 C77.3416149,10.0196064 77.2750041,10.4320138 77.1417824,10.8024396 C77.0085607,11.1728654 76.7569197,11.469206 76.3868595,11.6914615 C76.0167992,11.913717 75.4814454,12.0248447 74.780798,12.0248447 L74.780798,12.0248447 L73.7888199,12.0248447 L73.7890366,8.37985482 Z" id="HEYTHAR" fill="#FFFFFF" fill-rule="nonzero"></path>
        </g>
    </g>
</svg>
</file>

<file path="public/images/logotype.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="322px" height="88px" viewBox="0 0 322 88" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>logotype</title>
    <g id="logotype" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <rect id="Rectangle" fill="#333F48" x="5" y="4" width="312" height="81" rx="3"></rect>
        <path d="M67,64 L67,62.8983051 C65.8067303,62.8248588 64.9117781,62.6779661 64.3151432,62.4576271 C63.7185084,62.2372881 63.3176444,61.7966102 63.1125512,61.1355932 C62.9074579,60.4745763 62.8049113,59.4830508 62.8049113,58.1610169 L62.8049113,58.1610169 L62.8049113,30.8389831 C62.8049113,29.480226 62.8981355,28.4795198 63.0845839,27.8368644 C63.2710323,27.194209 63.6718963,26.7535311 64.287176,26.5148305 C64.9024557,26.2761299 65.8067303,26.1384181 67,26.1016949 L67,26.1016949 L67,25 C66.0677581,25.0367232 64.8465211,25.0734463 63.3362892,25.1101695 C61.8260573,25.1468927 60.2132788,25.1652542 58.4979536,25.1652542 C56.8944975,25.1652542 55.281719,25.1468927 53.659618,25.1101695 C52.0375171,25.0734463 50.7230559,25.0367232 49.7162347,25 L49.7162347,25 L49.7162347,26.1016949 C50.8722146,26.1384181 51.7578445,26.2761299 52.3731241,26.5148305 C52.9884038,26.7535311 53.3985903,27.194209 53.6036835,27.8368644 C53.8087767,28.4795198 53.9113233,29.480226 53.9113233,30.8389831 L53.9113233,30.8389831 L53.91121,43.8389831 L39.0885633,43.8389831 L39.0886767,30.8389831 C39.0886767,29.5847458 39.1681103,28.6355932 39.3269776,27.9915254 L39.3683492,27.8368644 C39.5547976,27.194209 39.9556617,26.7535311 40.5709413,26.5148305 C41.186221,26.2761299 42.0904957,26.1384181 43.2837653,26.1016949 L43.2837653,26.1016949 L43.2837653,25 C42.2769441,25.0367232 41.009095,25.0734463 39.4802183,25.1101695 C37.9513415,25.1468927 36.4038199,25.1652542 34.8376535,25.1652542 C33.0104593,25.1652542 31.3231014,25.1468927 29.7755798,25.1101695 C28.2280582,25.0734463 26.9695316,25.0367232 26,25 L26,25 L26,26.1016949 C27.15598,26.1384181 28.0416098,26.2761299 28.6568895,26.5148305 C29.2721692,26.7535311 29.6823556,27.194209 29.8874488,27.8368644 C30.0925421,28.4795198 30.1950887,29.480226 30.1950887,30.8389831 L30.1950887,30.8389831 L30.1950887,58.1610169 C30.1950887,59.4830508 30.0925421,60.4745763 29.8874488,61.1355932 C29.6823556,61.7966102 29.2814916,62.2372881 28.6848568,62.4576271 C28.0882219,62.6779661 27.1932697,62.8248588 26,62.8983051 L26,62.8983051 L26,64 C26.9695316,63.9265537 28.2280582,63.8806497 29.7755798,63.8622881 C31.3231014,63.8439266 33.0104593,63.8347458 34.8376535,63.8347458 C36.4038199,63.8347458 37.9513415,63.8439266 39.4802183,63.8622881 C41.009095,63.8806497 42.2769441,63.9265537 43.2837653,64 L43.2837653,64 L43.2837653,62.8983051 C42.0904957,62.8248588 41.1955434,62.6779661 40.5989086,62.4576271 C40.0022738,62.2372881 39.6014097,61.7966102 39.3963165,61.1355932 C39.1912233,60.4745763 39.0886767,59.4830508 39.0886767,58.1610169 L39.0886767,58.1610169 L39.0885633,44.940678 L53.91121,44.940678 L53.9113233,58.1610169 C53.9113233,59.3813559 53.8239463,60.3200782 53.6491923,60.9771838 L53.6036835,61.1355932 C53.3985903,61.7966102 52.9977262,62.2372881 52.4010914,62.4576271 C51.8044566,62.6779661 50.9095043,62.8248588 49.7162347,62.8983051 L49.7162347,62.8983051 L49.7162347,64 C50.7230559,63.9265537 52.0375171,63.8806497 53.659618,63.8622881 C55.281719,63.8439266 56.8944975,63.8347458 58.4979536,63.8347458 C60.2132788,63.8347458 61.8260573,63.8439266 63.3362892,63.8622881 C64.8465211,63.8806497 66.0677581,63.9265537 67,64 L67,64 Z M85.0702553,43.8389831 L85.0702703,30.1779661 C85.0702703,29.0028249 85.1633634,28.1490113 85.3495495,27.6165254 C85.5357357,27.0840395 85.8987988,26.7259887 86.4387387,26.5423729 C86.9786787,26.3587571 87.8072072,26.2669492 88.9243243,26.2669492 L88.9243243,26.2669492 L91.2144144,26.2669492 C92.8900901,26.2669492 94.3516517,26.5882768 95.5990991,27.2309322 C96.8465465,27.8735876 97.8612613,28.9752825 98.6432432,30.5360169 C99.4252252,32.0967514 100.002402,34.2175141 100.374775,36.8983051 L100.374775,36.8983051 L101.659459,36.8983051 C101.622222,36.4576271 101.584985,35.9067797 101.547748,35.2457627 C101.510511,34.5847458 101.491892,33.8870056 101.491892,33.1525424 C101.491892,32.3446328 101.51982,31.1878531 101.575676,29.6822034 C101.631532,28.1765537 101.733934,26.6158192 101.882883,25 C100.16997,25.0734463 98.2243243,25.1193503 96.0459459,25.1377119 C93.8675676,25.1560734 91.9219219,25.1652542 90.209009,25.1652542 L85.181982,25.1652542 C83.0966967,25.1652542 80.8810811,25.1468927 78.5351351,25.1101695 C76.1891892,25.0734463 74.0108108,25.0367232 72,25 L72,25 L72,26.1016949 C73.1543544,26.1384181 74.0387387,26.2761299 74.6531532,26.5148305 C75.2675676,26.7535311 75.6771772,27.194209 75.881982,27.8368644 C76.0867868,28.4795198 76.1891892,29.480226 76.1891892,30.8389831 L76.1891892,30.8389831 L76.1891892,58.1610169 C76.1891892,59.4830508 76.0867868,60.4745763 75.881982,61.1355932 C75.6771772,61.7966102 75.2768769,62.2372881 74.6810811,62.4576271 C74.0852853,62.6779661 73.1915916,62.8248588 72,62.8983051 L72,62.8983051 L72,64 C74.0108108,63.9265537 76.1891892,63.8806497 78.5351351,63.8622881 C80.8810811,63.8439266 83.0966967,63.8347458 85.181982,63.8347458 L85.181982,63.8347458 L90.209009,63.8347458 C92.0708709,63.8347458 94.1933934,63.8439266 96.5765766,63.8622881 C98.9597598,63.8806497 101.100901,63.9265537 103,64 C102.813814,62.3474576 102.702102,60.75 102.664865,59.2076271 C102.627628,57.6652542 102.609009,56.4717514 102.609009,55.6271186 C102.609009,53.7175141 102.664865,52.1751412 102.776577,51 L102.776577,51 L101.491892,51 C101.007808,53.9378531 100.30961,56.269774 99.3972973,57.9957627 C98.484985,59.7217514 97.3864865,60.9427966 96.1018018,61.6588983 C94.8171171,62.375 93.3369369,62.7330508 91.6612613,62.7330508 L91.6612613,62.7330508 L88.9243243,62.7330508 C87.8072072,62.7330508 86.9786787,62.6412429 86.4387387,62.4576271 C85.8987988,62.2740113 85.5357357,61.9067797 85.3495495,61.3559322 C85.1633634,60.8050847 85.0702703,59.960452 85.0702703,58.8220339 L85.0702703,58.8220339 L85.0702553,44.940678 L86.8576577,44.940678 C88.2478478,44.940678 89.3947548,45.2365851 90.2983784,45.8283992 L90.4882883,45.9597458 C91.4192192,46.6391243 92.136036,47.529661 92.6387387,48.6313559 C93.1414414,49.7330508 93.4858859,50.9265537 93.6720721,52.2118644 L93.6720721,52.2118644 L94.9567568,52.2118644 C94.9468268,52.0723164 94.9371451,51.9349718 94.9277117,51.7998305 L94.8495135,50.6430508 C94.7621301,49.3019209 94.7047848,48.2274011 94.6774775,47.4194915 C94.6402402,46.3177966 94.6216216,45.3079096 94.6216216,44.3898305 C94.6216216,43.4717514 94.6123123,42.4618644 94.5936937,41.3601695 C94.5750751,40.2584746 94.6402402,38.6610169 94.7891892,36.5677966 L94.7891892,36.5677966 L93.5045045,36.5677966 C93.3183183,37.559322 92.9831832,38.615113 92.4990991,39.7351695 C92.015015,40.855226 91.3261261,41.819209 90.4324324,42.6271186 C89.5387387,43.4350282 88.3471471,43.8389831 86.8576577,43.8389831 L86.8576577,43.8389831 L85.0702553,43.8389831 Z M133.203526,64 L133.203526,62.899859 C132.006944,62.8265162 131.109509,62.6798307 130.511218,62.4598025 C129.912927,62.2397743 129.510951,61.7997179 129.305288,61.1396333 C129.099626,60.4795487 128.996795,59.4894217 128.996795,58.1692525 L128.996795,58.1692525 L128.995901,45.3260226 L135.615385,32.4809591 C136.596955,30.6244711 137.496363,29.2111551 138.313608,28.2410112 L138.475962,28.0528914 C139.336004,27.0811001 140.17735,26.4301834 141,26.100141 L141,26.100141 L141,25 C140.439103,25.0366714 139.794071,25.0733427 139.064904,25.1100141 C138.335737,25.1466855 137.559829,25.1650212 136.737179,25.1650212 C135.577991,25.1650212 134.4375,25.1466855 133.315705,25.1100141 C132.19391,25.0733427 130.997329,25.0366714 129.725962,25 L129.725962,25 L129.725962,26.100141 C131.259081,26.1368124 132.446314,26.4760226 133.28766,27.1177715 C134.129006,27.7595205 134.502938,28.832158 134.409455,30.3356841 C134.315972,31.8392102 133.577457,33.9111425 132.19391,36.551481 L132.19391,36.551481 L127.836713,45.1380818 L119.293269,29.0155148 C118.876603,28.2323192 118.782357,27.6467466 119.010531,27.2587972 L119.06891,27.1727786 C119.368056,26.7877292 119.89156,26.5218618 120.639423,26.3751763 C121.387286,26.2284908 122.228632,26.1551481 123.163462,26.1551481 L123.163462,26.1551481 L123.163462,25 C121.592949,25.0733427 119.854167,25.1375176 117.947115,25.1925247 C116.040064,25.2475317 114.263889,25.2750353 112.61859,25.2750353 C111.347222,25.2750353 110.178686,25.2566996 109.112981,25.2200282 C108.047276,25.1833568 107.009615,25.1100141 106,25 L106,25 L106,26.1551481 C106.411325,26.1551481 106.888088,26.3568406 107.430288,26.7602257 C107.972489,27.1636107 108.580128,27.9887165 109.253205,29.235543 L109.253205,29.235543 L120.077632,48.8813117 L120.078526,58.1692525 C120.078526,59.3878702 119.990906,60.3252685 119.815667,60.9814473 L119.770032,61.1396333 C119.56437,61.7997179 119.162393,62.2397743 118.564103,62.4598025 C117.965812,62.6798307 117.068376,62.8265162 115.871795,62.899859 L115.871795,62.899859 L115.871795,64 C116.769231,63.9266573 118.003205,63.8808181 119.573718,63.8624824 C121.144231,63.8441467 122.808226,63.8349788 124.565705,63.8349788 C126.136218,63.8349788 127.716079,63.8441467 129.305288,63.8624824 C130.894498,63.8808181 132.19391,63.9266573 133.203526,64 L133.203526,64 Z M168.62167,64 L168.62167,62.8983051 C167.079929,62.8248588 165.905269,62.6596045 165.097691,62.4025424 C164.290112,62.1454802 163.748668,61.6497175 163.473357,60.9152542 C163.198046,60.180791 163.060391,59.079096 163.060391,57.6101695 L163.060391,57.6101695 L163.060391,26.2669492 L166.033748,26.2669492 C168.346359,26.2669492 170.053286,26.5974576 171.154529,27.2584746 C172.255773,27.9194915 173.026643,28.9936441 173.46714,30.4809322 C173.907638,31.9682203 174.256365,33.9971751 174.513321,36.5677966 L174.513321,36.5677966 L175.779751,36.5677966 C175.743043,35.980226 175.706335,35.3008475 175.669627,34.529661 C175.632919,33.7584746 175.614565,32.9322034 175.614565,32.0508475 C175.614565,31.3531073 175.642096,30.3524011 175.697158,29.0487288 C175.75222,27.7450565 175.853168,26.3954802 176,25 C174.494967,25.0367232 172.824748,25.0734463 170.989343,25.1101695 C169.153937,25.1468927 167.327709,25.1652542 165.510657,25.1652542 L165.510657,25.1652542 L155.516874,25.1652542 C153.681468,25.1652542 151.85524,25.1468927 150.038188,25.1101695 C148.221137,25.0734463 146.541741,25.0367232 145,25 C145.146832,26.3954802 145.24778,27.7450565 145.302842,29.0487288 C145.357904,30.3524011 145.385435,31.3531073 145.385435,32.0508475 C145.385435,32.9322034 145.376258,33.7584746 145.357904,34.529661 C145.33955,35.3008475 145.293665,35.980226 145.220249,36.5677966 L145.220249,36.5677966 L146.486679,36.5677966 C146.743635,33.9971751 147.092362,31.9682203 147.53286,30.4809322 C147.973357,28.9936441 148.753404,27.9194915 149.873002,27.2584746 C150.992599,26.5974576 152.690349,26.2669492 154.966252,26.2669492 L154.966252,26.2669492 L157.939609,26.2669492 L157.939609,57.6101695 C157.939609,59.079096 157.801954,60.180791 157.526643,60.9152542 C157.251332,61.6497175 156.709888,62.1454802 155.902309,62.4025424 C155.094731,62.6596045 153.920071,62.8248588 152.37833,62.8983051 L152.37833,62.8983051 L152.37833,64 C153.259325,63.9265537 154.424808,63.8806497 155.874778,63.8622881 C157.324748,63.8439266 158.875666,63.8347458 160.527531,63.8347458 C162.032564,63.8347458 163.519242,63.8439266 164.987567,63.8622881 C166.455891,63.8806497 167.667259,63.9265537 168.62167,64 L168.62167,64 Z M218,64 L218,62.8983051 C216.753839,62.8248588 215.810054,62.6779661 215.168648,62.4576271 C214.527241,62.2372881 214.096582,61.7966102 213.876672,61.1355932 C213.656761,60.4745763 213.546805,59.4830508 213.546805,58.1610169 L213.546805,58.1610169 L213.546805,30.8389831 C213.546805,29.480226 213.656761,28.4795198 213.876672,27.8368644 C214.096582,27.194209 214.527241,26.7535311 215.168648,26.5148305 C215.810054,26.2761299 216.753839,26.1384181 218,26.1016949 L218,26.1016949 L218,25 C217.230312,25.0367232 216.222387,25.0734463 214.976226,25.1101695 C213.730064,25.1468927 212.392273,25.1652542 210.962853,25.1652542 C209.716691,25.1652542 208.452204,25.1468927 207.169391,25.1101695 C205.886578,25.0734463 204.823675,25.0367232 203.980684,25 L203.980684,25 L203.980684,26.1016949 C205.226845,26.1384181 206.170629,26.2761299 206.812036,26.5148305 C207.453442,26.7535311 207.884101,27.194209 208.104012,27.8368644 C208.323923,28.4795198 208.433878,29.480226 208.433878,30.8389831 L208.433878,30.8389831 L208.433073,43.8389831 L190.565317,43.8389831 L190.566122,30.8389831 C190.566122,29.5847458 190.659812,28.6355932 190.847191,27.9915254 L190.895988,27.8368644 C191.115899,27.194209 191.546558,26.7535311 192.187964,26.5148305 C192.829371,26.2761299 193.773155,26.1384181 195.019316,26.1016949 L195.019316,26.1016949 L195.019316,25 C194.176325,25.0367232 193.122585,25.0734463 191.858098,25.1101695 C190.593611,25.1468927 189.31996,25.1652542 188.037147,25.1652542 C186.607727,25.1652542 185.269936,25.1468927 184.023774,25.1101695 C182.777613,25.0734463 181.769688,25.0367232 181,25 L181,25 L181,26.1016949 C182.246161,26.1384181 183.189946,26.2761299 183.831352,26.5148305 C184.472759,26.7535311 184.903418,27.194209 185.123328,27.8368644 C185.343239,28.4795198 185.453195,29.480226 185.453195,30.8389831 L185.453195,30.8389831 L185.453195,58.1610169 C185.453195,59.4830508 185.343239,60.4745763 185.123328,61.1355932 C184.903418,61.7966102 184.472759,62.2372881 183.831352,62.4576271 C183.189946,62.6779661 182.246161,62.8248588 181,62.8983051 L181,62.8983051 L181,64 C181.769688,63.9265537 182.777613,63.8806497 184.023774,63.8622881 C185.269936,63.8439266 186.607727,63.8347458 188.037147,63.8347458 C189.31996,63.8347458 190.593611,63.8439266 191.858098,63.8622881 C193.122585,63.8806497 194.176325,63.9265537 195.019316,64 L195.019316,64 L195.019316,62.8983051 C193.773155,62.8248588 192.829371,62.6779661 192.187964,62.4576271 C191.546558,62.2372881 191.115899,61.7966102 190.895988,61.1355932 C190.676077,60.4745763 190.566122,59.4830508 190.566122,58.1610169 L190.566122,58.1610169 L190.565317,44.940678 L208.433073,44.940678 L208.433878,58.1610169 C208.433878,59.3813559 208.340188,60.3200782 208.152809,60.9771838 L208.104012,61.1355932 C207.884101,61.7966102 207.453442,62.2372881 206.812036,62.4576271 C206.170629,62.6779661 205.226845,62.8248588 203.980684,62.8983051 L203.980684,62.8983051 L203.980684,64 C204.823675,63.9265537 205.886578,63.8806497 207.169391,63.8622881 C208.452204,63.8439266 209.716691,63.8347458 210.962853,63.8347458 C212.392273,63.8347458 213.730064,63.8439266 214.976226,63.8622881 C216.222387,63.8806497 217.230312,63.9265537 218,64 L218,64 Z M258,65 L258,63.8779804 C257.402799,63.8405797 256.749611,63.5881253 256.040435,63.1206171 C255.33126,62.6531089 254.696734,61.7087424 254.136858,60.2875175 L254.136858,60.2875175 L240.475894,25 L240.475894,25 L239.580093,25 L226.423017,58.997195 C225.788491,60.6802244 225.079316,61.8676952 224.29549,62.5596073 C223.511664,63.2515194 222.746501,63.6909771 222,63.8779804 L222,63.8779804 L222,65 C222.559876,64.9251987 223.166407,64.8784479 223.819596,64.8597475 C224.472784,64.8410472 225.265941,64.8316971 226.199067,64.8316971 C227.169518,64.8316971 228.22395,64.8410472 229.362364,64.8597475 C230.500778,64.8784479 231.592535,64.9251987 232.637636,65 L232.637636,65 L232.637636,63.8779804 C231.069984,63.8405797 229.875583,63.5787751 229.054432,63.0925666 C228.233281,62.6063581 227.804044,61.7928939 227.766719,60.6521739 C227.729393,59.511454 228.102644,57.9312763 228.88647,55.911641 L228.88647,55.911641 L231.169942,49.9649369 L244.708667,49.9649369 L248.14619,59.1654979 C248.860234,60.9899994 248.993729,62.2071114 248.546675,62.816834 L248.482115,62.8962132 C247.959565,63.4759233 246.746501,63.8031791 244.842924,63.8779804 L244.842924,63.8779804 L244.842924,65 C245.62675,64.9251987 246.653188,64.8784479 247.92224,64.8597475 C249.191291,64.8410472 250.553655,64.8316971 252.009331,64.8316971 C253.091757,64.8316971 254.174184,64.8410472 255.25661,64.8597475 C256.339036,64.8784479 257.253499,64.9251987 258,65 L258,65 Z M244,49 L231,49 L237.591778,32 L244,49 Z M274.799353,45.6094183 C276.266451,45.6094183 277.375944,45.9418283 278.127832,46.6066482 C278.87972,47.2714681 279.466559,48.1855956 279.88835,49.3490305 C280.31014,50.5124654 280.686084,51.8882733 281.016181,53.4764543 L281.016181,53.4764543 L282.226537,59.0166205 C282.740022,61.3804247 283.510248,62.9686057 284.537217,63.7811634 C285.564186,64.5937211 286.756203,65 288.113269,65 C289.617044,65 290.781553,64.6952909 291.606796,64.0858726 C292.432039,63.4764543 293.229773,62.5992613 294,61.4542936 L294,61.4542936 L293.174757,60.8448753 C292.69795,61.4727608 292.248652,61.9713758 291.826861,62.3407202 C291.40507,62.7100646 290.882416,62.9132041 290.2589,62.9501385 C289.451996,62.9870729 288.855987,62.6454294 288.470874,61.9252078 C288.085761,61.2049861 287.709817,60.0323176 287.343042,58.4072022 L287.343042,58.4072022 L285.967638,52.7562327 C285.454153,50.4662973 284.656419,48.7765466 283.574434,47.6869806 C282.492449,46.5974146 280.722762,45.8494922 278.265372,45.4432133 C278.100324,45.4155125 277.933556,45.3889658 277.765069,45.3635734 L277.660306,45.3490305 L277.936417,45.3066262 C278.898534,45.1496228 279.776699,44.9315627 280.570912,44.6524456 L280.906149,44.5290859 C282.776699,43.8088643 284.252967,42.8947368 285.334951,41.7867036 C286.416936,40.6786704 287.177994,39.4967682 287.618123,38.2409972 C288.058252,36.9852262 288.278317,35.8033241 288.278317,34.6952909 C288.278317,31.9621422 287.177994,29.6722068 284.977346,27.8254848 C282.776699,25.9787627 279.457389,25.0554017 275.019417,25.0554017 C274.359223,25.0554017 273.240561,25.0738689 271.66343,25.1108033 C270.0863,25.1477378 268.435814,25.166205 266.711974,25.166205 C265.501618,25.166205 264.272923,25.1477378 263.02589,25.1108033 C261.778857,25.0738689 260.770227,25.0369344 260,25 L260,25 L260,26.1080332 C261.247033,26.1449677 262.191478,26.2834718 262.833333,26.5235457 C263.475189,26.7636196 263.906149,27.2068329 264.126214,27.8531856 C264.346278,28.4995383 264.456311,29.5060018 264.456311,30.8725762 L264.456311,30.8725762 L264.456311,58.3518006 C264.456311,59.6814404 264.346278,60.6786704 264.126214,61.3434903 C263.906149,62.0083102 263.475189,62.4515235 262.833333,62.6731302 C262.191478,62.8947368 261.247033,63.0424746 260,63.1163435 L260,63.1163435 L260,64.2243767 C260.770227,64.1505078 261.778857,64.1043398 263.02589,64.0858726 C264.272923,64.0674054 265.61165,64.0581717 267.042071,64.0581717 C268.325782,64.0581717 269.600324,64.0674054 270.865696,64.0858726 C272.131068,64.1043398 273.185545,64.1505078 274.029126,64.2243767 L274.029126,64.2243767 L274.029126,63.1163435 C272.782093,63.0424746 271.837648,62.8947368 271.195793,62.6731302 C270.553937,62.4515235 270.122977,62.0083102 269.902913,61.3434903 C269.682848,60.6786704 269.572816,59.6814404 269.572816,58.3518006 L269.572816,58.3518006 L269.57201,45.6094183 L273.809061,45.6094183 L273.809061,45.6094183 L274.799353,45.6094183 Z M270.000793,30.6626506 C270.000793,28.7831325 270.253555,27.5361446 270.75908,26.9216867 C271.264605,26.3072289 272.347872,26 274.008882,26 C277.294792,26 279.61479,26.7861446 280.968874,28.3584337 C282.322958,29.9307229 283,32.1445783 283,35 C283,36.6626506 282.756265,38.1716867 282.268795,39.5271084 C281.781324,40.8825301 280.860547,41.9668675 279.506463,42.7801205 C278.152379,43.5933735 276.193471,44 273.629738,44 L273.629738,44 L270,44 L270.000793,30.6626506 Z" id="HEYTHAR" fill="#FFFFFF" fill-rule="nonzero"></path>
    </g>
</svg>
</file>

<file path="public/robots.txt">
User-agent: *
Disallow: /
</file>

<file path=".eslintrc">
{
    "extends": "next"
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/react-day-picker/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build
/public/storybook

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env.local
.env.development.local
.env.test.local
.env.production.local

# vercel
.vercel

# translations
service-account.json
.json-autotranslate-cache

.idea
# .env
.env*.local

# Local .terraform directories
**/.terraform/*

# .tfstate files
*.tfstate
*.tfstate.*

# Terraform crash log files
crash.log

# Ignore any .tfvars files that are generated automatically for each Terraform run. Most
# .tfvars files are managed as part of configuration and so should be included in
# version control.
#
aws.tfvars

# Ignore override files as they are usually used to override resources locally and so
# are not checked in
override.tf
override.tf.json
*_override.tf
*_override.tf.json

# Include override files you do wish to add to version control using negated pattern
#
# !example_override.tf

# Include tfplan files to ignore the plan output of command: terraform plan -out=tfplan
# example: *tfplan*

#cache
/react-day-picker/.yarn/cache

.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions
</file>

<file path=".prettierignore">
# Ignore artifacts: 
react-day-picker
</file>

<file path="babel.config.json">
{
    "presets": ["next/babel"],
    "plugins": [
        [
            "styled-components",
            {
                "ssr": true,
                "displayName": true,
                "preprocess": true
            }
        ]
    ]
}
</file>

<file path="CONTRIBUTING.md">
# Contributing

When contributing to this repository, please first discuss the change you wish to make via issue,
email, or any other method with the owners of this repository before making a change. 

Please note we have a code of conduct, please follow it in all your interactions with the project.

## Pull Request Process

1. Ensure any install or build dependencies are removed before the end of the layer when doing a build.
2. Update the README.md with details of changes to the interface, this includes new environment variables, exposed ports, useful file locations and container parameters.
3. Increase the version numbers in any relevant files to the new version that this Pull Request would represent. The versioning scheme we use is [SemVer](http://semver.org/).
4. The PR will be merged by the primary maintainer team.

## Code of Conduct

### Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.

### Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
  address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

### Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.

### Scope

This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.

### Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at dev-support@blvd.co. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately. 

Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.
</file>

<file path="LICENSE.md">
Copyright 2022 Boulevard Inc

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</file>

<file path="material-ui.d.ts">
import { PaletteOptions } from '@mui/material/styles'
import { Colors } from './enums/colors'

type Custom = Record<Colors, string>

declare module '@mui/material/styles' {
    export interface Palette {
        custom: Custom
    }

    export interface PaletteOptions {
        custom: Custom
    }
}
</file>

<file path="next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/types/global" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.
</file>

<file path="next.config.js">
const withTM = require('next-transpile-modules')(['@boulevard/blvd-book-sdk'])

// Note: These variables can be named however you'd like, but be sure what you set in your environment(s)
// match what's in here!
module.exports = withTM({
    env: {
            NEXT_PUBLIC_MAPBOX_TOKEN: process.env.MAPBOX_API_TOKEN_DEVELOPMENT,
            NEXT_PUBLIC_BLVD_BUSINESS_ID: process.env.NEXT_PUBLIC_BLVD_BUSINESS_ID,
            NEXT_PUBLIC_BLVD_API_KEY: process.env.NEXT_PUBLIC_BLVD_API_KEY,
            NEXT_PUBLIC_BLVD_DEFAULT_LOCATION_EXTERNAL_ID:
              process.env.NEXT_PUBLIC_BLVD_DEFAULT_LOCATION_EXTERNAL_ID_DEVELOPMENT,
            GOOGLE_ANALYTICS_KEY: process.env.GOOGLE_ANALYTICS_KEY_DEVELOPMENT,
            NEXT_PUBLIC_GOOGLE_MAPS_API_KEY: process.env.GOOGLE_MAPS_API_KEY_DEVELOPMENT,
        },
})
</file>

<file path="package.json">
{
    "name": "create-booking-flow",
    "version": "0.0.1",
    "private": true,
    "scripts": {
        "prepare": "husky install",
        "dev": "npm run next:dev",
        "dev:all": "concurrently -k -c 'red,blue' -n 'next' 'npm:next:dev'",
        "prebuild": "next lint",
        "build": "npm run prebuild && npm run next:build && npm run next:export",
        "start": "next start",
        "next:dev": "next dev -p 3000",
        "next:build": "next build",
        "next:export": "next export",
        "deploy:www": "ts-node --skip-project deploy.ts",
        "pretty-quick": "pretty-quick --staged",
        "lint": "prettier -c \"**/*.{js,ts,jsx,tsx}\"",
        "lint:fix": "prettier -w \"**/*.{js,ts,jsx,tsx}\""
    },
    "dependencies": {
        "@boulevard/blvd-book-sdk": "^2.0.2",
        "@date-io/date-fns": "1.x",
        "@emotion/react": "^11.4.1",
        "@emotion/styled": "^11.3.0",
        "@mapbox/mapbox-sdk": "^0.13.2",
        "@mui/icons-material": "^5.0.3",
        "@mui/lab": "^5.0.0-alpha.50",
        "@mui/material": "^5.0.3",
        "@mui/styles": "^5.0.1",
        "aws-sdk": "^2.968.0",
        "axios": "0.21.1",
        "bootstrap": "^5.1.0",
        "card-validator": "^8.1.1",
        "date-fns": "^2.23.0",
        "date-fns-tz": "^1.1.6",
        "decimal.js-light": "^2.5.1",
        "detect-node": "2.x",
        "formik": "^2.2.9",
        "glob": "^7.1.6",
        "google-map-react": "^2.1.10",
        "haversine": "^1.1.1",
        "ics": "^2.31.0",
        "modern-css-reset": "1.x",
        "nanoid": "3.x",
        "next": "11.x",
        "next-transpile-modules": "8.x",
        "ora": "^5.4.1",
        "polished": "4.x",
        "react": "17.x",
        "react-day-picker": "7.4.10",
        "react-device-detect": "^1.17.0",
        "react-dom": "17.x",
        "react-icons": "^4.2.0",
        "react-map-gl": "^6.1.17",
        "react-spinners": "^0.11.0",
        "react-spring": "^9.3.2",
        "react-text-mask": "^5.4.3",
        "recoil": "^0.4.0",
        "sass": "^1.37.5",
        "styled-components": "5.x",
        "ts-node": "^10.2.0",
        "use-places-autocomplete": "^1.9.4",
        "yup": "^0.32.9"
    },
    "devDependencies": {
        "@babel/core": "7.x",
        "@types/detect-node": "2.x",
        "@types/glob": "^7.2.0",
        "@types/google-map-react": "^2.1.2",
        "@types/gtag.js": "^0.0.8",
        "@types/haversine": "^1.1.5",
        "@types/mapbox-gl": "^2.4.2",
        "@types/node": "^16.4.12",
        "@types/react": "17.x",
        "@types/styled-components": "5.x",
        "babel-loader": "8.x",
        "babel-plugin-styled-components": "1.x",
        "concurrently": "6.x",
        "eslint": "^7.29.0",
        "eslint-config-next": "^11.0.1",
        "husky": "^7.0.0",
        "prettier": "2.x",
        "pretty-quick": "3.x",
        "query-string": "7.0.1",
        "tsconfig-paths-webpack-plugin": "3.x",
        "typescript": "4.x",
        "webpack": "5.x"
    },
    "prettier": {
        "trailingComma": "es5",
        "tabWidth": 4,
        "semi": false,
        "singleQuote": true,
        "overrides": [
            {
                "files": "*.mdx",
                "options": {
                    "semi": true
                }
            }
        ]
    },
    "resolutions": {
        "webpack": "5.x"
    }
}
</file>

<file path="README.md">
[![TypeScript](https://badgen.net/badge/icon/typescript?icon=typescript&label)](https://typescriptlang.org)
[![GitHub license](https://img.shields.io/github/license/Boulevard/create-booking-flow)](https://github.com/Boulevard/create-booking-flow/blob/master/LICENSE.md)
[![GitHub release](https://img.shields.io/github/release/Boulevard/create-booking-flow)](https://github.com/Boulevard/create-booking-flow/releases/)
[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square)](https://github.com/Boulevard/create-booking-flow/compare)

<div align="center">
  <h2 align="center">Create Booking Flow starter kit</h2>

  <p align="center">
    <a href="https://github.com/Boulevard/create-booking-flow/issues">Report a Bug</a>
    ·
    <a href="https://github.com/Boulevard/create-booking-flow/issues">Request a Feature</a>
  </p>
</div>


<details>
  <summary>Table of Contents</summary>
  <ol>
    <li><a href="#about-the-project">About the project</a></li>
    <li><a href="#setup-and-run">Setup and run</a></li>
    <li><a href="#contributing">Contributing</a></li>
    <li><a href="#issues">Issues</a></li>
  </ol>
</details>

<hr />

## About the project
<br />

![Screenshot - After choosing the service and the service provider you will be presented with the date/time selection step](https://user-images.githubusercontent.com/100217514/157887586-8c9a5773-d49c-4943-8e21-fb92297fa82b.png)

<br />

Create Booking Flow is the easiest way to have a custom booking flow for your [Boulevard](https://joinblvd.com) integration. By just providing basic information, your Business ID and your API Key, you can have this project up and running. This enables you to customize your Boulevard integration easily, and gives you the power to provide a seamless experience to your end users.

The starter kit has MapBox and Google Maps built in, alongside Google Analytics. It also has 
multiple flows that control how the user booking flow looks like, and it's all a matter of changing the `env` configuration.

## Setup and run

This is a [typescript](https://www.typescriptlang.org/) project so it requires some experience with typescript to be able to do advanced customizations with the project. It uses [Next.js](https://nextjs.org/) framework with Material UI on top of it. 

To setup the project locally follow these steps:

1. Configure your environment. The following tools must be installed before you start.

- NodeJS
- Yarn package manager (can be installed via npm by running `npm install -g yarn`)
- ts-node `npm install -g ts-node`

2. Install all required packages for the project by running the following command.

    ```
    yarn
    ```

3. To connect to a Boulevard dashboard, manually set the following values in the `.env` file. Reach out to dev-support@blvd.co to request a developer sandbox and retrieve these values. Note: must be a current Boulevard customer with an Enterprise license.

    Required info:

    ```dosini
    NEXT_PUBLIC_BLVD_BUSINESS_ID=VALID_ID_HERE
    NEXT_PUBLIC_BLVD_API_KEY=VALID_KEY_HERE
    ```
    Optional:

    ```dosini
    NEXT_PUBLIC_MAPBOX_TOKEN=VALID_KEY_HERE
    GOOGLE_MAPS_API_KEY_DEVELOPMENT=VALID_KEY_HERE
    GOOGLE_ANALYTICS_KEY=VALID_KEY_HERE
    NEXT_PUBLIC_BLVD_PLATFORM=
    ```

4. You can customize a few primary aspects of your booking flow very easily using the App UI settings in the .env file.

    **4.1.** *NEXT_PUBLIC_FLOW_TYPE*

    Use the key `NEXT_PUBLIC_FLOW_TYPE` to set the flow type. The possible values are `SelectLocationFirst` and `SelectServiceFirst`. Default is `SelectLocationFirst`.

    Use `SelectLocationFirst` if you want the user to choose a location as the first step of the flow. In this case, the second step for the user would be to choose a service from the list of the services available at the chosen location. 

    Use `SelectServiceFirst` if you want the user to choose a service as the first step of the flow. In this case, the second step for the user would be to choose a location from the list of the locations where the chosen service is available.


    **4.2.** NEXT_PUBLIC_MAP_TYPE

    Use the key `NEXT_PUBLIC_MAP_TYPE` to set a map provider you want to use. Possible values are `MapBox`, `Google` and 'None'. Default is `MapBox`


    **4.3.** NEXT_PUBLIC_DATE_TIME_TYPE

    Use the key `NEXT_PUBLIC_DATE_TIME_TYPE` to set how the app should display appointment availability (dates & times). Possible values are `ShowTimeForOneDay` and `ShowTimeForManyDays`. Default is `ShowTimeForOneDay`.

    Use `ShowTimeForOneDay` to display a single day at a time (Calendar UI).

    Use `ShowTimeForManyDays` to display a list of days & times.


    **4.4.** NEXT_PUBLIC_DISPLAY_APP_SETTINGS

    You can play with these settings via the UI in the browser. To display a popup in the UI set `NEXT_PUBLIC_DISPLAY_APP_SETTINGS` to `Yes`. Default is `No`

    **4.5.** NEXT_PUBLIC_BLVD_PLATFORM

    This env key controls the API host target. If you set the value to `live` the starter kit will target the Boulevard production API. You need to have production credentials to be able to do this.

5. Ingress point

    Use an ingress point if you want to preselect a location for the user. Pass a location's externalId (set in your Boulevard Dashboard) in the `storeId` URL parameter.

    Example:
    ```
    http://localhost:3000?storeId=228
    ```


6. Run the dev server with the following command.

    ```
    yarn run next:build
    yarn run next:dev
    ```

## Contributing
Pull requests are welcome. See the [contribution guidelines](https://github.com/Boulevard/create-booking-flow/blob/master/CONTRIBUTING.md) for more information.

## Issues

If you encounter any problems while trying to run the starter kit please create an issue.
</file>

<file path="tsconfig.json">
{
    "compilerOptions": {
        "baseUrl": "./",
        "target": "es2017",
        "lib": ["dom", "dom.iterable", "esnext"],
        "allowJs": true,
        "skipLibCheck": true,
        "strict": false,
        "forceConsistentCasingInFileNames": true,
        "noEmit": true,
        "esModuleInterop": true,
        "module": "esnext",
        "moduleResolution": "node",
        "resolveJsonModule": true,
        "strictNullChecks": true,
        "isolatedModules": true,
        "jsx": "preserve",
        "paths": {
            "styles/*": ["lib/styles/*"],
            "components/*": ["./components/*"],
            "lib/*": ["./lib/*"],
            "config/*": ["./config/*"],
            "public/*": ["./public/*"]
        }
    },
    "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
    "exclude": ["node_modules", "deploy.ts"]
}
</file>

</files>
